<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="算法学习">
    
    <meta name="author" content="卡布叻_米菲">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://carolinebaby.github.io/2024/01/13/数据结构/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="数据结构课程笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Caroline&#39;s World">
<meta property="og:description" content="数据结构课程笔记">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230830211617075.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230830212935201.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230901144020730.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230901144705812.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231022164632839.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231023214957349.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024000908133.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024100455394.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024101501211.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024102257893.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024111147459.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024125103470.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024135621931.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024151926560.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231027145320894.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024152930416.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024154608246.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024184916937.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024194456519.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024200510456.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024215659224.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024213600750.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025151319839.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025153910874.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025162301118.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025165229367.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025190842964.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231026205946750.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231027150900012.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025210624589.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231103143156350.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204000733780.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204002918691.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204121811909.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204134424785.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204141023744.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204150913950.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204183115402.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204190227265.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204190411494.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/b9fe69db719078c7006664369b19e856.jpg">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/df406fce44167347b7ce3a897992150a.jpg">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/80d5b8ee64b399d63435062e71e63bda.jpg">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204195339788.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204195533018.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204214803077.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204214831681.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204215644750.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204215755020.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204221138133.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204232434350.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204233719046.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204235017538.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204235411235.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231205001149352.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231205002538761.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231205003310705.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231205085907191.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231205090918799.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231205101134528.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206145850919.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206193025842.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206195619668.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206203424046.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206204037559.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206210541751.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206212931462.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206213022944.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206215457461.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231207002833708.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231207003715136.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231207101130506.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231207103226348.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206232532102.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240101165055003.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240101151548473.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240101153203645.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240101195643494.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240101200013294.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240101200424507.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240101200820982.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240101202400186.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240102003452393.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240102013827556.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240102093446842.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240102094320842.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240109145224036.png">
<meta property="og:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240102103006941.png">
<meta property="article:published_time" content="2024-01-13T01:29:29.000Z">
<meta property="article:modified_time" content="2024-01-12T16:39:28.041Z">
<meta property="article:author" content="Caroline">
<meta property="article:tag" content="算法学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://carolinebaby.github.io/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230830211617075.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
    <meta name="theme-color" content="#0072BC">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <!--- Page Info-->
    
    <title>
        
            数据结构 -
        
        卡布叻_米菲的世界
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
        <style>
    :root {
        --preloader-background-color: #fff;
        --preloader-text-color: #000;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --preloader-background-color: #202124;
            --preloader-text-color: #fff;
        }
    }

    @media (prefers-color-scheme: light) {
        :root {
            --preloader-background-color: #fff;
            --preloader-text-color: #000;
        }
    }

    @media (max-width: 600px) {
        .ml13 {
            font-size: 2.6rem !important; /* Adjust this value as needed */
        }
    }

    .preloader {
        display: flex;
        flex-direction: column;
        gap: 1rem; /* Tailwind 'gap-4' is 1rem */
        align-items: center;
        justify-content: center;
        position: fixed;
        padding: 12px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh; /* 'h-screen' is 100% of the viewport height */
        background-color: var(--preloader-background-color);
        z-index: 1100; /* 'z-[1100]' sets the z-index */
        transition: opacity 0.2s ease-in-out;
    }

    .ml13 {
        font-size: 3.2rem;
        /* text-transform: uppercase; */
        color: var(--preloader-text-color);
        letter-spacing: -1px;
        font-weight: 500;
        font-family: 'Chillax-Variable', sans-serif;
        text-align: center;
    }

    .ml13 .word {
        display: inline-flex;
        flex-wrap: wrap;
        white-space: nowrap;
    }

    .ml13 .letter {
        display: inline-block;
        line-height: 1em;
    }
</style>

<div class="preloader">
    
<script src="/js/libs/anime.min.js"></script>

    <h1 class="ml13">
        卡布叻_米菲的世界
    </h1>
    <script>
        var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });


        anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [100,0],
                translateZ: 0,
                opacity: [0,1],
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i
            }).add({
            targets: '.ml13 .letter',
            translateY: [0,-100],
            opacity: [1,0],
            easing: "easeInExpo",
            duration: 1200,
            delay: (el, i) => 100 + 30 * i
        });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            hidePreloaderAfterTimeout(1000); // Hide after 1000 milliseconds once the window has loaded
        });

        // Backup failsafe: Hide preloader after a maximum of 5000 milliseconds, regardless of the window load event
        hidePreloaderAfterTimeout(5000);

        function hidePreloaderAfterTimeout(delay) {
            setTimeout(function () {
                var preloader = document.querySelector('.preloader');
                preloader.style.opacity = '0';
                setTimeout(function () {
                    preloader.style.display = 'none';
                }, 200);
            }, delay);
        }
    </script>
</div>
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    <!--- Font Part-->
    
    
    
    


    <script id="hexo-configurations">
    window.config = {"hostname":"carolinebaby.github.io","root":"/","language":"en"};
    window.theme = {"articles":{"style":{"font_size":"18px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left","headings_top_spacing":{"h1":"5rem","h2":"4rem","h3":"2.8rem","h4":"2.5rem","h5":"2.2rem","h6":"2rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#0072BC","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"https://cdn.dynamicwallpaper.club/wallpapers/0lt9t1k10ae/thumbs/1600/2.jpg","dark":"https://cdn.dynamicwallpaper.club/wallpapers/0lt9t1k10ae/thumbs/1600/5.jpg"},"title":"Welcome to Caroline's world!","subtitle":{"text":["这里是 卡布叻_米菲 的世界！"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"style":"default","links":{"github":"https://github.com/Carolinebaby","instagram":null,"zhihu":null,"twitter":null,"email":"1474396199@qq.com"},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.6.1","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"About":{"icon":"fa-regular fa-user","submenus":{"Me":"/about","Blog":"https://carolinebaby.github.io/","Github":"https://github.com/Carolinebaby"}}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":"Hi~Welcome~","show_on_mobile":true,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"},"shuoshuo":{"path":"/shuoshuo","icon":"fa-regular fa-comment-dots"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2023/4/8 08:29:29"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
<!--        <span class="swup-progress-icon">-->
<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
<!--        </span>-->
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container px-6 md:px-12">

    <div class="navbar-content ">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/charlie3.jpg">
                </a>
            
            <a class="logo-title" href="/">
                
                卡布叻_米菲的世界
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-user fa-fw"></i>
                                    ABOUT
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a href="/about">
                                                    ME
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a href="https://carolinebaby.github.io/">
                                                    BLOG
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://github.com/Carolinebaby">
                                                    GITHUB
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-About"
                        >
                            <span>
                                ABOUT
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-About">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="/about">ME</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="https://carolinebaby.github.io/">BLOG</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://github.com/Carolinebaby">GITHUB</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/tags"
                        >
                            <span>Tags</span>
                            <i class="fa-regular fa-tags fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/shuoshuo"
                        >
                            <span>Shuoshuo</span>
                            <i class="fa-regular fa-comment-dots fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">4</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">3</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">16</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container flex relative justify-between box-border w-full h-full">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                <div class="w-full flex items-center pt-6 justify-start">
                    <h1 class="article-title-regular text-second-text-color text-4xl md:text-6xl font-bold px-2 sm:px-6 md:px-8 py-3">数据结构</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/images/QQ%E5%A4%B4%E5%83%8F.jpg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">卡布叻_米菲</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-01-13 09:29:29</span>
        <span class="mobile">2024-01-13 09:29:29</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-01-13 00:39:28</span>
            <span class="mobile">2024-01-13 00:39:28</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/">算法学习</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/">算法学习</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <p>这是我关于数据结构课程的笔记。</p>
<span id="more"></span>

<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><h2 id="1-1-基本概念和术语"><a href="#1-1-基本概念和术语" class="headerlink" title="1.1 基本概念和术语"></a>1.1 基本概念和术语</h2><h3 id="1-1-1-数据"><a href="#1-1-1-数据" class="headerlink" title="1.1.1 数据"></a>1.1.1 数据</h3><p><strong>数据</strong>(data)：对客观事物的符号表示，在计算机科学中指<strong>所有能输入到计算机中并被计算机程序处理的符号的总称</strong>。</p>
<p><strong>数据元素</strong>（data element）：数据的基本单位。在计算机中通常作为一个整体进行考虑喝处理。</p>
<p><strong>数据项</strong>（data item）：是组成数据元素、有独立含义的、不可分割的最小单位。</p>
<p><strong>数据对象</strong>（data object）：性质相同的数据元素的集合，是数据的一个子集。</p>
<h3 id="1-1-2-数据结构"><a href="#1-1-2-数据结构" class="headerlink" title="1.1.2 数据结构"></a>1.1.2 数据结构</h3><p><strong>数据结构</strong>（data structure）：相互之间存在一种或多种特定关系的数据元素的集合。</p>
<p><strong>结构</strong>（structure）：数据元素相互之间的关系。</p>
<ul>
<li><p><strong>逻辑结构</strong></p>
<p>数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。</p>
<p>因此，数据的逻辑结构 可以看作是 从具体问题抽象出来的数学模型。</p>
<p>四类基本结构：</p>
<ol>
<li>集合 set：数据元素之间就是“属于同一个集合”</li>
<li>线性结构 list：数据元素之间存在着一对一的线性关系</li>
<li>树形结构 tree：数据元素之间存在者一对多的层次关系</li>
<li>图状结构 或 网状结构 graph：数据元素之间存在着多对多的任意关系</li>
</ol>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20230830211617075.png" alt="image-20230830211617075" style="zoom: 50%;">

<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230830212935201.png" class title="image-20230830212935201">




</li>
<li><p><strong>存储结构</strong></p>
<p><strong>存储结构</strong>：数据结构在计算机中的表示（又称映像），数据的物理结构。包括数据元素的表示和关系的表示。</p>
<p>在计算机中，表示信息的最小单位是二进制数的一位，叫做 <strong>位</strong>（bit）。计算机中，用一个由若干位组合起来形成的一个位串表示一个数据元素。通常称这个位串为<strong>元素</strong>（element）或<strong>结点</strong>（node）。当数据元素由若干个数据项组成时，位串中对应于各个数据项的子位串称为<strong>数据域</strong>（data field）。</p>
<p>元素 或 结点 可以看成是数据元素在计算机中的映像。</p>
<p>数据元素之间的关系在计算机中有两种不同的表示方法：<strong>顺序映像</strong> 和 <strong>非顺序映像</strong>，并由此得到两种不同的存储结构：<strong>顺序存储结构</strong> 和 <strong>链式存储结构</strong>。（其实还有两种存储方式：索引存储（索引项：关键词、地址）、散列存储（结点地址 &#x3D; F(关键字) ））</p>
<ul>
<li><p><strong>顺序映像</strong> 的特点是：借助元素在存储器中的相对关系来表示数据元素之间的逻辑关系</p>
</li>
<li><p><strong>非顺序映像</strong> 的特点是：借助指示元素存储地址的 <strong>指针</strong>（pointer）来表示 数据元素之间的逻辑关系</p>
</li>
</ul>
</li>
</ul>
<p>数据存储原则：</p>
<ul>
<li>不仅要存储数据本身的值，还要保存数据间的关系。</li>
<li>存储数据的目的是为了对它们进行处理。</li>
</ul>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230901144020730.png" class title="image-20230901144020730">



<ul>
<li><p>数据的 逻辑结构 属于用户视图，是面向问题的，反映了数据内部的构成方式，数据的逻辑结构独立于计算机</p>
</li>
<li><p>数据的 物理存储结构 的实现要用计算机语言中的 数据类型 来描述，因而是依赖于具体的计算机语言而言的，是面向计算机的。</p>
</li>
</ul>
<p>一种数据的逻辑结构可以用多种存储结构来存储，而采用不同的存储结构，其数据存储的效率往往是不同的</p>
<h3 id="1-1-3-数据的运算"><a href="#1-1-3-数据的运算" class="headerlink" title="1.1.3 数据的运算"></a>1.1.3 数据的运算</h3><p>数据的运算有两方面的含义：运算的定义与算法的实现</p>
<p>运算的定义：取决于数据的逻辑结构。根据问题中的数据及数据间的关系，设计相应的数据处理方法。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20230901144705812.png" alt="image-20230901144705812" style="zoom:80%;">

<p>常见的运算操作：</p>
<ul>
<li>初始化：对存储结构设置初始值，或者申请存储空间。</li>
<li>判空：判断存储空间是否为未存放有效值的状态</li>
<li>查找：判断是否包含指定元素</li>
<li>遍历：按某种次序访问所有元素，每个元素只被访问一次</li>
<li>插入：增加指定元素</li>
<li>删除：移去指定元素</li>
<li>……</li>
</ul>
<h3 id="1-1-3-数据类型和抽象数据类型"><a href="#1-1-3-数据类型和抽象数据类型" class="headerlink" title="1.1.3 数据类型和抽象数据类型"></a>1.1.3 数据类型和抽象数据类型</h3><ol>
<li>数据类型</li>
</ol>
<p><strong>数据类型</strong>（data type）是 一个值的集合和定义在这个值集上的一组操作的总称。</p>
<ol start="2">
<li>抽象数据类型</li>
</ol>
<p><strong>抽象数据类型</strong>（Abstract Data Type，简称 ADT）是指一个数学模型以及定义在该模型上的一组操作。</p>
<ul>
<li><p>抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p>
</li>
<li><p>抽象数据类型，不仅包括各处理器已经定义及实现的数据类型，还包括用户自己定义的数据类型。</p>
</li>
</ul>
<p>抽象数据类型具体包括三部分：数据对象、数据对象上关系的集合以及对抽象对象的基本操作</p>
<p>抽象数据类型的定义格式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名&#123;</span><br><span class="line">	数据对象:&lt;数据对象的定义&gt;</span><br><span class="line">	数据关系:&lt;数据关系的定义&gt;</span><br><span class="line">	基本操作:&lt;基本操作的定义&gt;</span><br><span class="line">&#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure></div>

<p>基本操作的定义格式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本操作名(参数表)</span><br><span class="line">	初始条件:&lt;初始条件描述&gt;</span><br><span class="line">	操作结果:&lt;操作结果描述&gt;</span><br></pre></td></tr></table></figure></div>









<h2 id="1-2-算法和算法分析"><a href="#1-2-算法和算法分析" class="headerlink" title="1.2 算法和算法分析"></a>1.2 算法和算法分析</h2><h3 id="1-2-1-算法"><a href="#1-2-1-算法" class="headerlink" title="1.2.1 算法"></a>1.2.1 算法</h3><p><strong>算法</strong>（algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作。</p>
<p>算法的 5 个重要特性：</p>
<ol>
<li>有穷性：一个算法总是在执行有穷步之后结束，且每一步都可在 有穷时间  内完成。</li>
<li>确定性：算法中每一条指令必须有确切的含义，读者理解时不会产生二义性。而且，在任何条件下，算法只有唯一的一条执行路径，即对相同的输入只能得到相同的输出。</li>
<li>可行性：算法中所描述的操作都是可以通过已经实现的基本运算执行有限次来实现。</li>
<li>输入：一个算法有零个或多个输入，这些输入来自某个特定的对象的集合</li>
<li>输出：一个算法有一个或多个的输出，这些输出是同输入有着某些特定关系的量</li>
</ol>
<h3 id="1-2-2-算法设计的要求"><a href="#1-2-2-算法设计的要求" class="headerlink" title="1.2.2 算法设计的要求"></a>1.2.2 算法设计的要求</h3><ul>
<li>正确性：指算法至少应该具有输入、输出和加工处理无歧义性，能正确反映问题的需求，能够得到问题的正确答案。</li>
<li>可读性：算法设计的另一个目的是为了方便阅读、理解和交流</li>
<li>健壮性：有成鲁棒性或容错性，是指算法对不合理输入的反应能力和处理能力。一个好的算法，应该能够识别出错误的输入数据并进行适当的处理和反应，而不是产生异常或莫名其妙的结果。</li>
<li>效率：具有 时间效率高 和 存储空间少 的要求。</li>
</ul>
<h3 id="1-2-3-算法的描述"><a href="#1-2-3-算法的描述" class="headerlink" title="1.2.3 算法的描述"></a>1.2.3 算法的描述</h3><ul>
<li><p>自然语言描述 —— Pipeline Chart </p>
<ul>
<li>优点：容易理解</li>
<li>限制：冗余、含糊</li>
<li>用途：粗略地描述算法的目的</li>
</ul>
</li>
<li><p>流程图 —— Pipeline Chart</p>
<ul>
<li>优点：步骤直观</li>
<li>限制：缺乏严谨性和灵活性</li>
<li>用途：描述简单的算法</li>
</ul>
</li>
<li><p>编程语言 —— Programming Language</p>
<ul>
<li>优点：电脑可以运行</li>
<li>显示：抽象性差，编程要求高</li>
<li>用途：需要调试算法</li>
</ul>
</li>
<li><p>伪代码 —— Pseudo Code</p>
<p>介于自然语言和程序设计语言之间的方法，它采用某一程序设计语言的基本语法，操作指令可以结合自然语言来设计。</p>
<p>优点：表达能力强，抽象性强，容易理解</p>
</li>
</ul>
<h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2 线性表"></a>2 线性表</h1><h2 id="2-1-线性表的类型定义"><a href="#2-1-线性表的类型定义" class="headerlink" title="2.1 线性表的类型定义"></a>2.1 线性表的类型定义</h2><p><strong>线性结构的特点</strong>：</p>
<p>在数据元素的非空有限集中，</p>
<ul>
<li>存在唯一的一个被称作“第一个”的数据元素</li>
<li>存在唯一的一个被称作“最后一个”的数据元素</li>
<li>除第一个之外，集合中的每一个数据元素均只有一个前驱</li>
<li>除最后一个之外，集合中的每一个数据元素均只有一个后继</li>
</ul>
<p>线性表是最常用且最简单的一种数据结构。<strong>一个线性表是 $n$ 个数据元素的有限序列</strong>。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line">(A,B,C,...,Z)  <span class="comment">// 26 个英文字母的字母表，表中数据元素是单个字母字符</span></span><br><span class="line">(<span class="number">6</span>,<span class="number">17</span>,<span class="number">28</span>,<span class="number">50</span>,<span class="number">92</span>,<span class="number">188</span>)  <span class="comment">// 某校几年内拥有计算机数量变化，表中的数据元素是整数</span></span><br></pre></td></tr></table></figure></div>

<p>在稍复杂的线性表中，一个数据元素可以由若干个 <strong>数据项</strong> （item）组成。在这种情况下，常常把数据元素称为 <strong>记录</strong>（record），含有大量记录的线性表又称 <strong>文件</strong>（file）。</p>
<p>例如，一个学校的学生健康情况登记表如图所示，表中每个学生的情况为一个记录，它由姓名、学号、性别、年龄、班级和健康状况等 6 个数据项组成。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231022164632839.png" alt="image-20231022164632839" style="zoom:50%;">

<p>【注】线性表的元素可以是各种各样的，但是<strong>在同一线性表中的元素必定具有相同特性</strong>，即属同一数据对象，相邻数据元素之间存在序偶关系。</p>
<hr>
<p>线性表是具有相同特性的数据元素的一个有限序列，例如： $a_1,a_2,…,a_{i-1}, a_i,a_{i+1},…,a_n$ </p>
<p>有限序列的第一个元素叫做线性起点，每个元素的前面一个元素叫做 它的直接前趋，后一个元素叫做它的直接后继，序列的最后一个元素叫做线性终点。</p>
<p><strong>线性表</strong>（Linear List）：由 $n(n\geqslant0)$ 个数据元素（结点）$a_1,a_2,…,a_n$ 组成的有限序列。</p>
<ul>
<li>数据元素个数 $n$ 定义为 线性表的长度</li>
<li>当 $n &#x3D; 0$ 时称为空表</li>
<li>$a_1$ 是第一个数据元素，$a_n$ 是最后一个数据元素，$a_i$ 是第 $i$ 个数据元素，称 $i$ 为数据元素 $a_i$ 在线性表中的位序</li>
<li>将非空的线性表 $(n&gt;0)$ 记作：$(a_1, a_2, …, a_n)$ </li>
<li>这里的数据元素 $a_i(1\leqslant i \leqslant n)$ 只是一个抽象的符号，其具体含义在不同的情况下可以不同。</li>
</ul>
<p><strong>同一线性表中的元素必定具有相同的特性</strong>，数据元素间的关系是线性关系。</p>
<h3 id="线性表的逻辑特征"><a href="#线性表的逻辑特征" class="headerlink" title="线性表的逻辑特征"></a>线性表的逻辑特征</h3><p>非空的线性表中：</p>
<ul>
<li>有且仅有一个开始结点 $a_1$ ，它没有直接前趋，而仅有一个直接后继 $a_2$ </li>
<li>有且仅有一个终端结点 $a_n$ ，它没有直接后继，而仅有一个直接前驱 $a_{n-1}$ </li>
<li>其余内部结点 $a_i(2\leqslant i \leqslant n-1)$ 都有且仅有一个直接前趋 $a_{i-1}$ 和一个直接后继 $a_{i+1}$ 。</li>
</ul>
<p>线性表是一个相当灵活的数据结构，它的长度可以根据需要增加或缩短，即对线性表的数据元素不仅可以进行访问，还可以进行插入和删除。</p>
<p>顺序存储结构存在问题：</p>
<ul>
<li>存储空间分配不灵活</li>
<li>运算的空间复杂度高</li>
</ul>
<p><strong>抽象数据类型线性表的定义</strong>如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">ADT List&#123;</span><br><span class="line">    数据对象:D = &#123;ai | ai ∈ ElemSet, i = 1,2,..., m, n≥0&#125;</span><br><span class="line">    数据关系:R1 = &#123;&lt;a(i-1), ai | a(i-1), ai ∈ D, i = 2,..., n&#125;</span><br><span class="line">    基本操作：</span><br><span class="line">        InitList(&amp;L)</span><br><span class="line">        	操作结果：构造一个空的线性表L</span><br><span class="line">        DestroyList(&amp;L)</span><br><span class="line">        	初始条件：线性表L已存在</span><br><span class="line">        	操作结果：销毁线性表L</span><br><span class="line">        ClearList(&amp;L)</span><br><span class="line">        	初始条件：线性表L已存在</span><br><span class="line">        	操作结果：将L重置为空表</span><br><span class="line">        ListEmpty(L)</span><br><span class="line">        	初始条件：线性表L已存在</span><br><span class="line">        	操作结果：若L为空表，则返回TRUE，否则返回FALSE</span><br><span class="line">        ListLength(L)</span><br><span class="line">        	初始条件：线性表L已存在</span><br><span class="line">        	操作结果：返回L中数据元素个数</span><br><span class="line">        GetElem(L, i, &amp;e)</span><br><span class="line">        	初始条件：线性表L已存在,1≤i≤ListLength(L)</span><br><span class="line">        	操作结果：用e返回L中第i个数据元素的值</span><br><span class="line">        LocateElem(L, e, compare())</span><br><span class="line">        	初始条件：线性表L已存在, compare()是数据元素判定函数</span><br><span class="line">        	操作结果：返回L中第一个与 e 满足 关系compare() 的数据元素的位序。</span><br><span class="line">        			若这样的数据元素不存在，则返回值为 0</span><br><span class="line">        PriorElem(L, cur_e, &amp;pre_e)</span><br><span class="line">        	初始条件：线性表L已存在</span><br><span class="line">        	操作结果：若 cur_e 是L的数据元素，且不是第一个，则用 pre_e 返回它的前驱，</span><br><span class="line">        			否则操作失败，pre_e 无定义</span><br><span class="line">        NextElem(L, cur_e, &amp;next_e)</span><br><span class="line">        	初始条件：线性表L已存在</span><br><span class="line">        	操作结果：若 cur_e 是L的数据元素，且不是最后一个，则用 next_e 返回它的前驱，</span><br><span class="line">        			否则操作失败，next_e 无定义</span><br><span class="line">        ListInsert(&amp;L, i, e)</span><br><span class="line">        	初始条件：线性表L已存在，1≤i≤ListLength(L)+1</span><br><span class="line">        	操作结果：在L中第i个位置之前插入新的的数据元素e，L的长度加1</span><br><span class="line">        ListDelete(&amp;L, i, &amp;e)</span><br><span class="line">        	初始条件：线性表L已存在，1≤i≤ListLength(L)</span><br><span class="line">        	操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1</span><br><span class="line">        ListTraverse(L, visit())</span><br><span class="line">        	初始条件：线性表L已存在</span><br><span class="line">        	操作结果：依次对L的每个数据元素调用函数 visit()。一旦 visit()失败，则操作失败</span><br><span class="line">&#125;ADT List</span><br></pre></td></tr></table></figure></div>



<p>例：<strong>合并两个线性表 LA 和 LB</strong>，从线性表 LB 中依次取每个数据元素，并依值在线性表 LA 中进行查访，若不存在，则插入之。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">union</span><span class="params">(List&amp; La, List Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将所有在线性表 Lb 中但不在 La 中的数据元素插入到 Lb 中</span></span><br><span class="line">    La_len = <span class="built_in">ListLength</span>(La); Lb_len = <span class="built_in">ListLength</span>(Lb);  <span class="comment">// 求线性表的长度</span></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">1</span>; i&lt;=Lb_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GetElem</span>(Lb, i, e);  <span class="comment">// 取 Lb 中第 i 个数据元素赋给 e</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">LocateElem</span>(La, e, equal))  <span class="comment">// La 中不存在和 e 相同的数据元素，则插入之</span></span><br><span class="line">            <span class="built_in">ListInsert</span>(La, ++La_len, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// union</span></span><br></pre></td></tr></table></figure></div>

<p>时间复杂度：O(ListLength(LA)*ListLength(LB))</p>
<p>例：<strong>合并两个递增有序序列 LA 和 LB</strong>：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList</span><span class="params">(List La, List Lb, List&amp; Lc)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 已知线性表 La 和 Lb 中的数据元素按值非递减排列</span></span><br><span class="line">    <span class="comment">// 归并 La 和 Lb 得到新的线性表 Lc, Lc 的数据也按值非递减排列</span></span><br><span class="line">    <span class="built_in">InitList</span>(Lc);</span><br><span class="line">    i = j = <span class="number">1</span>; k = <span class="number">0</span>;</span><br><span class="line">    La_len = <span class="built_in">ListLength</span>(La);</span><br><span class="line">    Lb_len = <span class="built_in">ListLength</span>(Lb);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((i&lt;=La_len) &amp;&amp; (i&lt;=Lb_len))&#123;</span><br><span class="line">        <span class="built_in">GetElem</span>(La, i, ai);</span><br><span class="line">        <span class="built_in">GetElem</span>(Lb, j, bj);</span><br><span class="line">        <span class="keyword">if</span>(ai &lt;= bj)&#123;</span><br><span class="line">            <span class="built_in">ListInsert</span>(Lc, ++k, ai);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">ListInsert</span>(Lc, ++k, bj);</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= La_len)&#123;</span><br><span class="line">        <span class="built_in">GetElem</span>(La, i++, ai);</span><br><span class="line">        <span class="built_in">ListInsert</span>(Lc, ++k, ai);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">while</span>(j &lt;= Lb_len)&#123;</span><br><span class="line">        <span class="built_in">GetElem</span>(Lb, j++, bj);</span><br><span class="line">        <span class="built_in">ListInsert</span>(Lc, ++k, bj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;  <span class="comment">// MergeList</span></span><br></pre></td></tr></table></figure></div>

<p>时间复杂度：O(ListLength(LA)+ListLength(LB))</p>
<h2 id="2-2-线性表的顺序表示和实现"><a href="#2-2-线性表的顺序表示和实现" class="headerlink" title="2.2 线性表的顺序表示和实现"></a>2.2 线性表的顺序表示和实现</h2><p>在计算机中，线性表有两种基本的存储结构：<strong>顺序存储结构</strong> 和 <strong>链式存储结构</strong> </p>
<p><strong>线性表的顺序表示</strong> 指的是用 <strong>一组地址连续单元</strong> <strong>依次存储</strong> 线性表的数据元素。</p>
<h3 id="2-2-1-线性表的线性存储表示"><a href="#2-2-1-线性表的线性存储表示" class="headerlink" title="2.2.1 线性表的线性存储表示"></a>2.2.1 线性表的线性存储表示</h3><p>线性表的顺序表示又称为顺序存储结构或顺序映像。</p>
<p><strong>顺序存储</strong>定义：把<strong>逻辑上相邻的数据元素</strong>存储在<strong>物理相邻的存储单元</strong>中的存储结构。</p>
<ul>
<li><p>依次存储，地址连续，中间没有空出存储单元。</p>
</li>
<li><p>线性表顺序存储结构占用一片连续的存储空间，知道某个元素的存储位置就可以计算其他元素的存储位置。</p>
<p>假设线性表的每个元素需占 $l$ 个存储单元，则第 $i+1$ 个数据元素的存储位置和第 $i$ 个数据元素的存储位置之间满足关系：$\mathrm{LOC}(a_{i+1}) &#x3D; \mathrm{LOC}(a_{i}) + l$ 。</p>
<p>由此所有数据元素的存储位置均可由第一个数据元素的存储位置得到：$\mathrm{LOC}(a_{i+1}) &#x3D; \mathrm{LOC}(a_{1}) + (i-1)\times l$ ，第一个元素的地址是基地址。</p>
<p>每一个数据元素的存储位置都和线性表的起始位置相差一个和数据元素在线性表中的位序成正比的常数。</p>
</li>
<li><p>线性表的<strong>顺序存储结构</strong> 是一种 <strong>随机存取</strong>的存储结构</p>
</li>
</ul>
<h3 id="2-2-2-线性表的实现"><a href="#2-2-2-线性表的实现" class="headerlink" title="2.2.2 线性表的实现"></a>2.2.2 线性表的实现</h3><p>高级程序设计语言中的数组类型也有随机存取的特性，因此通常用数组来描述数据结构中的顺序存储结构。</p>
<p>顺序表的特点：以物理位置相邻表示逻辑关系。任一元素均可随机存取。（优点）</p>
<p>顺序表（元素）：地址连续、依次存放、随意存取、类型相同。</p>
<p>&#x3D;&gt; 可以用高级语言的 一维数组表示顺序表示。</p>
<p>线性表的表长可变（删除），数组长度不可动态定义。&#x3D;&gt; 用一个变量表示顺序表的长度属性</p>
<p>通用代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 100  <span class="comment">// 线性表存储空间的初始分配量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 10    <span class="comment">// 线性表存储空间的分配增量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType elem[LIST_INIT_SIZE];  <span class="comment">// 存储空间的基地址</span></span><br><span class="line">    <span class="type">int</span> length;    <span class="comment">// 当前长度 </span></span><br><span class="line">    <span class="type">int</span> listsize;  <span class="comment">// 当前分配的存储容量(以sizeof(ElemType)为单位)</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure></div>

<p>注意：上面代码的数组是静态分配的</p>
<p>数组动态分配：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType* data; <span class="comment">// 可以用内存动态分配来动态分配内存</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> listsize;  </span><br><span class="line">&#125;SqList;   <span class="comment">// 顺序表类型</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SqList L;</span><br><span class="line">L.data = (ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*MaxSize);</span><br><span class="line"><span class="comment">// 释放指针 free(p)</span></span><br><span class="line"><span class="comment">//或者借助 C++ 语法： L.data = new ElemType[MaxSize]，释放地址：delete p 或 delete[] p</span></span><br></pre></td></tr></table></figure></div>





<ul>
<li><p>多项式的顺序存储结构类型定义</p>
<p>$P_n(x) &#x3D; p_1x^{e_1} + p_2x^{e_2} + \cdots + p_mx^{e_m}$ ：</p>
<p>&#x3D;&gt; 线性表：<code>P = ((p1,e1), (p2, e2), ..., (pm, em))</code> </p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000 <span class="comment">// 多项式可能达到的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;  <span class="comment">// 多项式非零项的定义</span></span><br><span class="line">    <span class="type">float</span> p;  <span class="comment">// 系数</span></span><br><span class="line">    <span class="type">int</span> e;    <span class="comment">// 指数</span></span><br><span class="line">&#125;Polynomial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    Polynomial* elem; <span class="comment">// 存储空间的基地址 </span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-2-3-顺序表基本操作的实现"><a href="#2-2-3-顺序表基本操作的实现" class="headerlink" title="2.2.3 顺序表基本操作的实现"></a>2.2.3 顺序表基本操作的实现</h3><p>预定义常量和类型</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数结果状态代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="comment">// Statue 是函数的类型，其值是函数结果状态代码</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>线性表的初始化</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构造一个空的线性表 L</span></span><br><span class="line">    L.elem = (ElemType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span>(!L.elem) <span class="built_in">exit</span>(OVERFLOW);  <span class="comment">// 存储分配失败</span></span><br><span class="line">    L.length = <span class="number">0</span>;                <span class="comment">// 空表长度为 0</span></span><br><span class="line">    L.listsize = LIST_INIT_SIZE; <span class="comment">// 初始存储容量</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;  <span class="comment">// InitList_Sq</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>元素的插入</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在顺序线性表 L 中 第 i 个位置之前插入新的元素 e</span></span><br><span class="line">    <span class="comment">// i 的合法值为 1&lt;= i &lt;= ListLength_Sq(L)+1</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(L.length &gt;= L.listsize)&#123;</span><br><span class="line">		newbase = (ElemType*) <span class="built_in">malloc</span>(L.elem, </span><br><span class="line">                 (L.listsize+LISTINCREMENT)*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span>(!newbase) <span class="built_in">exit</span>(OVERFLOW);  <span class="comment">// 分配地址失败</span></span><br><span class="line">        L.elem = newbase;             <span class="comment">// 新基址</span></span><br><span class="line">        L.listsize = LISTINCREMENT;   <span class="comment">// 增加存储容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    q = &amp;(L.elem[i<span class="number">-1</span>]);  <span class="comment">// q 为插入位置</span></span><br><span class="line">    <span class="keyword">for</span>(p = &amp;(L.elem[L.length<span class="number">-1</span>]); p&gt;=q; --p)   *(p+<span class="number">1</span>) = *p;   <span class="comment">// 插入位置及之后的元素右移</span></span><br><span class="line">    *q = e;  <span class="comment">// 插入 e</span></span><br><span class="line">    ++L.length;  <span class="comment">// 表长加1</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">// ListInsert_Sq</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>元素的删除</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在顺序线性表L中删除第 i 个元素，并用 e 返回其值</span></span><br><span class="line">    <span class="comment">//  i 的合法值为 1&lt;= i &lt;= ListLength_Sq(L)</span></span><br><span class="line">    <span class="keyword">if</span>((i&lt;<span class="number">1</span>) || (i&gt;L.length)) <span class="keyword">return</span> ERROR;  <span class="comment">// i 值不合法</span></span><br><span class="line">    p = &amp;(L.elem[i<span class="number">-1</span>]);         <span class="comment">// p 为被删除元素的位置</span></span><br><span class="line">    e = *p;                     <span class="comment">// 被删除元素的值赋给 e</span></span><br><span class="line">    q = L.elem + L.length - <span class="number">1</span>;  <span class="comment">// 表尾元素的位置</span></span><br><span class="line">    <span class="keyword">for</span>(++p; p&lt;=q; ++p)         <span class="comment">// 被删除元素之后元素左移</span></span><br><span class="line">        *(p<span class="number">-1</span>) = *p;</span><br><span class="line">    --L.length;                 <span class="comment">// 表长减 1</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;  <span class="comment">// ListDelete_Sq</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>若表长为 $n$ ，则算法 ListInsert_Sq 和 ListDelete_Sq 的时间复杂度为 $O(n)$ </p>
<ul>
<li><p>找到满足 <code>compare</code> 关系的第一个元素</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem_Sq</span><span class="params">(SqList L, ElemType e, </span></span></span><br><span class="line"><span class="params"><span class="function">                  Status(* compare)(ElemType, ElemType))</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在顺序线性表 L 中查找第 1 个值与 e 满足 compare() 关系的位序</span></span><br><span class="line">    <span class="comment">// 若找到，则返回其在 L 的位序，否则返回 0</span></span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    p = L.elem;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=L.length &amp;&amp; !(*compare)(*p++, e)) ++i;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;= L.length)  <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">// LocateElem_Sq</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>合并递增有序顺序线性表</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList_Sq</span><span class="params">(SqList La, SqList Lb, SqList &amp;Lc)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 已知顺序线性表 La 和 Lb 的元素按值非递减排序</span></span><br><span class="line">    <span class="comment">// 归并 La 和 Lb 得到新的顺序线性表 Lc，Lc 的元素也按值非递减排列</span></span><br><span class="line">    pa = La.elem; pb = Lb.elem;</span><br><span class="line">    Lc.listsize = Lc.length = La.length + Lb.length;</span><br><span class="line">    pc = Lc.elem = (ElemType*)<span class="built_in">malloc</span>(Lc.listsize*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span>(!Lc.elem) <span class="built_in">exit</span>(OVERFLOW);    <span class="comment">// 存储分配失败</span></span><br><span class="line">    pa_last = La.elem + La.length - <span class="number">1</span>;</span><br><span class="line">    pb_last = Lb.elem + Lb.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*pa &lt;= *pb) *pc++ = *pa++;</span><br><span class="line">        <span class="keyword">else</span> *pc++ = *pb++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pa &lt;= pa.last) *pc++ = *pa++;  <span class="comment">// 插入 La 的剩余元素</span></span><br><span class="line">    <span class="keyword">while</span>(pb &lt;= pb.last) *pc++ = *pb++;  <span class="comment">// 插入 Lb 的剩余元素</span></span><br><span class="line">&#125;  <span class="comment">// MergeList_Sq</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="2-3-顺序表的链式表示和实现"><a href="#2-3-顺序表的链式表示和实现" class="headerlink" title="2.3 顺序表的链式表示和实现"></a>2.3 顺序表的链式表示和实现</h2><p>链式存储结构，不要求逻辑上相邻的元素在物理位置也相邻，因此它没有顺序存储结构所具有的弱点（在插入或删除操作时，需移动大量元素），同时也失去了顺序表 随机存取 的优点。</p>
<h3 id="2-3-1-线性链表"><a href="#2-3-1-线性链表" class="headerlink" title="2.3.1 线性链表"></a>2.3.1 线性链表</h3><p>线性表的链式存储结构</p>
<ul>
<li><p>特点：用一组 <strong>任意的存储单元</strong> 存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）</p>
</li>
<li><p>对于数据元素 $a_i$ 来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。这两部分信息组成数据元素 $a_i$ 的 <strong>存储映像</strong>，称为 <strong>结点</strong> (node)。它包括两个域：</p>
<ul>
<li><strong>数据域</strong>：存储数据元素信息</li>
<li><strong>指针域</strong>：存储直接后继存储位置，指针域存储的信息称做 指针 或 链。</li>
</ul>
</li>
<li><p>$n$ 个结点( $a_i(1\leqslant i \leqslant n)$ 的存储映像)链结成一个链表，即线性表 $(a_1,a_2,\cdots,a_n)$ 的链式存储结构。</p>
</li>
<li><p>此链表的每个结点只包含一个指针域，故又称 <strong>线性链表</strong> 或 <strong>单链表</strong></p>
</li>
</ul>
<p>整个链表必须从 <strong>头指针</strong> 开始进行，头指针指示链表中第一个结点（即第一个数据元素的存储映像）的存储位置。同时，由于最后一个数据元素没有直接后继，则线性链表中最后一个结点的指针为 “空” ($\bold{NULL}$)</p>
<ul>
<li>用线性链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的。换句话说，指针为数据元素之间的逻辑关系的映像。</li>
<li>这种存储结构称为 <strong>非顺序映像</strong> 或 <strong>链式映像</strong></li>
</ul>
<h3 id="2-3-2-线性链表的实现"><a href="#2-3-2-线性链表的实现" class="headerlink" title="2.3.2 线性链表的实现"></a>2.3.2 线性链表的实现</h3><p>单链表的描述：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> * next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>设 L 是 LinkList 型变量，则 L 为单链表的头指针，它指向表中第一个结点。若 L 为 “空” (L &#x3D; NULL) ，则所表示的线性表为 “空” 表，其长度 $n$ 为 “零” 。</p>
</li>
<li><p>有时，在单链表的第一个结点之前附设一个结点，称之为头结点，头结点的数据域可以不存储任何信息，也可以存储诸如 线性表的长度等类的附加信息。头结点的指针域指向第一个结点的指针（即第一个元素结点的存储位置）。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231023214957349.png" alt="image-20231023214957349" style="zoom:50%;">

<p>若线性表为空表，则头结点的指针域为 “空”</p>
</li>
</ul>
<p>单链表是非随机存取的存储结构。</p>
<h3 id="2-3-3-线性链表基本操作的实现"><a href="#2-3-3-线性链表基本操作的实现" class="headerlink" title="2.3.3 线性链表基本操作的实现"></a>2.3.3 线性链表基本操作的实现</h3><ul>
<li><p><strong>获取链表中的元素</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L, <span class="type">int</span> i, ElemType &amp; e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// L 为带头结点的单链表的头指针</span></span><br><span class="line">    <span class="comment">// 当第 i 个元素存在时,其值赋给 e 并返回 OK,否则返回 ERROR</span></span><br><span class="line">    p = L-&gt;next;  j = <span class="number">1</span>;   <span class="comment">// 初始化, p 指向第一个结点, j 为计数器</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i)&#123;   <span class="comment">// 顺指针向后查找, 知道 p 指向第 i 个元素或 p 为空</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!p || j&gt;i) <span class="keyword">return</span> ERROR;  <span class="comment">// 第 i 个元素不存在</span></span><br><span class="line">    e = p-&gt;data;  <span class="comment">// 取 第 i 个元素</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// GetElem_L</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>插入元素</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp; L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在带头结点的单链表线性表 L 中第 i 个位置之前插入元素 e</span></span><br><span class="line">    p = L; j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;   <span class="comment">// 寻找第 i-1 个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;  <span class="comment">// i 小于 1 或者大于表长加 1</span></span><br><span class="line">    s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">// 生成新结点</span></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;  <span class="comment">// ListInsert_L</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>删除结点</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp; e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在带头结点的单链线性表L中,删除第 i 个元素,并用 e 返回其值</span></span><br><span class="line">    p = L; j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;  <span class="comment">// 寻找第 i-1 个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j&gt;i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;  <span class="comment">// i 小于 1 或者大于表长加1</span></span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">    </span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// ListDelete_L</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>插入和删除操作，复杂度均为 $O(n)$ ，因为查找第 i-1 个结点的复杂度为 $O(n)$ </p>
</li>
<li><p><strong>逆向建立链表</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 逆位序输入 n 个元素的值，建立带表头结点的单链线性表 L</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = n; i&gt;<span class="number">0</span>; --i)&#123;</span><br><span class="line">        p = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));   <span class="comment">// 生成新的结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(&amp; p-&gt;data);</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// CreateList_L</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>合并两个有序链表</strong>（非递减序列）</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList_L</span><span class="params">(LinkList &amp; La, LinkList &amp; Lb, LinkList &amp; Lc)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 已知单恋线性表 La 和 Lb 的元素按值非递减排列</span></span><br><span class="line">    <span class="comment">// 归并 La 和 Lb 得到新单链线性表 Lc, Lc 的元素也按值非递减排列</span></span><br><span class="line">    pa = La-&gt;next;  pb = Lb-&gt;next;</span><br><span class="line">    Lc = pc = La;   <span class="comment">// 用 La 的头结点组为 Lc 的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pc-&gt;next = pb;</span><br><span class="line">            pc = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    pc-&gt;next = pa?pa:pb;   <span class="comment">// 插入剩余段</span></span><br><span class="line">    <span class="built_in">free</span>(Lb);   <span class="comment">// 释放 Lb 的头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-3-4-静态链表"><a href="#2-3-4-静态链表" class="headerlink" title="2.3.4 静态链表"></a>2.3.4 静态链表</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性表的静态单链表存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> cur;  <span class="comment">// 游标,代替指针指示结点在数组中的相对位置</span></span><br><span class="line">&#125;component, SLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure></div>

<p>这种存储结构需要预先分配一个较大的空间，但在线性表的插入和删除操作时不需要移动元素，仅需修改指针，故仍具有链式存储结构的主要优点。下面展示 插入元素 “SHI” 和 删除元素 “ZHENG” 之后的状况。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231024000908133.png" alt="image-20231024000908133" style="zoom:50%;">

<p>假设 S 为 SLinkList 变量，则 <code>S[0].cur</code> 指示第一个结点在数组中的位置，若设 <code>i = S[0].cur</code> ，则 <code>S[i].data</code> 存储线性表的第一个数据元素。若第 i 个分量表示链表的第 k 个结点，则 <code>S[i].cur</code> 指示第 k+1 个结点的位置。因此在静态链表中，以整型游标 <code>i</code> 代替动态指针 <code>p</code>。<code>i = S[i].cur</code> 实为指针后移（类似 <code>p=p-&gt;next</code>）</p>
<p>需要自己实现 <code>malloc</code> 和 <code>free</code> 这两个函数。为了辨明数组中哪些分量未被使用，解决办法是将所有未被使用过以及被删除的分量用游标链成一个备用链表，每当插入时，便可从备用链表取第一个结点作为待插入的新结点。反之，在删除时将从链表中删除下来的结点链接到备用链表上。</p>
<ul>
<li><p><strong>初始化静态链表</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitSpace_SL</span><span class="params">(SLinkList &amp;space)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将一维数组 space 中各分量链成一个备用链表，space[0].cur 为头指针</span></span><br><span class="line">    <span class="comment">// “0” 表示空指针</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;MAXSIZE<span class="number">-1</span>; ++i) space[i].cur = i+<span class="number">1</span>;</span><br><span class="line">    space[MAXSIZE<span class="number">-1</span>].cur = <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">// InitSpace_SL</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>自定义 <code>malloc</code> 函数</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Malloc_SL</span><span class="params">(SLinkList &amp; space)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将一维数组 space 中各分量链成一个备用链表, space[0].cur 为头指针</span></span><br><span class="line">    <span class="comment">// &#x27;0&#x27; 表示空指针</span></span><br><span class="line">    i = space[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="keyword">if</span>(space[<span class="number">0</span>].cur) space[<span class="number">0</span>].cur = space[i].cur;</span><br><span class="line">    <span class="comment">// 将备用链表的头指针指向备用链表中第一个节点的下一个节点。这样，备用链表中的第一个节点被分配出去，不再是备用节点。</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;  <span class="comment">// Malloc_SL</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>自定义 <code>free</code> 函数</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Free_SL</span><span class="params">(SLinkList &amp;space, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将下标为 k 的空闲结点回收到备用链表</span></span><br><span class="line">    space[k].cur = space[<span class="number">0</span>].cur; <span class="comment">// 回收结点的指针域指向现在链表第一个结点</span></span><br><span class="line">    space[<span class="number">0</span>].cur = k;  <span class="comment">// 头结点指针域指向回收结点</span></span><br><span class="line">&#125;  <span class="comment">// Free_SL</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>建立结合 <code>(A_B)⋃(B-A)</code> ：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">difference_SL</span><span class="params">(SLinkList  &amp;space, <span class="type">int</span>&amp; S)</span></span>&#123;</span><br><span class="line">   <span class="comment">//依次输入集合 A 和 B 的元素,在一维数组 space 中建立表示集合(A_B)⋃(B-A)</span></span><br><span class="line">   <span class="comment">// 的静态链表,S 为其头指针。假设备用空间足够大,space[0].cur 为其头指针</span></span><br><span class="line">    <span class="built_in">InitSpace_SL</span>(space);    <span class="comment">// 初始化备用空间</span></span><br><span class="line">    S = <span class="built_in">Malloc_SL</span>(space);   <span class="comment">// 生成 S 的头结点</span></span><br><span class="line">    r = S;                  <span class="comment">// r 指向 S 的当前最后结点</span></span><br><span class="line">    <span class="built_in">scanf</span>(m, n);            <span class="comment">// 输入 A 和 B 的元素个数</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j&lt;=m ;++j)&#123;  <span class="comment">// 建立集合 A 的链表</span></span><br><span class="line">        i = <span class="built_in">Malloc_SL</span>(space);  <span class="comment">// 分配结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(space[i].data);  <span class="comment">// 输入 A 的元素值</span></span><br><span class="line">        space[r].cur = i;      <span class="comment">// 插入到表尾</span></span><br><span class="line">        r = i;</span><br><span class="line">    &#125;  <span class="comment">// 尾结点的指针为空</span></span><br><span class="line">    space[r].cur = <span class="number">0</span>;   <span class="comment">// 尾结点的指针为空</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j&lt;=n; ++j)&#123;  <span class="comment">// 依次输入 B 的元素，若不在当前表中，则插入，否则删除</span></span><br><span class="line">        <span class="built_in">scanf</span>(b);</span><br><span class="line">        p = S;</span><br><span class="line">        k = space[S].cur;  <span class="comment">// k指向集合 A 中的第一个结点</span></span><br><span class="line">        <span class="keyword">while</span>(k != space[r].cur &amp;&amp; space[k].data != b)&#123;  <span class="comment">// 在当前表中查找</span></span><br><span class="line">            p = k;</span><br><span class="line">            k = space[k].cur;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k == space[r].cur)&#123;</span><br><span class="line">           	<span class="comment">// 当前表中不存在该元素，插入在 r 所指结点之后</span></span><br><span class="line">            <span class="comment">//且 r 的位置不变</span></span><br><span class="line">            i = <span class="built_in">Malloc_SL</span>(space);</span><br><span class="line">            space[i].data = b;</span><br><span class="line">            space[i].cur = space[r].cur;</span><br><span class="line">            space[r].cur = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;   <span class="comment">// 该元素在表中，删除之</span></span><br><span class="line">            space[p].cur = space[k].cur;</span><br><span class="line">            <span class="built_in">Free_SL</span>(space, k);</span><br><span class="line">            <span class="keyword">if</span>(r == k) r = p;    <span class="comment">// 若删除的是 r 所指结点，则需修改尾指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>时间复杂度：$O(m\times n)$</p>
</li>
</ul>
<h3 id="2-3-5-循环链表"><a href="#2-3-5-循环链表" class="headerlink" title="2.3.5 循环链表"></a>2.3.5 循环链表</h3><p>循环链表（circular linked list） 是另一种形式的链式存储结构。它的特点是表中最后一个结点的指针指向头结点，整个链表形成一个环。</p>
<p>因此，从表中任一结点出发均可找到表中其他结点。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231024100455394.png" alt="image-20231024100455394" style="zoom: 50%;">

<p>在这种结构中，链表操作中的循环条件是 <code>p-&gt;next</code> 是否等于头指针。</p>
<p>有时候，在循环链表中设立尾指针而不设头指针，可以使得某些操作化简。例如两个线性表合并成一个表时，仅需将一个表的表尾和另一个表的表头相接。运算时间 $O(1)$ </p>
<h3 id="2-3-6-双向链表"><a href="#2-3-6-双向链表" class="headerlink" title="2.3.6 双向链表"></a>2.3.6 双向链表</h3><p>双向链表的结点有两个指针域，其一指向直接后继，另一指向直接前驱。C 语言中可描述如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DuLNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DuLNode</span> * prior;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DuLNode</span> * next;</span><br><span class="line">&#125;DuLNode, *DuLinkList;</span><br></pre></td></tr></table></figure></div>

<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231024101501211.png" alt="image-20231024101501211" style="zoom: 50%;">

<p>双向链表中存在两个环，有 <code>d-&gt;next-&gt;prior = d-&gt;prior-&gt;next = d</code> </p>
<p>在双向链表中，有些操作：ListLength, GetElem 和 LocateElem 等仅需涉及一个方向的指针，则它们的算法描述和线性链表的操作相同。但在 <strong>插入</strong>、<strong>删除</strong> 时有很大的不同，在双向链表中需 <strong>同时修改两个方向上的指针</strong>。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231024102257893.png" alt="image-20231024102257893" style="zoom:50%;">

<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_DuL</span><span class="params">(DuLinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在带头结点的双链循环线性表L中第i个位置之前插入元素 e</span></span><br><span class="line">    <span class="comment">// i 的合法值为 1≤i≤表长+1</span></span><br><span class="line">    <span class="keyword">if</span>(!(p = <span class="built_in">GetElemP_DuL</span>(L,i)))  <span class="comment">// 在 L 中确定插入位置</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;              <span class="comment">// p == NULL, 即插入位置不合法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!(s = (DuLinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DuLNode)))) <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;prior = p-&gt;prior; p-&gt;prior-&gt;next = s;</span><br><span class="line">    s-&gt;next = p; p-&gt;prior = s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK</span><br><span class="line">&#125;  <span class="comment">// ListInsert_DuL</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_DuL</span><span class="params">(DuLinkList &amp;L, <span class="type">int</span> i, ELemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 删除带头结点的双链循环线性表 L 的第 i 个元素，i的合法值 1≤i≤表长</span></span><br><span class="line">    <span class="keyword">if</span>(!(p = <span class="built_in">GetElemP_DuL</span>(L, i)))  <span class="comment">// 在 L 中确定第 i 个元素的位置指针 p</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;   <span class="comment">// p = NULL, 即第 i 个元素</span></span><br><span class="line">    </span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;  <span class="comment">// ListDelete_Dul</span></span><br></pre></td></tr></table></figure></div>



<p>链表有空间的合理利用上和插入、删除时不需要移动等优点。但，它也存在着实现某些基本操作，如求线性表的长度时不如顺序存储结构的缺点。另一个方面，由于在链表中，结点之间的关系用指针表示，则数据元素在线性表中的 “位序”  的概念已淡化，而被数据元素在线性链表中的 “位置” 所代替。</p>
<h2 id="2-4-一元多项式的表示和相加"><a href="#2-4-一元多项式的表示和相加" class="headerlink" title="2.4 一元多项式的表示和相加"></a>2.4 一元多项式的表示和相加</h2><p>一元多项式 $P_n(x)$ 可按升幂写成：$P_n(x) &#x3D; p_0+p_1x+p_2x^2+\cdots+p_nx^n$ ，它由 $n+1$ 个系数唯一确定。因此，在计算机里，它可用一个线性表 $P$ 来表示：$P &#x3D; (p_0, p_1, p_2, \cdots, p_n)$<br>每一项的指数 $i$ 隐含在其系数 $p_i$ 的序号里。</p>
<p>在处理多项式的次数可能很高且变化很大，例如 $S(x) &#x3D; 1+3x^{10000}+2x^{20000}$ 的多项式时，就要用长度为 20001 的线性表表示，浪费大量空间。</p>
<p>可以用一个长度为 每个元素有两个数据项（系数项和指数项）的线性表：<br>$$<br>((p_1, e_1),(p_2, e_2),\cdots,(p_m, e_m))<br>$$<br>这样将到达节省空间。</p>
<p>利用 <strong>线性链表</strong> 可以更好地实现 改变多项式的系数和指数的运算。</p>
<p>抽象数据类型一元多项式的定义：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ADT Polynomial&#123;</span><br><span class="line">    数据对象: D = &#123;ai|ai∈TermSet, i = <span class="number">1</span>,<span class="number">2</span>,...,m,  m≥<span class="number">0</span></span><br><span class="line">              TermSet 中每个元素都包含一个表示系数的实数和表示指数的整数&#125;</span><br><span class="line">    </span><br><span class="line">    数据关系：R1 = &#123;&lt;<span class="built_in">a</span>(i<span class="number">-1</span>), ai&gt;|<span class="built_in">a</span>(i<span class="number">-1</span>), ai ∈ D,且 <span class="built_in">a</span>(i<span class="number">-1</span>) 中的指数值 &lt;ai </span><br><span class="line">        						  中指数值,i = <span class="number">2</span>,...,n&#125;</span><br><span class="line">    基本操作：</span><br><span class="line">        <span class="built_in">CreatePolyn</span>(&amp;P, m)</span><br><span class="line">        操作结果: 输入 m 项的系数和指数,建立一元多项式 P</span><br><span class="line">        <span class="built_in">DestroyPolyn</span>(&amp;P)</span><br><span class="line">        初始条件: 一元多项式 P 已存在</span><br><span class="line">        操作结果: 销毁一元多项式 P</span><br><span class="line">        <span class="built_in">PrintPolyn</span>(P)</span><br><span class="line">        初始条件: 一元多项式 P 已存在</span><br><span class="line">        操作结果: 打印输出一元多项式 P</span><br><span class="line">        <span class="built_in">PolynLength</span>(P)</span><br><span class="line">        初始条件: 一元多项式 P 已存在</span><br><span class="line">        操作结果: 返回一元多项式 P中的项数</span><br><span class="line">        <span class="built_in">AddPolyn</span>(&amp;Pa, &amp;Pb)</span><br><span class="line">        初始条件: 一元多项式 Pa 和 Pb 已存在</span><br><span class="line">        操作结果: 完成多项式相加运算, 即 Pa = Pa+Pb,并销毁一元多项式 Pb</span><br><span class="line">        <span class="built_in">SubtractPolyn</span>(&amp; Pa, &amp; Pb)</span><br><span class="line">        初始条件: 一元多项式 Pa 和 Pb 已存在</span><br><span class="line">        操作结果: 完成多项式相减运算, 即 Pa = Pa-Pb,并销毁一元多项式 Pb</span><br><span class="line">        <span class="built_in">MultiplyPolyn</span>(&amp;Pa, &amp;Pb)</span><br><span class="line">        初始条件: 一元多项式 Pa 和 Pb 已存在</span><br><span class="line">        操作结果: 完成多项式相乘运算, 即 Pa = Pa×Pb,并销毁一元多项式 Pb</span><br><span class="line">&#125; ADT Polynomial</span><br></pre></td></tr></table></figure></div>

<p>实现上述定义的一元多项式，显然应该采用链式存储结构。例如：表示多项式<br>$$<br>A_{17}(x) &#x3D; 7+3x+9x^{8}+5x^{17}<br>$$</p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024111147459.png" class title="image-20231024111147459">

<p>利用有序链表实现 一元多项式。有序链表的基本操作定义 与 线性链表 有两处不同，一是 LocateElem 的职能不同，二是需要增加有序关系进行插入操作 OrderInsert：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e, Position &amp;q,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">int</span>(*compare) (ElemType, ElemType))</span></span>;</span><br><span class="line"><span class="comment">// 若有序链表 L 中存在与 e 满足判定函数 compare() 取值为 0 的元素，则 q 指示 L中第一个值为 e 的结点的位置，并返回 TRUE，否则 q 指示第一个与 e 满足判定函数 compare() 取值 &gt;0 的元素的前驱的位置，并返回 FALSE</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">OrderInsert</span><span class="params">(LinkList &amp; L, ElemType e, <span class="type">int</span>(* compare)(ElemType, ElemType))</span></span>;</span><br><span class="line"><span class="comment">// 按有序判定函数 compare() 的约定，将值为 e 的结点插入到有序链表 L 的适当位置</span></span><br></pre></td></tr></table></figure></div>

<p>抽象数据类型 Polynomial 的实现：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">float</span> coef;  <span class="comment">// 系数</span></span><br><span class="line">    <span class="type">int</span> expn;    <span class="comment">// 指数</span></span><br><span class="line">&#125;term, ElemType;  <span class="comment">//两个类型名: term 用于本 ADT, ElemType 为 LinkList 的数据对象名</span></span><br></pre></td></tr></table></figure></div>

<p>基本操作算法描述：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(term a, term b)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 依 a 的指数值 &lt; (或 = )(或 &gt; ) b 的指数值，返回 -1,0,+1</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatePolyn</span><span class="params">(polynomial &amp; P, <span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 输入 m 项的系数和指数，建立一元多项式的有序链表 P</span></span><br><span class="line">    <span class="built_in">InitList</span>(P);</span><br><span class="line">    h = <span class="built_in">GetHead</span>(P);</span><br><span class="line">    e.coef = <span class="number">0.0</span>; ex.expn = <span class="number">-1</span>; <span class="built_in">SetCurElem</span>(h, e);  <span class="comment">// 设置头结点的数据元素</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;=m; ++i)&#123;  <span class="comment">//依次输入 m 个非零项</span></span><br><span class="line">        <span class="built_in">scanf</span>(e.coef, e.expn);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">LocateElem</span>(P,e,q,(*cmp)()))&#123;       <span class="comment">//当前链表中不存在该指数项</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">MakeNode</span>(s,e)) <span class="built_in">InsFirst</span>(q, s);  <span class="comment">// 生成结点并插入链表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// CreatePolyn</span></span><br></pre></td></tr></table></figure></div>

<p><strong>多项式相加</strong>：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddPolyn</span><span class="params">(polynomial &amp; Pa, polynomial &amp; Pb)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 多项式加法: Pa = Pa + Pb, 利用两个多项式的结点构成 &quot;和多项式&quot;</span></span><br><span class="line">    ha = <span class="built_in">GetHead</span>(Pa); hb = <span class="built_in">GetHead</span>(Pb); <span class="comment">// ha 和 hb 指向Pa 和 Pb 的头结点</span></span><br><span class="line">    qa = <span class="built_in">NextPos</span>(Pa, ha); qb = <span class="built_in">NextPos</span>(Pb, hb);  <span class="comment">// qa 和 qb 分别指向 Pa 和 Pb 中的当前结点</span></span><br><span class="line">    <span class="keyword">while</span>(qa &amp;&amp; qb)&#123;</span><br><span class="line">        a = <span class="built_in">GetCurElem</span>(qa); b = <span class="built_in">GetCurElem</span>(qb);  <span class="comment">// a 和 b 为两表中当前比较元素</span></span><br><span class="line">        <span class="keyword">switch</span>( *<span class="built_in">cmp</span>(a, b) )&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>:   <span class="comment">// 多项式 PA 中当前结点的指数值小</span></span><br><span class="line">                ha = qa; qa = <span class="built_in">NExtPos</span>(Pa, qa); </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:    <span class="comment">// 两者的指数相等</span></span><br><span class="line">                sum = a.coef + b.coef;</span><br><span class="line">                <span class="keyword">if</span>(sum != <span class="number">0.0</span>)&#123;  <span class="comment">// 修改多项式 PA 当前的系数值</span></span><br><span class="line">                    <span class="built_in">SetCurElem</span>(qa, sum);  ha = qa;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 删除多项式 PA 中的当前结点</span></span><br><span class="line">                    <span class="built_in">DelFirst</span>(ha, qa);  <span class="built_in">FreeNode</span>(qa);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">DelFirst</span>(hb, qa);  <span class="built_in">FreeNode</span>(qb); </span><br><span class="line">                qb = <span class="built_in">NextPos</span>(Pb, hb); qa = <span class="built_in">NextPos</span>(Pa, ha); </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:   <span class="comment">// 多项式 PB 中当前结点的指数值小</span></span><br><span class="line">                <span class="built_in">DelFirst</span>(hb, qb);  <span class="built_in">InsFirst</span>(ha, qb);</span><br><span class="line">                qb = <span class="built_in">NextPos</span>(Pb, hb); ha = <span class="built_in">NextPos</span>(Pa, ha);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">ListEmpty</span>(Pb)) <span class="built_in">Append</span>(Pa, qb);  <span class="comment">// 链表 Pb 中剩余结点</span></span><br><span class="line">    <span class="built_in">FreeNode</span>(hb); <span class="comment">// 释放 Pb 的头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h1 id="3-栈和队列"><a href="#3-栈和队列" class="headerlink" title="3 栈和队列"></a>3 栈和队列</h1><ul>
<li>从 数据结构 角度看，栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表操作的子集，它们是 <strong>操作受限的线性表</strong> 。因此，可称为限定性的数据结构。</li>
<li>从 数据类型 角度看，它们是和线性表大不相同的抽象数据类型。</li>
</ul>
<h2 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h2><h3 id="3-1-1-抽象数据类型栈的定义"><a href="#3-1-1-抽象数据类型栈的定义" class="headerlink" title="3.1.1 抽象数据类型栈的定义"></a>3.1.1 抽象数据类型栈的定义</h3><p>栈 (stack) 是限定 仅在表尾进行插入或删除 的线性表。</p>
<ul>
<li>表尾段称为 栈顶(top)，表头段称为栈底(bottom)。不含元素的空表称为空栈。</li>
<li>栈 是 <strong>后进先出</strong> (last in first out) 的线性表 (简称 LIFO 结构)</li>
</ul>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231024125103470.png" alt="image-20231024125103470" style="zoom:50%;">

<p>栈的数据结构的抽象定义：</p>
<div class="highlight-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ADT Stack&#123;</span><br><span class="line">    数据对象: D = &#123;ai|ai∈TermSet, i = 1,2,...,n,  n≥0</span><br><span class="line">              TermSet 中每个元素都包含一个表示系数的实数和表示指数的整数&#125;</span><br><span class="line">    </span><br><span class="line">    数据关系：R1 = &#123;&lt;a(i-1), ai&gt;|a(i-1), ai ∈ D,i = 2,...,n&#125;</span><br><span class="line">    		约定 an 为栈顶，a1 为栈底</span><br><span class="line">    基本操作：</span><br><span class="line">        InitStack(&amp;S)</span><br><span class="line">        操作结果：构造一个空栈S.</span><br><span class="line">        DestroyStack(&amp;S)</span><br><span class="line">            初始条件：栈S已存在.</span><br><span class="line">            操作结果：栈S被销毁.</span><br><span class="line">        ClearStack(&amp;S)</span><br><span class="line">            初始条件：栈S已存在.</span><br><span class="line">            操作结果：栈S清为空栈.</span><br><span class="line">        StackEmpty(&amp;S)</span><br><span class="line">            初始条件：栈S已存在.</span><br><span class="line">            操作结果：若栈S为空栈，则返回 TRUE，否则返回 FALSE.</span><br><span class="line">        StackLength(&amp;S)</span><br><span class="line">            初始条件：栈S已存在.</span><br><span class="line">            操作结果：返回S的元素个数，即栈的长度.</span><br><span class="line">        GetTop(S, &amp;e)</span><br><span class="line">            初始条件：栈S已存在且非空.</span><br><span class="line">            操作结果：用 e 返回 S的栈顶元素.</span><br><span class="line">        Push(&amp;S, e)</span><br><span class="line">            初始条件：栈S已存在.</span><br><span class="line">            操作结果：插入元素 e 为新的栈顶元素.</span><br><span class="line">        Pop(&amp;S, &amp;e)</span><br><span class="line">            初始条件：栈S已存在且非空.</span><br><span class="line">            操作结果：删除S的栈顶元素，并用 e 返回其值.</span><br><span class="line">        StackTraverse(S.visit())</span><br><span class="line">            初始条件：栈S已存在且非空.</span><br><span class="line">            操作结果：从栈底到栈顶依次对 S 的每个数据元素调用函数 visit().一旦visit()失败，则操作失败</span><br><span class="line">            </span><br><span class="line">&#125;ADT Stack</span><br></pre></td></tr></table></figure></div>



<h3 id="3-1-2-栈的表示和实现"><a href="#3-1-2-栈的表示和实现" class="headerlink" title="3.1.2 栈的表示和实现"></a>3.1.2 栈的表示和实现</h3><p>栈的两种存储表示方式：<strong>顺序栈</strong> 和 <strong>链栈</strong> 。</p>
<p><strong>顺序栈</strong>，栈的顺序存储结构，利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈的位置。通常以 top &#x3D; 0 表示空栈。</p>
<p>设定两个常量<code>STACK_INIT_SIZE</code>(存储空间初始分配量)和 <code>STACKINCREMENT</code> (存储空间分配增量)，并以下述类型说明作为顺序栈的定义。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    SElemType * base;</span><br><span class="line">    SElemType * top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></div>

<p><code>stacksize</code> 指示栈的当前可使用的最大容量。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231024135621931.png" alt="image-20231024135621931" style="zoom:50%;">

<p><strong>顺序栈的模块说明</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ADT Stack 的表示和实现</span></span><br><span class="line"><span class="comment">// 栈的顺序存储表示</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    SElemType * base;</span><br><span class="line">    SElemType * top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="comment">// 基本操作的函数原型说明</span></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(SqStack &amp;S)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S, SElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">StackTraverse</span><span class="params">(SqStack S, Status(*visit)())</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>基本操作的算法描述（部分）</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构造一个空栈</span></span><br><span class="line">    S.base = (SElemType *)<span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">    <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = STACK_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// InitStack</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S, SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 若栈不空，则用 e 返回 S 的栈顶元素，并返回 OK，否则返回 ERROR</span></span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *(S.top - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;  <span class="comment">// GetTop</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 插入元素 e 为新的栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span>(S.top - S.base &gt;= S.stacksize)&#123;  <span class="comment">// 栈满，追加存储空间</span></span><br><span class="line">        S.base = (SElemType *)<span class="built_in">realloc</span>(S.base, </span><br><span class="line">                 (S.stacksize + STACKINCREMENT)*<span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">        <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(OVERFLOW); <span class="comment">//存储分配失败</span></span><br><span class="line">        S.top = S.base+S.stacksize;</span><br><span class="line">        S.stacksize += STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++ = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// Push</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 若栈不空，则删除 S 的栈顶元素，用 e 返回其值，并返回 OK；否则返回 ERROR</span></span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = * --S.top;</span><br><span class="line">&#125; <span class="comment">//Pop</span></span><br></pre></td></tr></table></figure></div>



<p><strong>链栈</strong>：</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231024151926560.png" alt="image-20231024151926560" style="zoom:50%;">



<p><strong>共享栈</strong>：</p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231027145320894.png" class title="image-20231027145320894">





<h2 id="3-2-栈的应用"><a href="#3-2-栈的应用" class="headerlink" title="3.2 栈的应用"></a>3.2 栈的应用</h2><h3 id="3-2-1-数制转换"><a href="#3-2-1-数制转换" class="headerlink" title="3.2.1 数制转换"></a>3.2.1 数制转换</h3><p>十进制数 <em>N</em> 和其他 <em>d</em> 进制数的转换。基本原理：<br>$$<br>N &#x3D; (N\ \mathrm{div} \ d) \times d+N\  \mathrm{mod}\ d<br>$$<br><img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231024152930416.png" alt="image-20231024152930416" style="zoom:50%;"></p>
<p>上述计算过程是从低位到高位顺序产生八进制数的各个数位，而打印输出一般是从高位到地位进行，伪代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">conversion</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 对于输入的任一个非负十进制整数，打印输出与其等值的八进制数</span></span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, N);</span><br><span class="line">    <span class="keyword">while</span>(N)&#123;</span><br><span class="line">        <span class="built_in">Push</span>(S, N%<span class="number">8</span>);</span><br><span class="line">        N /= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(s))&#123;</span><br><span class="line">        <span class="built_in">Pop</span>(S,e);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// conversion</span></span><br></pre></td></tr></table></figure></div>

<p>c++代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">conversion</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">while</span>(N)&#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(N%<span class="number">8</span>);</span><br><span class="line">        N /= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="3-2-2-表达式求值"><a href="#3-2-2-表达式求值" class="headerlink" title="3.2.2 表达式求值"></a>3.2.2 表达式求值</h3><p><strong>四则运算求值</strong> 规则：（1）先乘除，后加减；（2）从左算到右；（3）先括号内，后括号外</p>
<p>设定任意两个相继出现的运算符 $\theta_1$ 和 $\theta_2$ 之间的优先关系，最多有以下三种关系：$\theta_1 &lt; \theta_2$ ，$\theta_1$ 的优先权低于 $\theta_2$ ；$\theta_1 &#x3D; \theta_2$，$\theta_1$ 的优先权等于 $\theta_2$ ；$\theta_1&gt;\theta_2$ ，$\theta_1$ 的优先权高于 $\theta_2$ 。</p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024154608246.png" class title="image-20231024154608246">

<p>为了实现算符优先算法，可以使用两个工作栈。一个称作 OPTR，用以寄存 运算符；另一个叫做 OPND，用于 寄存操作数或运算结果。算法基本思想：</p>
<p>（ 1 ）首先置操作数栈为空栈，表达式起始符 “#” 为运算符栈的栈底元素</p>
<p>（ 2 ）依次读入表达式中每个字符，若是操作数则进入 OPND 栈，若是运算符则和 OPTR 栈的栈顶运算符进行优先权 比较后进行相应运算操作。</p>
<p>（ 3 ）如此，直至整个表达式求值完毕 （即 OPTR 栈的栈顶元素和读入的字符均为 “#” ）</p>
<p><strong>算法实现</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OperandType <span class="title">EvaluateExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 算术表达式求值的算符优先算法，设 OPTR 和 OPND 分别为运算符栈和运算数栈</span></span><br><span class="line">    <span class="comment">// OP 为运算符集合</span></span><br><span class="line">    <span class="built_in">InitStack</span>(OPTR);  <span class="built_in">Push</span>(OPTR, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    <span class="built_in">InitStack</span>(OPND);  c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c! = <span class="string">&#x27;#&#x27;</span> || <span class="built_in">GetTop</span>(OPTR) != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">In</span>(c, OP))&#123; <span class="built_in">Push</span>(OPND, c); c = <span class="built_in">getchar</span>(); &#125; <span class="comment">// 不是运算符则进栈</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">switch</span>(<span class="built_in">Precede</span>(<span class="built_in">GetTop</span>(OPTR), c))&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:  <span class="comment">// 栈顶元素优先权低</span></span><br><span class="line">                    <span class="built_in">Push</span>(OPTR, c); c = <span class="built_in">getchar</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:  <span class="comment">// 脱括号并接受下一个字符</span></span><br><span class="line">                    <span class="built_in">Pop</span>(OPTR, x); c = <span class="built_in">getchar</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:  <span class="comment">// 退栈，将运算符结果入栈</span></span><br><span class="line">                    <span class="built_in">Pop</span>(OPTR, theta);</span><br><span class="line">                    <span class="built_in">Pop</span>(OPND, b);  <span class="built_in">Pop</span>(OPND, a);</span><br><span class="line">                    <span class="built_in">Push</span>(OPND, <span class="built_in">Operate</span>(a, theta, b));</span><br><span class="line">                    <span class="keyword">break</span>;       </span><br><span class="line">            &#125; <span class="comment">// switch</span></span><br><span class="line">    &#125; <span class="comment">// while</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetTop</span>(OPND);</span><br><span class="line">&#125; <span class="comment">// EvaluateExpression</span></span><br></pre></td></tr></table></figure></div>





<h2 id="3-3-栈与递归的实现"><a href="#3-3-栈与递归的实现" class="headerlink" title="3.3 栈与递归的实现"></a>3.3 栈与递归的实现</h2><p>一个直接调用自己，或通过一系列调用语句间接地调用自己的函数，称做递归函数。</p>
<p><strong>递归的应用</strong></p>
<p>阶乘函数：<br>$$<br>\mathrm{Fact}(n) &#x3D; \begin{cases}1&amp;若n &#x3D; 0 \ n·\mathrm{Fact}(n-1)&amp; 若n&gt;0 \end{cases}<br>$$<br>2 阶 $\mathrm{Fibonacci}$ 数列：<br>$$<br>\mathrm{Fib}(n) &#x3D; \begin{cases}0 &amp;若n &#x3D; 0 \1&amp;若 n &#x3D; 1\ \mathrm{Fib}(n-1)+\mathrm{Fib}(n-2)&amp; 其他情形 \end{cases}<br>$$</p>
<h3 id="3-3-1-n-阶汉诺塔问题"><a href="#3-3-1-n-阶汉诺塔问题" class="headerlink" title="3.3.1  n 阶汉诺塔问题"></a>3.3.1  n 阶汉诺塔问题</h3><p> 假设有 3 个分别命名为 X、Y 和 Z 的塔座，在塔座 X 上插有 $n$ 个直径大小各不相同、依小到大编号为 1,2,···,n 的圆盘。要求将 X 轴上的 $n$ 个圆盘移至塔座 Z 上并仍按同样顺序叠排，圆盘移动时必须遵循下列规则：<br>（ 1 ）每次只能移动一个圆盘；（ 2 ）圆盘可以插在 X、Y 和 Z 中的任一塔座上；（ 3 ）任何时刻都不能将一个较大的圆盘压在较小的圆盘之上。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231024184916937.png" alt="image-20231024184916937" style="zoom:50%;">

<p>如何实现移动圆盘操作：</p>
<ul>
<li>n &#x3D; 1 时，只要将编号为 1 的圆盘从 塔座X 直接移动到 塔座 Z</li>
<li>，n &gt; 1 时，需利用塔座 Y 作辅助塔座，若能设法将压在编号为 n 的圆盘之上的 n-1 圆盘从塔座 X 移动到 塔座 Y 上，则可先将 编号为 n 的圆盘从塔座 X 移至 塔座 Z，然后再将塔座 Y 上的 n-1 个圆盘（依照上述法则）移至塔座 Z 上。<br>而如何将 n-1 个圆盘从一个塔座移至另一个塔座是一个和原问题具有相同的特征属性的问题，指示问题规模小 1，因此可以用相同的方法求解。</li>
</ul>
<p>算法实现代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> x, <span class="type">char</span> y, <span class="type">char</span> z)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 将塔座x上按直径由小到大且自上而下编号为1至n的n个圆盘规则搬到</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 塔座z上，y可用作辅助塔座</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 搬动操作 move(x,n,z) 可定义为(c是初值为0的全局变量，对搬动计数)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// printf(&quot;%i, Move disk %i from %c to %c\n&quot;, ++c, n, x, z);</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">move</span>(x, <span class="number">1</span>, z);     <span class="comment">// 将编号为 1 的圆盘从 x 移动到 z</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">hanoi</span>(n<span class="number">-1</span>,x,z,y);  <span class="comment">// 将 x 上编号为 1 到 n-1 的圆盘移到 y,z 作辅助塔</span></span><br><span class="line">        <span class="built_in">move</span>(x,n,z);       <span class="comment">// 将编号为 n 的圆盘从 x 移到 z</span></span><br><span class="line">        <span class="built_in">hanoi</span>(n<span class="number">-1</span>,y,x,z);  <span class="comment">// 将 y 上编号为 1 至 n-1 的圆盘移到 z,x 作辅助塔</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="3-3-2-递归函数运行实质"><a href="#3-3-2-递归函数运行实质" class="headerlink" title="3.3.2  递归函数运行实质"></a>3.3.2  递归函数运行实质</h3><p>当在一个函数的运行期间调用另一个函数，在运行被调用函数之前，系统需先完成 3 件事：</p>
<ul>
<li>将 所有的实在参数、返回地址 等信息传递 给被调用函数保存</li>
<li>为 被调用函数的局部变量 分配存储区</li>
<li>将 控制转移到被调函数的入口</li>
</ul>
<p>从被调用函数返回调用函数之前，系统也应完成 3 件工作：</p>
<ul>
<li>保存 被调函数的计算结果</li>
<li>释放 被调函数的数据区</li>
<li>依照 被调函数保存的返回地址 将控制转移到 调用函数</li>
</ul>
<p>一个递归函数的运行过程 类似于 多个函数的嵌套调用，只是 调用函数 和 被调用函数 是同一个函数，因此，和每次调用相关的一个重要的概念是递归函数运行的 “层次” 。<br>假设调用该递归函数的主函数为 第 0 层，则从主函数调用递归函数为进入 第 1 层；从第 i 层递归调用本函数为 进入 “下一层”，即 i+1 层。反之，退出第 i 层递归则返回 i-1 层。</p>
<p>为保证 递归函数 正确执行，系统需设立一个 “<strong>递归工作栈</strong>” 作为整个递归函数运行期间使用的数据存储区。每一层递归所需信息构成一个“工作记录”，其中包括 <u>所有的实在参数、所有的局部变量以及上一层的返回地址</u>。<br>每进入一层递归，就产生一个新的工作记录压入栈顶。每退出一层递归，就从栈顶弹出一个工作记录，则当前执行层的工作记录必定是递归工作栈栈顶的工作记录，称这个记录 “活动记录”，并称指示活动记录的栈顶指针为 “当前环境指针”。</p>
<h2 id="3-4-队列"><a href="#3-4-队列" class="headerlink" title="3.4 队列"></a>3.4 队列</h2><h3 id="3-4-1-抽象数据类型队列的定义"><a href="#3-4-1-抽象数据类型队列的定义" class="headerlink" title="3.4.1 抽象数据类型队列的定义"></a>3.4.1 抽象数据类型队列的定义</h3><p><strong>队列</strong>（queue）是一种 <strong>先进先出</strong>（first in first out，缩写为 FIFO）的线性表。只允许在表的一端进行插入，而在另一端删除元素。允许插入的一端叫做 <strong>队尾</strong>（rear），允许删除的一端则称为 <strong>队头</strong>（front）。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231024194456519.png" alt="image-20231024194456519" style="zoom:50%;">

<p>队列的应用：操作系统中的作业排队。</p>
<p>队列的抽象数据类型定义：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ADT Queue&#123;</span><br><span class="line">    数据对象: D = &#123;ai|ai∈TermSet, i = <span class="number">1</span>,<span class="number">2</span>,...,n,  n≥<span class="number">0</span>&#125;</span><br><span class="line">    数据关系：R1 = &#123;&lt;<span class="built_in">a</span>(i<span class="number">-1</span>), ai&gt;|<span class="built_in">a</span>(i<span class="number">-1</span>), ai ∈ D,i = <span class="number">2</span>,...,n&#125;</span><br><span class="line">    		约定 a1 段为队列头，an 段为队列尾</span><br><span class="line">    基本操作：</span><br><span class="line">        <span class="built_in">InitQueue</span>(&amp;Q)</span><br><span class="line">            操作结果：构造一个空队列Q.</span><br><span class="line">        <span class="built_in">DestroyQueue</span>(&amp;Q)</span><br><span class="line">            初始条件：队列Q已存在.</span><br><span class="line">            操作结果：队列Q被销毁，不再存在.</span><br><span class="line">        <span class="built_in">ClearQueue</span>(&amp;Q)</span><br><span class="line">            初始条件：队列Q已存在.</span><br><span class="line">            操作结果：将Q清为空队列.</span><br><span class="line">        <span class="built_in">QueueEmpty</span>(Q)</span><br><span class="line">            初始条件：队列Q已存在.</span><br><span class="line">            操作结果：若Q为空队列，则返回TRUE,否则返回FALSE.</span><br><span class="line">        <span class="built_in">QueueLength</span>(Q)</span><br><span class="line">            初始条件：队列Q已存在.</span><br><span class="line">            操作结果：返回Q的元素个数，即队列的长度.</span><br><span class="line">        <span class="built_in">GetHead</span>(Q, &amp;e)</span><br><span class="line">            初始条件：队列Q已存在且非空.</span><br><span class="line">            操作结果：用 e 返回 Q的队头元素.</span><br><span class="line">        <span class="built_in">EnQueue</span>(&amp;Q, e)</span><br><span class="line">            初始条件：队列Q已存在.</span><br><span class="line">            操作结果：插入元素 e 为新的队尾元素.</span><br><span class="line">        <span class="built_in">DeQueue</span>(&amp;Q, &amp;e)</span><br><span class="line">            初始条件：队列Q已存在且非空.</span><br><span class="line">            操作结果：删除Q的队头元素，并用 e 返回其值.</span><br><span class="line">        <span class="built_in">QueueTraverse</span>(Q.<span class="built_in">visit</span>())</span><br><span class="line">            初始条件：队列Q已存在且非空.</span><br><span class="line">            操作结果：从队头到队尾依次对 Q 的每个数据元素调用函数 <span class="built_in">visit</span>().一旦<span class="built_in">visit</span>()失败，则操作失败</span><br><span class="line">&#125;ADT Queue</span><br></pre></td></tr></table></figure></div>



<p>双端队列是限定插入和删除操作在表的两端进行的线性表。这两段分别称为端点1和端点2。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231024200510456.png" alt="image-20231024200510456" style="zoom:50%;">



<h3 id="3-4-2-链队列-——-队列的链式表示和实现"><a href="#3-4-2-链队列-——-队列的链式表示和实现" class="headerlink" title="3.4.2 链队列 —— 队列的链式表示和实现"></a>3.4.2 链队列 —— 队列的链式表示和实现</h3><p>队列有两种存储表示：链式存储和线性存储。</p>
<p>链队列，需要两个分别指示队头和队尾的指针（分别称为 头指针 和 尾指针）。为操作方便，给队列添加一个头结点，并令头指针指向头结点。</p>
<p>单链队列的实现：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span>&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> * next;</span><br><span class="line">&#125;QNode, * QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QueuePtr front;  <span class="comment">// 队头指针</span></span><br><span class="line">    QueuePtr rear;   <span class="comment">// 队尾指针</span></span><br><span class="line">&#125;ListQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(LinkQueue Q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(LinkQueue Q, QElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">QueueTraverse</span><span class="params">(LinkQueue Q, visit())</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>基本操作的算法描述（部分）</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构造一个空队列 Q</span></span><br><span class="line">    Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 销毁队列 Q</span></span><br><span class="line">    <span class="keyword">while</span>(Q.front)&#123;</span><br><span class="line">        Q.rear = Q.front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(Q.front);</span><br><span class="line">        Q.front = Q.rear;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 插入元素 e 为 Q 的新的队尾元素</span></span><br><span class="line">    p = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    p-&gt;data = e; p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear -&gt; next = p;</span><br><span class="line">    Q.reat = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 若队列不空，则删除 Q 的队头元素，用 e 返回其值，并返回 OK</span></span><br><span class="line">    <span class="comment">// 否则返回 ERROR</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p = Q.front-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) Q.rear = Q.front;  <span class="comment">// 特殊情况，队列只有一个数据元素</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h3 id="3-4-3-循环队列——队列的顺序表示和实现"><a href="#3-4-3-循环队列——队列的顺序表示和实现" class="headerlink" title="3.4.3  循环队列——队列的顺序表示和实现"></a>3.4.3  循环队列——队列的顺序表示和实现</h3><ul>
<li><p>在非空队列中，队首指针始终指向队头元素，而队尾指针始终指向队尾元素的下一个位置。</p>
</li>
<li><p>在顺序队列中存在 “假溢出” 现象。因为在入队和出队操作中，头、尾指针只增加不减少，导致删除元素的空间永远无法重新利用。</p>
</li>
<li><p>因此，尽管队列中实际元素个数可能远远小于数组大小，但可能由尾指针已超出数组空间的上界而不能做入队操作。这种现象称为假溢出。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231024215659224.png" alt="image-20231024215659224" style="zoom:50%;"></li>
</ul>
<p>为充分利用数组空间，克服上述“假溢出”现象的方法：将队列分配的数组空间看成一个首位相接的圆环，并称这种队列为 <strong>循环队列</strong>。</p>
<ul>
<li><p>在循环队列中 进行出队、入队操作时，队首、队尾指针仍要加 1，朝前移动。只不过当队首、队尾指针指向数组上界（MAX_QUEUE_SIZE-1）时，其加 1 操作的结果是指向数组的下界 0：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i+<span class="number">1</span> == MAX_QUEUE_SIZE) i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> i++;</span><br></pre></td></tr></table></figure></div>

<p>其中 i 代表 队首指针或队尾指针</p>
<p>可以用 模运算简化为 ：<code>i = (i+1)%MAX_QUEUE_SIZE</code></p>
</li>
</ul>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231024213600750.png" alt="image-20231024213600750" style="zoom:50%;">

<ul>
<li>入队时尾指针向前追赶头指针，出队时，头指针向前追赶尾指针，故队空和队满尾指针均相等。</li>
<li>因此无法通过 <code>front = rear</code> 来判断队列 “空” 还是 “满”。<br>解决方法：约定入队前，测试尾指针在循环意义下加 1 是否等于头指针，若相等则认为队满。即：<ul>
<li>rear 所指的单元始终为空</li>
<li>循环队列为空：front &#x3D; rear</li>
<li>循环队列满：<code>(rear+1)%MAX_QUEUE_SIZE = front</code></li>
</ul>
</li>
</ul>
<p><strong>循环队列 vs. 非循环队列</strong></p>
<ul>
<li>队列主要用于保存中间数据，而且保存的数据满足先产生先处理的特点。非循环队列可能存在数据假溢出，即队列中还有空间，可是队满的条件却成立了。为此，改为循环队列，这样克服了假溢出。</li>
<li>但并不能说循环队列一定优于非循环队列，因为循环队列中出队元素的空间可能被后来进队的元素占用，如果算法要求 <strong>队列操作结束后利用进队的所有元素实现某种功能</strong>，这样循环队列就不适合了，这种情况下就需要使用非循环队列。</li>
</ul>
<h3 id="3-4-4-优先队列"><a href="#3-4-4-优先队列" class="headerlink" title="3.4.4 优先队列"></a>3.4.4 优先队列</h3><p>普通的队列是一种先进先出的数据结构，元素在队列尾追加，从队列头删除。</p>
<p>在优先队列中，<strong>每个元素都有一个优先级</strong>。具有<strong>最高优先级</strong>的元素<strong>最先出队</strong>。优先队列具有 最高级先出 的行为特征。优先队列执行的操作有 查找、插入一个新元素 和 删除 三种。</p>
<ul>
<li><p>优先队列和普通队列都适用在处理或服务对象需要按序逐个进行操作的场合，不过 <strong>优先队列关心对象的优先级</strong>，将队列按 <strong>优先级顺序</strong> 作 出队 处理。</p>
</li>
<li><p>例子：</p>
<ul>
<li><p>操作系统的任务调度</p>
<p>对操作系统而言，当有多个任务需要处理的时候，一般而言，解决这个问题的简单策略就是把任务放在一个队列中，先来者先服务，这是公平的，虽然对每个任务本身来说，都期望是能够被立即执行而不仅仅是被执行。 实际中会出现提交一个执行时间很短的任务可能要等很长的时间才能被执行的情形，因为在它之前已经有许多执行时间很长的任务，在队列中等待执行，这样会导致用户的使用感受不好。 解决此问题的一个策略是利用优先队列，按照“任务需要执行的时间越短，它的优先权越高”的原则，按任务的轻重顺序执行，可以使用户的平均等待时间最短。</p>
</li>
<li><p>多媒体通讯网络中的数据包调度</p>
</li>
<li><p>集合中的元素搜索</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-5-队列的应用"><a href="#3-4-5-队列的应用" class="headerlink" title="3.4.5  队列的应用"></a>3.4.5  队列的应用</h3><ul>
<li>只要满足 <strong>先来先服务</strong> 特性的应用均可采用队列作为其数据组织方式或中间数据结构。</li>
<li>调度或缓冲：消息缓冲器、邮件缓冲器、计算机的硬件设备之间的通信也需要队列作为数据缓冲、操作系统的资源管理</li>
<li>广度优先搜索</li>
</ul>
<p><strong>回文串的判断</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Palindrome_Test</span><span class="params">(<span class="type">char</span> * str)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//判断输入的字符串是否回文序列，是则返回 true，否则返回 false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> *c = str; *c != <span class="string">&#x27;\0&#x27;</span>; c++)&#123;</span><br><span class="line">        <span class="built_in">Push</span>(S, *c);</span><br><span class="line">        <span class="built_in">EnQueue</span>(Q, *c);  <span class="comment">// 同时使用栈和队列两种结构</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(S))&#123;</span><br><span class="line">        <span class="built_in">Pop</span>(S, a);</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, b);</span><br><span class="line">        <span class="keyword">if</span>(a != b) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>用两个栈 S1 和 S2 模拟一个队列</strong>，写出入队和出队的算法（可用栈的基本操作）</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(DualStack &amp;Q, QElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Q.<span class="built_in">StackFull</span>(S1)) Q.<span class="built_in">push</span>(S1, e);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(Q.<span class="built_in">StackEmpty</span>(S2))&#123;</span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">StackEmpty</span>(S1)) Q.<span class="built_in">Push</span>(S2, Q.<span class="built_in">Pop</span>(S1));</span><br><span class="line">        Q.<span class="built_in">Push</span>(S1, e);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(DualStack &amp;Q, QElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Q.<span class="built_in">StackEmpty</span>(S1) || !Q.<span class="built_in">StackEmpty</span>(S2))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Q.<span class="built_in">StackEmpty</span>(S2)) a = Q.<span class="built_in">Pop</span>(S2);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!Q.<span class="built_in">StackEmpty</span>(S1)) Q.<span class="built_in">Push</span>(S2, Q.<span class="built_in">Pop</span>(S1));</span><br><span class="line">            a = Q.<span class="built_in">Pop</span>(S2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="4-串"><a href="#4-串" class="headerlink" title="4 串"></a>4 串</h1><h2 id="4-1-串类型的定义"><a href="#4-1-串类型的定义" class="headerlink" title="4.1 串类型的定义"></a>4.1 串类型的定义</h2><p><strong>串</strong> (string)(或字符串) 是由零个或多个字符组成的有限序列</p>
<ul>
<li>一般记为 $s &#x3D; “a_1a_2\cdots a_n”\ \ (n\geqslant 0)$ 。其中，$s$ 是串的名，用双引号括起来的字符序列是串的值；$a_i(1\leqslant i \leqslant n)$ 可以是 字母、数字或其他字符；</li>
<li>串中字符的数目 $n$ 称为串的 <strong>长度</strong>。</li>
<li>零个字符的串称为 <strong>空串</strong> (null string)，它的长度为零。用 $\varnothing$ 表示 “空串”。</li>
<li>通常将仅由一个或多个<strong>空格</strong>组成的串称为 空白<strong>串</strong>（Blank String），注意 空串和空白串的不同。 <code>&quot;&quot;</code> 和 <code>&quot; &quot;</code> 分别表示长度为0的空串和长度为 1 的空白串。</li>
<li>串中 任意个 <strong>连续的字符</strong> 组成的子序列称为串的子串。包含子串的串相应地称为 <strong>主串</strong>。</li>
<li>通常称字符在序列中的序号为该字符在串中的位置，子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。</li>
<li>只有当两个串的长度相等，并且各个对应位置的字符都相等时两个串才相等</li>
<li>串值必须用<strong>一对双引号</strong>括起来。</li>
</ul>
<p>字符串常数：<code>&quot;\n&quot;</code> </p>
<p>字符串变量：<code>a = &quot;program&quot;</code> </p>
<p>串的逻辑结构和线性表极为相似，区别在于 串的数据对象约束为字符集。在串的基本操作中，通常以 “串的整体” 作为操作对象，例如在串中查找某个子串，求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。</p>
<p>串的抽象数据类型定义如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ADT Queue&#123;</span><br><span class="line">    数据对象: D = &#123;ai|ai∈TermSet, i = <span class="number">1</span>,<span class="number">2</span>,...,n,  n≥<span class="number">0</span>&#125;</span><br><span class="line">    数据关系：R1 = &#123;&lt;<span class="built_in">a</span>(i<span class="number">-1</span>), ai&gt;|<span class="built_in">a</span>(i<span class="number">-1</span>), ai ∈ D,i = <span class="number">2</span>,...,n&#125;</span><br><span class="line">    基本操作：</span><br><span class="line">        <span class="built_in">StrAssign</span>(&amp;T, chars);</span><br><span class="line">    		初始条件：chars 是字符串常量</span><br><span class="line">			操作结果：生成一个其值等于chars的串<span class="function">T</span></span><br><span class="line"><span class="function">        <span class="title">StrCopy</span><span class="params">(&amp;T, S)</span></span>;</span><br><span class="line">			初始条件：串S存在</span><br><span class="line">			操作结果：由串S复制得到串<span class="function">T</span></span><br><span class="line"><span class="function">        <span class="title">StrEmpty</span><span class="params">(S)</span></span>;</span><br><span class="line">			初始条件：串S存在</span><br><span class="line">			操作结果：若S为空串，则返回 TRUE，否则返回<span class="function">FALSE</span></span><br><span class="line"><span class="function">        <span class="title">StrCompare</span><span class="params">(S,T)</span></span>;</span><br><span class="line">			初始条件：串S和T存在</span><br><span class="line">			操作结果：若 S&gt;T,则返回值&gt;<span class="number">0</span>;若 S=T,则返回值=<span class="number">0</span>;若S&lt;T,则返回值&lt;<span class="number">0</span></span><br><span class="line">        <span class="built_in">StrLength</span>(S);</span><br><span class="line">			初始条件：串S存在</span><br><span class="line">			操作结果：返回S的元素个数,称为串的长度</span><br><span class="line">        <span class="built_in">ClearString</span>(&amp;S);</span><br><span class="line">			初始条件：串S存在</span><br><span class="line">			操作结果：将S清为空串</span><br><span class="line">        <span class="built_in">Concat</span>(&amp;T, S1, S2);</span><br><span class="line">			初始条件：串S1和S2存在</span><br><span class="line">			操作结果：用T返回由S1和S2联接而成的新串。</span><br><span class="line">        <span class="built_in">SubString</span>(&amp;Sub, S, pos, len);</span><br><span class="line">			初始条件：串S存在,<span class="number">1</span>&lt;=pos&lt;=<span class="built_in">StrLength</span>(S)且<span class="number">0</span>&lt;=len&lt;=<span class="built_in">StrLength</span>(S)-pos+<span class="number">1</span></span><br><span class="line">			操作结果：用 Sub 返回串的第 pos 个字符起长度为 len 的子串</span><br><span class="line">        <span class="built_in">Index</span>(S, T, pos);</span><br><span class="line">			初始条件：串S和T存在,T是非空串,<span class="number">1</span>&lt;=pos&lt;=<span class="built_in">StrLength</span>(S)</span><br><span class="line">			操作结果：若主串S出现和串T值相同的子串,则返回它在主串S中第pos个字符之后第一次出现的位置,否则函数值为<span class="number">0</span></span><br><span class="line">        <span class="built_in">Replace</span>(&amp;S, T, V);</span><br><span class="line">			初始条件：串S,T和V存在,T是非空串</span><br><span class="line">			操作结果：用V替换主串S中出现的所有与T相等的不重叠的子串</span><br><span class="line">        <span class="built_in">StrInsert</span>(&amp;S, pos, T);</span><br><span class="line">			初始条件：串S和T存在,<span class="number">1</span>&lt;=pos&lt;=<span class="built_in">StrLength</span>(S)+<span class="number">1</span></span><br><span class="line">			操作结果：在串S的第pos个字符之前插入串T</span><br><span class="line">        <span class="built_in">StrDelete</span>(&amp;S, pos, len);</span><br><span class="line">			初始条件：串S存在,<span class="number">1</span>&lt;=pos&lt;=<span class="built_in">StrLength</span>(S)-len+<span class="number">1</span></span><br><span class="line">			操作结果：从串S中删除第pos个字符起长度为len的子串</span><br><span class="line">        <span class="built_in">DestroyString</span>(&amp;S);</span><br><span class="line">			初始条件：串S存在</span><br><span class="line">			操作结果：串S被销毁</span><br><span class="line">&#125;ADT String</span><br></pre></td></tr></table></figure></div>



<p>串类型的 <strong>最小操作子集</strong>：</p>
<ul>
<li>串赋值（StrAssign）</li>
<li>串比较（StrCompare）</li>
<li>求串长（StrLength）</li>
<li>串联结（Concat）</li>
<li>求子串（SubString）</li>
</ul>
<p><strong>字符</strong>（char）：组成字符串的基本单元，在C和C++中，字符占单个字节（8 bits），采用 ASCII码 对 128个符号（字符集 charset）进行编码。</p>
<p><strong>标准字符串</strong>：将 C++ 的 <code>&lt;string.h&gt;</code> 函数库作为字符串数据类型的方案。例如<code>char S[M]</code><br>字符串的结束标记：<code>&#39;\0&#39;</code> ，<code>&#39;\0&#39;</code> 是 ASCII 码中 8位全0码，又称 NULL符</p>
<p>函数库的字符串操作函数：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串长函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strlen</span><span class="params">(<span class="type">char</span>* s)</span></span>;</span><br><span class="line"><span class="comment">// 字符串复制</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* s1, <span class="type">char</span>* s2)</span></span>;</span><br><span class="line"><span class="comment">// 字符串拼接</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcat</span><span class="params">(<span class="type">char</span>* s1, <span class="type">char</span>* s2)</span></span>;</span><br><span class="line"><span class="comment">// 字符串比较</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">char</span>* s1, <span class="type">char</span>* s2)</span></span>;</span><br><span class="line"><span class="comment">// 定位函数</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strchr</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="comment">// 逆定位函数</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strrchr</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span> c)</span></span>;</span><br></pre></td></tr></table></figure></div>





<h2 id="4-2-串的表示和实现"><a href="#4-2-串的表示和实现" class="headerlink" title="4.2 串的表示和实现"></a>4.2 串的表示和实现</h2><p>串是一种特殊的线性表，存储方式取决于对字符串所进行的操作。字符串在计算机中有 3 种表示方式：</p>
<ul>
<li>定长顺序存储表示：将字符串定义成字符数组，利用字符串名可以直接访问字符串值。用这种表示方式，字符串的存储空间在编译时确定，其大不能改变。</li>
<li>堆分配存储方式：仍然用一组地址连续的存储单元来依次存储字符串中的字符序列，但字符串的存储空间是在程序运行时根据字符串的实际长度动态分配的。</li>
<li>块链存储方式：是一种链式存储结构表示</li>
</ul>
<h3 id="4-2-1-定长顺序存储表示"><a href="#4-2-1-定长顺序存储表示" class="headerlink" title="4.2.1 定长顺序存储表示"></a>4.2.1 定长顺序存储表示</h3><p>用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串的定长顺序存储表示</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRLEN 256   <span class="comment">// 用户可在 255 以内定义最大串长</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[MAX_STRLEN];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;StringType;</span><br></pre></td></tr></table></figure></div>

<p>串的实际长度可以在这预定义长度范围内，超过预定义长度的串值则被舍弃，称之为 “截断”。</p>
<p><strong>字符串的联结操作</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StrConcat</span><span class="params">(StringType &amp;s, StringType t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将字符串 t 联结到字符串s之后，结果仍然保存在s中</span></span><br><span class="line">    <span class="keyword">if</span>(s.length+t.length &gt; MAX_STRLEN)</span><br><span class="line">        <span class="keyword">return</span> ERROR;  <span class="comment">//联结长度超出范围</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;t.length; i++)&#123;</span><br><span class="line">        s.str[s.length+i] = t.str[i];  <span class="comment">// 将字符串 t 联结到字符串之后</span></span><br><span class="line">    &#125;</span><br><span class="line">    s.length = s.length+t.length;  <span class="comment">// 修改联结后的字符串长度</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>求子串操作（已知位置）</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SubString</span><span class="params">(StringType s, <span class="type">int</span> pos, <span class="type">int</span> len, StringType* sub)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; s.length || len &lt; <span class="number">0</span> || len &gt; (s.length-pos+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ERROR;  <span class="comment">// 参数非法</span></span><br><span class="line">    </span><br><span class="line">    sub-&gt;length = len-pos+<span class="number">1</span>;  <span class="comment">// 求得子串长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>, k = pos; k&lt;len; k++, j++)</span><br><span class="line">        sub-&gt;str[j] = s.str[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="4-2-2-堆分配存储表示"><a href="#4-2-2-堆分配存储表示" class="headerlink" title="4.2.2 堆分配存储表示"></a>4.2.2 堆分配存储表示</h3><p>这种存储表示的特点，仍以一组地址连续的存储单元存放串值字符序列，但它们的存储空间是在程序执行过程中<strong>动态分配</strong>而得。</p>
<p>实现方式：在 C 语言中，存在一个称之为 “堆” 的自由存储区，并由 C 语言的动态分配函数 <code>malloc()</code> 和 <code>free()</code> 来管理。利用函数 <code>malloc()</code> 为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则返回一个指向初始地址的指针，作为串的基址。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串的堆分配存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span>* ch;    <span class="comment">// 若是非空串，则按串长分配</span></span><br><span class="line">    <span class="type">int</span> length;  <span class="comment">// 字符串的长度</span></span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure></div>



<p><strong>字符串的联结操作</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StrConcat</span><span class="params">(HString &amp;T, HString S1, HString S2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 用 T 返回由 s1 和 s2 联结而成的串</span></span><br><span class="line">   	<span class="keyword">if</span>(T.ch) <span class="built_in">free</span>(T.ch);</span><br><span class="line">    t_len = S1.length+S2.length;</span><br><span class="line">    <span class="keyword">if</span>(!(T.ch = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*t_len))) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;S1.length; i++)&#123;</span><br><span class="line">        T.ch[pos++] = S1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;S2.length; i++)&#123;</span><br><span class="line">        T.ch[pos++] = S2[i];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>指定位置的字符串插入</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StrInsert</span><span class="params">(HString &amp;S, <span class="type">int</span> pos, HString T)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1&lt;= pos &lt;= StrLength(S)+1, 在串S的第pos个字符之前插入串T</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; S.length+<span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(S.ch=(<span class="type">char</span>* )<span class="built_in">realloc</span>(S.ch, (S.length+T.length)*<span class="built_in">sizeof</span>(<span class="type">char</span>))))</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        <span class="keyword">for</span>(i = S.length<span class="number">-1</span>; i&gt;=pos<span class="number">-1</span>; --i)  <span class="comment">// 为插入 T 而腾出位置</span></span><br><span class="line">            S.ch[i+T.length] = S.ch[i];</span><br><span class="line">        S.ch[pos<span class="number">-1</span> ... pos+T.length<span class="number">-2</span>] = T.ch[<span class="number">0</span> ... T.length<span class="number">-1</span>];   <span class="comment">// 插入 T</span></span><br><span class="line">        S.length+=T.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>ADT String 的表示和实现</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串的堆分配存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> * ch;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作函数原型</span></span><br><span class="line"><span class="function">Status <span class="title">StrAssign</span><span class="params">(HString &amp;T, <span class="type">char</span>* chars)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrLength</span><span class="params">(HString S)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrCompare</span><span class="params">(HString S, HString T)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">ClearString</span><span class="params">(HString &amp;S)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">Concat</span><span class="params">(HString &amp;T, HString S1, HString S2)</span></span>;</span><br><span class="line"><span class="function">HString <span class="title">SubString</span><span class="params">(HString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础操作算法描述</span></span><br><span class="line"><span class="function">Status <span class="title">StrAssign</span><span class="params">(HString &amp;T, <span class="type">char</span>* chars)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 生成一个其值等于串常量chars的串T</span></span><br><span class="line">    <span class="keyword">if</span>(T.ch) <span class="built_in">free</span>(T.ch);  <span class="comment">// 释放 T 原有空间</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, c = chars; c; ++i, ++c);  <span class="comment">// 求chars的长度 i</span></span><br><span class="line">    <span class="keyword">if</span>(!i)&#123;T.ch = <span class="literal">NULL</span>; T.length = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(T.ch = (<span class="type">char</span>*)<span class="built_in">malloc</span>(i*<span class="built_in">sizeof</span>(<span class="type">char</span>)))) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        T.ch[<span class="number">0</span> ... i<span class="number">-1</span>] = chars[<span class="number">0</span> ... i<span class="number">-1</span>];</span><br><span class="line">        T.length = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// StrAssign</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrLength</span><span class="params">(HString S)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 返回S的元素个数，称为串的长度</span></span><br><span class="line">    <span class="keyword">return</span> S.length;</span><br><span class="line">&#125;  <span class="comment">// StrLength</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ClearString</span><span class="params">(HString &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将 S 清为空串</span></span><br><span class="line">    <span class="keyword">if</span>(S.ch)&#123;<span class="built_in">free</span>(S.ch);  S.ch = <span class="literal">NULL</span>;&#125;</span><br><span class="line">    S.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// ClearString</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Concat</span><span class="params">(HString &amp;T, HString S1, HString S2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 用 T 返回由S1和S2联结而成的新串</span></span><br><span class="line">    <span class="keyword">if</span>(T.ch) <span class="built_in">free</span>(T.ch);</span><br><span class="line">    <span class="keyword">if</span>(!(T.ch = (<span class="type">char</span>*)<span class="built_in">malloc</span>((S1.length + S2.length)*<span class="built_in">sizeof</span>(<span class="type">char</span>))))</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    T.ch[<span class="number">0</span> ... S1.length<span class="number">-1</span>] = S1.ch[<span class="number">0</span> ... S1.length<span class="number">-1</span>];</span><br><span class="line">    T.length = S1.length + S2.length;</span><br><span class="line">    T.ch[S1.length ... T.length<span class="number">-1</span>] = S2.ch[<span class="number">0</span> ... S2.length<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// Concat</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">SubString</span><span class="params">(HString &amp;Sub, HString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 用 Sub 返回串 S 的第pos个字符起长度为 len 的子串</span></span><br><span class="line">    <span class="comment">// 其中, 1&lt;=pos&lt;=StrLength(S) 且 0&lt;=len&lt;=StrLength(S)-pos+1</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; S.length || len&lt;<span class="number">0</span> || len.S.length-pos+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(Sub.ch) <span class="built_in">free</span>(Sub.ch);</span><br><span class="line">    <span class="keyword">if</span>(!len)&#123;Sub.ch = <span class="literal">NULL</span>; Sub.length = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Sub.ch = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len*<span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        Sub.ch[<span class="number">0</span> ... len<span class="number">-1</span>] = S.ch[pos<span class="number">-1</span> ... pos+len<span class="number">-2</span>];</span><br><span class="line">        Sub.length = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="4-2-3-串的块链存储表示"><a href="#4-2-3-串的块链存储表示" class="headerlink" title="4.2.3 串的块链存储表示"></a>4.2.3 串的块链存储表示</h3><p>可以采用 链表方式 存串值。结构中的每个数据元素是一个字符，则用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。</p>
<p>串的块链存储表示：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 80  <span class="comment">// 可由用于定义的块大小</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Chunk</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[CHUNKSIZE];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Chunk</span> *next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    Chunk * head, * tail;   <span class="comment">// 串的头和尾指针</span></span><br><span class="line">    <span class="type">int</span> curlen;             <span class="comment">// 串的当前长度</span></span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure></div>

<p>串的存储密度：<br>$$<br>存储密度 &#x3D; \cfrac{串值所占的存储位}{实际分配的存储位}<br>$$<br>存储密度小（如结点大小为1时），运算处理方便，然而，存储占用量大。如果在串处理过程中需要进行行内外存交换时，会因为内外存交换操作过多而影响处理的总效率。</p>
<h2 id="4-3-串的模式匹配算法"><a href="#4-3-串的模式匹配算法" class="headerlink" title="4.3 串的模式匹配算法"></a>4.3 串的模式匹配算法</h2><h3 id="4-3-1-求子串位置的定位函数-Index-S-T-pos"><a href="#4-3-1-求子串位置的定位函数-Index-S-T-pos" class="headerlink" title="4.3.1 求子串位置的定位函数 Index(S, T, pos)"></a>4.3.1 求子串位置的定位函数 <code>Index(S, T, pos)</code></h3><p>子串的定位操作 通常称为 串的模式匹配（其中 T 称为 模式串），是各种串处理系统中最重要的操作之一。最朴素的模式匹配算法：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 返回子串T在主串中第pos个字符之后的位置。若不存在，则函数值为0</span></span><br><span class="line">    <span class="comment">// 其中,T非空,1&lt;=pos&lt;=StrLength(S)</span></span><br><span class="line">    i = pos<span class="number">-1</span>; j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;S.length &amp;&amp; j&lt;T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == T[j])&#123;++i; ++j; &#125;  <span class="comment">// 继续比较后继字符</span></span><br><span class="line">        <span class="keyword">else</span>&#123; i = i-j+<span class="number">2</span>; j = <span class="number">0</span>;&#125;  <span class="comment">// 指针后退重新开始匹配</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T[<span class="number">0</span>]) <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="4-3-2-KMP算法"><a href="#4-3-2-KMP算法" class="headerlink" title="4.3.2 KMP算法"></a>4.3.2 KMP算法</h3><p><strong>算法流程</strong></p>
<p>假设现在文本串匹配到 i 位置，模式串 P 匹配到 j 位置</p>
<ul>
<li>如果 j &#x3D; -1，或者当前字符匹配成功（即 <code>S[i] == P[j]</code>），都令 <code>i++, j++</code> ，继续匹配下一个字符</li>
<li>如果 j !&#x3D; -1 且当前字符匹配失败（即 <code>S[i] != P[i]</code>），则令 i 不变，<code>j = next[j]</code> ，这意味着模式串 P 相对于文本串 S 向右移动了 <code>j-next[j]</code> 位。</li>
</ul>
<p><strong>算法关键</strong></p>
<ul>
<li>寻找前缀和后最最长公共元素长度</li>
<li>求 next 数组</li>
<li>匹配失配的处理</li>
</ul>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231025151319839.png" alt="image-20231025151319839" style="zoom:50%;">

<p><strong>算法实现</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> slen = <span class="built_in">strlen</span>(s)， plen = <span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="keyword">while</span>(i &lt; slen &amp;&amp; j &lt; slen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || s[i] == s[j])&#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(j == plen)</span><br><span class="line">        <span class="keyword">return</span> i-j;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>求解 next 数组：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(<span class="type">char</span>* p, <span class="type">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> plen = <span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;plen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || p[i] == p[j])&#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>改进的 nextval 数组：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNextval</span><span class="params">(<span class="type">char</span>* p, <span class="type">int</span> nextval[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> plen = <span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; j = <span class="number">-1</span>;</span><br><span class="line">    nextval[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;plen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || p[i] == p[j])&#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">            <span class="keyword">if</span>( p[i] == p[j])&#123;</span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="5-数组和广义表"><a href="#5-数组和广义表" class="headerlink" title="5 数组和广义表"></a>5 数组和广义表</h1><h2 id="5-1-数组的定义"><a href="#5-1-数组的定义" class="headerlink" title="5.1 数组的定义"></a>5.1 数组的定义</h2><p>数组是一组偶对(下标值，数据元素值)的集合。在数组中，对于一组有意义的下标，都存在一个与其对应的值。一维数组对应着一个下标值，二维数组对应着两个下标值，如此类推。</p>
<p>抽象数据类型数组可形式地定义为：</p>
<p><code>ADT Array</code>：</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231025153910874.png" alt="image-20231025153910874" style="zoom:50%;">

<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">基本操作：</span><br><span class="line"><span class="built_in">InitArray</span>(&amp;A, n, bound1, ···, boundn);</span><br><span class="line">    操作结果：若维数 n 和各维长度合法,则构造相应的数组 A,并返回<span class="function">OK</span></span><br><span class="line"><span class="function"><span class="title">DestroyArray</span><span class="params">(&amp;A)</span></span>;</span><br><span class="line">	操作结果：销毁数组<span class="function">A</span></span><br><span class="line"><span class="function"><span class="title">Value</span><span class="params">(A, &amp;e, indexl, ···, indexn)</span></span>;</span><br><span class="line">	初始条件：A 是 n维数组, e 为元素变量, 随后是n个下标值</span><br><span class="line">	操作结果：若各下标不超界，则 e 赋值为所指定的A的元素值,并返回 <span class="function">OK</span></span><br><span class="line"><span class="function"><span class="title">Assign</span><span class="params">(&amp;A, e, index1, ···, indexn)</span></span>;</span><br><span class="line">	初始条件：A 是 n维数组, e 为元素变量, 随后是n个下标值</span><br><span class="line">	操作结果：若下标不超界，则将 e 赋值给所指定的A的元素,并返回 OK</span><br></pre></td></tr></table></figure></div>



<p>$n$ 维数组中含有 $\prod_{i &#x3D; 1}^n b_i$ 个数据元素，每个元素都受着 $n$ 个关系的约束。在每个关系中，元素 $a_{j_1j_2\cdots j_n}(0\leqslant j_i\leqslant b_i-2)$ 都有 一个直接后继元素。</p>
<ul>
<li><p>数组的所有数据元素都必须属于同一数据类型。</p>
</li>
<li><p>数组中每个数据元素都对应于一组下标$(j_1,j_2 ,\cdots, j_n)$ ，每个下标的取值范围是 $0\leqslant j_i \leqslant b_i-1$ ，$b_i$ 称为 第 $i$ 维的长度 $(i&#x3D;1,2,\cdots,n)$ 。显然，当 $n &#x3D; 1$ 时，$n$ 维数组就退化为定长的线性表。</p>
</li>
<li><p>数组是一种随机存取结构，给定一组下标，就可以访问与其对应的数据元素。</p>
</li>
<li><p>数组中的数据元素个数是固定的。</p>
</li>
</ul>
<p>我们可以把二维数组看成是这样一个定长线性表：它的每个数据元素也是一个定长的线性表。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231025162301118.png" alt="image-20231025162301118" style="zoom:50%;">

<p>数组一旦被定义，它的维数和维界就不再改变。<br>因此，除了 <strong>结构的初始化和销毁</strong> 之外，数组只有 <strong>存取元素</strong> 和 <strong>改变元素值</strong> 的操作。</p>
<p>a</p>
<h2 id="5-2-数组的顺序表示和实现"><a href="#5-2-数组的顺序表示和实现" class="headerlink" title="5.2 数组的顺序表示和实现"></a>5.2 数组的顺序表示和实现</h2><p>由于数组一般不作插入或删除操作，一旦建立了数组，则结构中的数据元素个数和元素之间的关系就不再发生变动。因此采用顺序存储结构表示数组。</p>
<p>由于存储单元是一维结构，而数组是个多维的结构，则用一组连续存储单元存放数组的数据元素就有个 <strong>次序约定</strong> 问题。即必须按某种次序将数组元素排成一列序列，然后将这个线性序列存放到内存中。</p>
<p>对二维数组可有两种存储方式：</p>
<ul>
<li><p>以列序为主序（<strong>列优先顺序</strong>）—— 将数组按列向量排列，第 $j+1$ 个列向量紧接在第 $j$ 个列向量之后，A 的 $m\times n$ 个元素按列优先顺序存储的线性序列为：</p>
<p>$a_{11}, a_{21}, …, a_{m1}, a_{12}, a_{22}, …, a_{m2}, …, a_{1n}, a_{2n},…, a_{mn}$  </p>
</li>
<li><p>以行序为主序（<strong>行优先顺序</strong>）—— 将数组元素按行排列，第 $i+1$ 个行向量紧接在第 $i$ 个行向量后面，以二维数组为例， 按行优先顺序存储的线性序列为：</p>
<p>$a_{11}, a_{12}, …, a_{1n}, a_{21}, a_{22}, …, a_{2n}, …, a_{m1}, a_{m2},…, a_{mn}$  </p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231025165229367.png" alt="image-20231025165229367" style="zoom:50%;"></li>
</ul>
<p>一旦规定了它的维数和各维的长度，便可为它分配空间。反之，只要给出一组下标便可求得相应数组元素的存储位置。</p>
<p>下面仅以行序为主序为例：</p>
<p>假设每个数据元素占据 L 个存储单元，则二维数组 A 中任一元素 $a_{ij}$ 的存储位置可由下式确定：<br>$$<br>\mathrm{LOC}(i,j) &#x3D; \mathrm{LOC}(0,0)+(b_2\times i+j)L<br>$$<br>式中，$\mathrm{LOC}(i,j)$ 是 $a_{ij}$ 的存储位置，$\mathrm{LOC}(0,0)$ 是 $a_{00}$ 的存储位置，即二维数组 A 的起始存储位置，也称为基地址或基址。</p>
<p>n 维数组的数据元素存储位置计算公式：<br>$$<br>\mathrm{LOC}(j_1,j_2,\cdots,j_n) &#x3D; \mathrm{LOC}(0,0,\cdots,0)+(b_2\times \cdots \times b_n \times j_1+b_3\times\cdots\times b_n\times j_2<br>\+ \cdots +b_n\times j_{n-1}+j_n)L\<br>&#x3D;\mathrm{LOC}(0,0,\cdots,0) + (\sum_{i &#x3D; 1}^{n-1}j_i \prod^n_{k &#x3D; i+1}b_k+j_n)L<br>$$<br>可缩写成：<br>$$<br>\mathrm{LOC}(j_1,j_2,\cdots,j_n) &#x3D; \mathrm{LOC}(0,0,\cdots,0)+\sum_{i &#x3D; 1}^{n}c_ij_i<br>$$<br>其中 $c <em>n &#x3D; L,c</em>{i-1} &#x3D; b_i\times c_i,1&lt;i\leqslant n$ </p>
<p>上面的公式称为 $n$ 维数组的映像函数。数组的存储位置是其下标的线性函数，一旦确定了数组的各维的长度，$c_i$ 就是常数。</p>
<ul>
<li><p>对于 $m\times n$ 的矩阵 A，元素下标 $[i,j](0\leqslant i \leqslant m, 0\leqslant j \leqslant n)$ ，则</p>
<ul>
<li><p>按 <strong>行优先顺序</strong> 存储：<br>$$<br>\mathrm{LOC}[i,j] &#x3D; \mathrm{LOC}[0,0]+(n\times i + j)L<br>$$</p>
</li>
<li><p>按 <strong>列优先顺序</strong> 存储：<br>$$<br>\mathrm{LOC}[i,j] &#x3D; \mathrm{LOC}[0,0]+(m \times j+i)L<br>$$</p>
</li>
</ul>
</li>
<li><p>实例：假设二维数组A的规模为$6\times8$，每个元素用相邻的6个字节存储，存储器按字节编址。已知A的起始存储位置（基地址）为1000，元素a00为起始，计算：</p>
<ul>
<li><p>数组 A 的体积（即存储量）</p>
<p>$6\times8\times6&#x3D;288$</p>
</li>
<li><p>数组 A 的最后一个元素 $a_{57}$ 的第一个字节的地址</p>
<p>$1000+288-6 &#x3D; 1282$ </p>
</li>
<li><p>按行存储时，元素 $a_{14}$ 的第一个字节的地址</p>
<p>$1000+(1\times 8+4)\times6&#x3D;1072$ </p>
</li>
<li><p>按列存储时，元素 $a_{47}$ 的第一个字节的地址</p>
<p>$1000+(7\times 6 + 4)\times6&#x3D;1276$</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-3-矩阵的压缩存储"><a href="#5-3-矩阵的压缩存储" class="headerlink" title="5.3 矩阵的压缩存储"></a>5.3 矩阵的压缩存储</h2><h3 id="5-3-1-特殊矩阵"><a href="#5-3-1-特殊矩阵" class="headerlink" title="5.3.1 特殊矩阵"></a>5.3.1 特殊矩阵</h3><p>若 $n$ 阶矩阵 A 中的元满足性质 $a_{ij} &#x3D; a_{ji}\ \ \  1\leqslant i,j \leqslant n$ ，则称为 $n$ 阶对称矩阵。</p>
<p>对于 对称矩阵，我们可以为每一对对称元分配一个存储空间，则可将 $n^2$ 个元压缩存储到 $n(n+1)&#x2F;2$ 个元的空间中。不失一般性，我们可以行序为主序存储其下三角（包括对角线）中的元。</p>
<p>假设以一维数组 $sa[n(n+1)&#x2F;20]$ 作为 $n$ 阶矩阵A 的存储结构，则 $sa[k]$ 和矩阵元 $a_{ij}$ 之间存在着一一对应的关系：<br>$$<br>k &#x3D; \begin{cases}<br>\cfrac{i(i-1)}{2}+j-1&amp;当\ i\geqslant j\<br>\cfrac{j(j-1)}{2}+i-1&amp;当\ i&lt; j<br>\end{cases}<br>$$<br>称 $sa[n(n+1)&#x2F;2]$ 为 $n$ 阶对称矩阵 A 的压缩存储。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231025190842964.png" alt="image-20231025190842964" style="zoom:50%;">

<p>这种压缩存储方法同样也适用于三角矩阵，上（下）三角矩阵。</p>
<p>对角矩阵，可以按照某个原则（或以行为主，或以对角线的顺序）将其压缩在一维数组上。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231026205946750.png" alt="image-20231026205946750" style="zoom:50%;">

<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231027150900012.png" class title="image-20231027150900012">



<h3 id="5-3-2-稀疏矩阵"><a href="#5-3-2-稀疏矩阵" class="headerlink" title="5.3.2 稀疏矩阵"></a>5.3.2 稀疏矩阵</h3><p>假设在 $m\times n$ 的矩阵中，由 $t$ 个元素不为零，令 $\delta &#x3D; \cfrac{t}{m\times n}$ ，称 $\delta$ 为矩阵的 <strong>稀疏因子</strong>。通常认为 $\delta \leqslant 0.05$ 时称为稀疏矩阵。</p>
<p>抽象数据类型 稀疏矩阵 的定义：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ADT SparseMatrix&#123;</span><br><span class="line">    数据对象：D = &#123;<span class="built_in">a</span>(i,j) | i = <span class="number">1</span>,<span class="number">2</span>,···,m; j = <span class="number">1</span>,<span class="number">2</span>,···,n;</span><br><span class="line">             			<span class="built_in">a</span>(i,j) ∈ ElemSet, m和n分别称为矩阵的行数和列数&#125;</span><br><span class="line">    数据关系：R = &#123;Row, Col&#125;</span><br><span class="line">    		Row = &#123;&lt;<span class="built_in">a</span>(i,j), <span class="built_in">a</span>(i,j+<span class="number">1</span>)&gt; | <span class="number">1</span>≤i≤m, <span class="number">1</span>≤j≤n<span class="number">-1</span>&#125;</span><br><span class="line">    		Col = &#123;&lt;<span class="built_in">a</span>(i,j), <span class="built_in">a</span>(i+<span class="number">1</span>,j)&gt; | <span class="number">1</span>≤i≤m<span class="number">-1</span>, <span class="number">1</span>≤j≤n&#125;</span><br><span class="line">    基本操作：</span><br><span class="line">        <span class="built_in">CreateSMatrix</span>(&amp;M);</span><br><span class="line">			操作结果：创建稀疏矩阵 <span class="function">M</span></span><br><span class="line"><span class="function">        <span class="title">DestroySMatrix</span><span class="params">(&amp;M)</span></span>;</span><br><span class="line">    		初始条件：稀疏矩阵M存在</span><br><span class="line">			操作结果：销毁稀疏矩阵 <span class="function">M</span></span><br><span class="line"><span class="function">        <span class="title">PrintSMatrix</span><span class="params">(M)</span></span>;</span><br><span class="line">    		初始条件：稀疏矩阵M存在</span><br><span class="line">			操作结果：输出稀疏矩阵<span class="function">M</span></span><br><span class="line"><span class="function">        <span class="title">CopySMatrix</span><span class="params">(M, &amp;T)</span></span>;</span><br><span class="line">    		初始条件：稀疏矩阵M存在</span><br><span class="line">			操作结果：由稀疏矩阵M赋值到<span class="function">T</span></span><br><span class="line"><span class="function">        <span class="title">AddSMatrix</span><span class="params">(M, N, &amp;Q)</span></span>;</span><br><span class="line">    		初始条件：稀疏矩阵M和N的行数和列数对应相等</span><br><span class="line">			操作结果：求稀疏矩阵的和 Q = M+N</span><br><span class="line">        <span class="built_in">MultSMatrix</span>(M, N, &amp;Q);</span><br><span class="line">    		初始条件：稀疏矩阵M的列数等于N的行数</span><br><span class="line">			操作结果：求稀疏矩阵的和 Q = M*N</span><br><span class="line">        <span class="built_in">TransposeSMatrix</span>(M, &amp;T);</span><br><span class="line">    		初始条件：稀疏矩阵M存在</span><br><span class="line">			操作结果：求稀疏矩阵M的转置矩阵T</span><br><span class="line">&#125;ADT SparseMatrix</span><br></pre></td></tr></table></figure></div>



<ol>
<li><strong>三元组顺序表</strong></li>
</ol>
<p>以顺序存储结构来表示三元组表，即可得到 稀疏矩阵 的一种压缩存储方式——三元组顺序表</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稀疏矩阵的三元组顺序表存储表示</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 12500   <span class="comment">// 假设非零元个数的最大值为 12500</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;        <span class="comment">// 该非零元的行下标和列下标</span></span><br><span class="line">    ElemType e;</span><br><span class="line">&#125;Triple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    Triple data[MAXSIZE+<span class="number">1</span>];  <span class="comment">// 非零元三元组</span></span><br><span class="line">    <span class="type">int</span> mu,nu,tu;</span><br><span class="line">&#125;TSMatrix;</span><br></pre></td></tr></table></figure></div>



<p>转置矩阵：对于一个 $m\times n$ 的矩阵M，它的转置矩阵 T 是 $n\times m$ 的矩阵，且 $T(i,j) &#x3D; M(j,i)$ 。<br>获得一个转置矩阵的方法：（ 1 ）将矩阵的行列值相互交换（ 2 ）将每个三元组中的 $i$ 和 $j$ 相互调换；（ 3 ）重排三元组之间的次序便可实现矩阵的转置。</p>
<p>对于重拍三元组之间的次序，有两种处理方法：（设有矩阵 B 是 矩阵A 的转置）</p>
<ul>
<li><p>按照 转置后矩阵 中三元组的次序依次在 原矩阵的三元组 中找到相应的三元组进行转置：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TransposeSMatrix</span><span class="params">(TSMatrix M, TSMatrix &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 采用三元组表存储表示，求稀疏矩阵M的转置矩阵T</span></span><br><span class="line">    T.mu = M.nu; T.nu = M.mu; T.tu = M.tu;</span><br><span class="line">    <span class="keyword">if</span>(T.tu)&#123;</span><br><span class="line">        q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(col = <span class="number">1</span>; col&lt;=M.nu; ++col)&#123;</span><br><span class="line">            <span class="keyword">for</span>(p = <span class="number">0</span>; p&lt;M.tu; ++p)&#123;</span><br><span class="line">                <span class="keyword">if</span>(M.data[p].j == col)&#123;</span><br><span class="line">                    T.data[q].i = M.data[p].j;</span><br><span class="line">                    T.data[q].j = M.data[p].i;</span><br><span class="line">                    T.data[q].e = T.data[p].e;</span><br><span class="line">                    ++q;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>时间复杂度：$O(mu\times nu)$ </p>
</li>
<li><p><strong>快速转置</strong>：按照 原矩阵 中三元组 a.data 的次序进行转置，并将转置后的三元组置入 转置矩阵 恰当的位置。应先求M的每一列非零元的个数，进而求得每一列的第一个非零元在 转置矩阵的三元组b.data 中应有的位置。那么在对 a.data 中的三元组依次作转置时，便可直接放到 b.data 中恰当位置上去。</p>
<p>需要设置 <code>num</code> 和 <code>cpot</code> 两个向量。<code>num[col]</code> 表示矩阵M中第 <code>col</code> 列中非零元的个数，<code>cpot[col]</code> 指示 M 中第 <code>col</code> 列的第一个非零元在 <code>b.data</code> 中的恰当位置。显然有<br>$$<br>\begin{cases}<br>\mathrm{cpot[1] &#x3D; 1;}\<br>\mathrm{cpot[col] &#x3D; cpot[col - 1] + num[col-1]}&amp; \mathrm{2\leqslant col \leqslant a.nu}<br>\end{cases}<br>$$<br>算法实现：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">FastTransposeSMatrix</span><span class="params">(TSMatrix M, TSMatrix &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 采用三元组顺序表存储表示，求稀疏矩阵M的转置矩阵T</span></span><br><span class="line">    T.mu = M.nu; T.nu = M.mu; T.tu = M.tu;</span><br><span class="line">    <span class="keyword">if</span>(T.tu)&#123;</span><br><span class="line">        <span class="keyword">for</span>(col = <span class="number">1</span>; col&lt;=M.nu; ++col) num[col] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 求M中每一列含非零元个数</span></span><br><span class="line">        <span class="keyword">for</span>(t = <span class="number">1</span>; t&lt;=M.tu; ++t) ++num[M.data[t].j];</span><br><span class="line">        cpot[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 求第col列中第一个非零元在 b.data 中的序号</span></span><br><span class="line">        <span class="keyword">for</span>(col = <span class="number">2</span>; col&lt;=M.nu; ++col) cpot[col] cpot[col<span class="number">-1</span>]+num[col<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(p = <span class="number">1</span>; p&lt;=M.tu; ++p)&#123;</span><br><span class="line">            col = M.data[p].j; q = cpot[col];</span><br><span class="line">            T.data[q].i = M.data[p].j;</span><br><span class="line">            T.data[q].j = M.data[p].i;</span><br><span class="line">            T.data[q].e = M.data[q].e;</span><br><span class="line">            ++cpot[col];</span><br><span class="line">        &#125;<span class="comment">// for</span></span><br><span class="line">    &#125;<span class="comment">//if</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>时间复杂度：$O(nu+tu)$</p>
</li>
</ul>
<ol start="2">
<li><strong>行逻辑链接的顺序表</strong></li>
</ol>
<p>为了方便随机存取任意一行的非零元，则需知道每一行的第一个非零元在三元组表的位置。为此，可将 快速转置矩阵算法中创建的，指示“行”信息的辅助数组 cpot 固定在稀疏矩阵的存储结构中。</p>
<p>这种 “带行链接信息” 的三元组表 为行逻辑链接的顺序表，其类型描述如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    Triple data[MAXSIZE+<span class="number">1</span>];  <span class="comment">// 非零元三元组表</span></span><br><span class="line">    <span class="type">int</span> rpos[MAXRC+<span class="number">1</span>];       <span class="comment">// 各行第一个非零元的位置表</span></span><br><span class="line">    <span class="type">int</span> mu,nu,tu;            <span class="comment">// 矩阵的行数、列数和非零元个数</span></span><br><span class="line">&#125;RLSMatrix;</span><br></pre></td></tr></table></figure></div>





<ol start="3">
<li><strong>十字链表</strong></li>
</ol>
<p>当矩阵的非零元个数和位置在操作过程中变化较大时，就不宜采用顺序存储结构来表示三元组的线性表。此时，采用 <strong>链式存储结构</strong> 表示三元组的线性表更为恰当。</p>
<p>在链表中</p>
<ul>
<li>每个非零元可用一个含 5 个域的结点表示，其中 i、j 和 e 这三个域分别表示该非零元所在的行、列和非零元的值。</li>
<li>向右域 right 用以 链接同一行中下一个非零元，向下域 down 用以链接同一列中下一个非零元。</li>
<li>同一行 的非零元 通过 right 域 链接成 一个线性链表，同一列 的非零元通过 down 域 链接成一个线性链表。</li>
<li>每一个非零元既是某个行链表中的一个结点，又是某个列链表中的一个结点，整个矩阵构成了一个十字交叉的链表。</li>
</ul>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稀疏矩阵的十字链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">OLNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;   <span class="comment">// 该非零元的行和列下标</span></span><br><span class="line">    ElemType e;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">OLNode</span> * right, * down;  <span class="comment">// 给非零元所在行表和列表的后继链域</span></span><br><span class="line">&#125;OLNode, *OLink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    OLink* rhead, chead;   <span class="comment">// 行和列链表头指针向量基址由 CreateSMatrix 分配</span></span><br><span class="line">    <span class="type">int</span> mu, nu, tu;        <span class="comment">// 稀疏矩阵的行数、列数和非零元个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h2 id="5-4-广义表的定义"><a href="#5-4-广义表的定义" class="headerlink" title="5.4 广义表的定义"></a>5.4 广义表的定义</h2><p>广义表，是线性表的推广。广义表一般记作：$LS &#x3D; (\alpha_1, \alpha_2, \cdots, \alpha_n)$ ，其中，LS 是广义表 $(\alpha_1, \alpha_2, \cdots, \alpha_n)$ 的名称，$n$ 是它的长度。</p>
<ul>
<li>在线性表的定义中，$a_i(1\leqslant i \leqslant n)$ 只限于单个元素。而在广义表的定义中，$\alpha_i$ 可以是 单个元素，也可以是广义表，分别称为 广义表 LS 的 <strong>原子</strong> 和 <strong>子表</strong>。<br>习惯上，用大写字母表示广义表的名称，用小写字母表示原子</li>
<li>当 广义表 LS 非空时，称第一个元素 $a_1$ 为 LS 的 <strong>表头</strong>（Head），称其余元素组成的表 $(\alpha_2, \alpha_3, \cdots, \alpha_n)$ 是 LS 的表尾（Tail）</li>
</ul>
<p><strong>广义表的例子</strong>：</p>
<ul>
<li>A &#x3D; () —— A是一个空表，它的长度为零</li>
<li>B &#x3D; (e) —— 列表 B 只有一个原子 e，B 的长度为 1</li>
<li>C &#x3D; (a, (b,c,d)) —— 列表 C 的长度为 2，两个元素分别为 原子 a 和 子表(b,c,d)</li>
<li>D &#x3D; (A,B,C) —— 列表 D 的长度为 3，3个元素都是列表</li>
<li>E &#x3D; (a, E) —— 这是一个递归的表，它的长度为 2。E 相当于一个无限的列表 E &#x3D; (a, (a,(a, ···)))</li>
</ul>
<p>广义表的重要定义：</p>
<ul>
<li>广义表的元素可以是原子，也可以是子表，子表的元素又可以是子表。即广义表是一个多层次的结构。</li>
<li>广义表可以被其他广义表所共享，也可以共享其他广义表。广义表共享其他广义表时通过表名引用。</li>
<li>广义表本身可以是一个递归表。</li>
<li>任何一个非空广义表的表头可以是原子，也可以是子表，而表尾必定是广义表。</li>
</ul>
<h2 id="5-5-广义表的存储结构"><a href="#5-5-广义表的存储结构" class="headerlink" title="5.5 广义表的存储结构"></a>5.5 广义表的存储结构</h2><p>通常采用 链式存储结构 表示广义表，每个数据元素可用一个结点表示。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广义表的头尾链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;ATOM, LIST&#125;ElemTag;  <span class="comment">// ATOM == 0:原子, LIST == 1:子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">GLNode</span>&#123;</span><br><span class="line">    ElemTag tag;             <span class="comment">// 公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="keyword">union</span>&#123;	                 <span class="comment">// 原子结点 和 表结点的联合部分</span></span><br><span class="line">        AtomType atom;       <span class="comment">// atom 是原子结点的值域，AtomType 由用户定义</span></span><br><span class="line">        <span class="keyword">struct</span>&#123;<span class="keyword">struct</span> <span class="title class_">GLNode</span> * hp, * tp;&#125;ptr;</span><br><span class="line">    &#125;;<span class="comment">// ptr 是表结点的指针域，ptr.hp 和 ptr.tp 分别指向表头和表尾</span></span><br><span class="line">&#125;*GList;  <span class="comment">// 广义表类型</span></span><br></pre></td></tr></table></figure></div>

<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231025210624589.png" alt="image-20231025210624589" style="zoom:50%;">

<p>对于上述存储结构，有如下几个特点： (1) 若广义表为空，表头指针为空；否则，表头指针总是指向一个表结点，其中hp指向广义表的表头结点(或为原子结点，或为表结点) ， tp指向广义表的表尾(表尾为空时，指针为空，否则必为表结点)。 (2) 这种结构求广义表的长度、深度、表头、表尾的操作十分方便。 (3) 表结点太多，造成空间浪费</p>
<h1 id="6-树和二叉树"><a href="#6-树和二叉树" class="headerlink" title="6 树和二叉树"></a>6 树和二叉树</h1><h2 id="6-1-树的定义和基本术语"><a href="#6-1-树的定义和基本术语" class="headerlink" title="6.1 树的定义和基本术语"></a>6.1 树的定义和基本术语</h2><p>树（Tree） 是 $n$（$n\geqslant 0$ ）个结点的有限集。在任意一棵非空树中：<br>（1）有且仅有一个特定的称为根（Root）的结点；<br>（2）当 $n&gt;1$ 时，其余结点可分为 $m(m&gt;0)$ 个互不相交的有限集 $T_1, T_2,…,T_m$ ，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231103143156350.png" alt="image-20231103143156350" style="zoom: 33%;">

<p>抽象数据类型树的定义：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">ADT Tree&#123;</span><br><span class="line">	数据对象 D: D 是具有相同特性的数据元素的集合</span><br><span class="line">	数据关系 R: 若 D 为空集, 则称为空树</span><br><span class="line">		若 D 仅含一个数据元素, 则 R 为空集, 否则 R = &#123;H&#125;, H 是如下二元关系:</span><br><span class="line">		(1) 在 D 中存在唯一的称为根的数据元素 root, 它在关系 H 下无前驱</span><br><span class="line">		(2) 若 D-&#123;root&#125; != ⌀, 则存在 D-&#123;root&#125; 的一个划分 D1,D2,...,Dm(m&gt;0),对任意 j!=k(1&lt;=j,k&lt;=m) 有 Dj ∩ Dk = ⌀, 且对任意的 i(1&lt;=i&lt;=m), 惟一存在数据元素 xi ∈ Di, 有 &lt;root, xi&gt; ∈ H;</span><br><span class="line">		(3) 对应于 D-&#123;root&#125; 的划分, H-&#123;&lt;root,x1&gt;,...,&lt;root, xm&gt;&#125; 有惟一的一个划分 H1,H2,...,Hm(m&gt;0), 对任意 j!=k(1&lt;=j,k&lt;=m) 有 Hj ∩ Hk = ⌀. 且对任意 i(1&lt;=i&lt;=m). Hi 是 Di 上的二元关系, (Di,&#123;Hi&#125;) 是一个符合本定义的树，称为根 root 的子树</span><br><span class="line">		基本操作 P:</span><br><span class="line">			InitTree(&amp;T);</span><br><span class="line">				操作结果: 构造空树 T</span><br><span class="line">			DestroyTree(&amp;T);</span><br><span class="line">				初始条件: 树 T 存在</span><br><span class="line">				操作结果: 销毁树 T</span><br><span class="line">            CreateTree(&amp;T, definition);</span><br><span class="line">            	初始条件: definition 给出树 T 的定义</span><br><span class="line">            	操作结果: 按 definition 构造树 T</span><br><span class="line">            ClearTree(&amp;T);</span><br><span class="line">            	初始条件: 树 T 存在</span><br><span class="line">            	操作结果: 将树 T 清为空树</span><br><span class="line">            TreeEmpty(T);</span><br><span class="line">            	初始条件: 树 T 存在</span><br><span class="line">            	操作结果: 若 T 为空树, 则返回 TRUE, 否则返回 FALSE</span><br><span class="line">            TreeDepth(T);</span><br><span class="line">            	初始条件: 树 T 存在</span><br><span class="line">            	操作结果: 返回树 T 的深度</span><br><span class="line">            Root(T);</span><br><span class="line">            	初始条件: 树 T 存在</span><br><span class="line">            	操作结果: 返回树 T 的根</span><br><span class="line">            Value(T, cur, e);</span><br><span class="line">            	初始条件: 树 T 存在, cur_e 是 T 中某个结点</span><br><span class="line">            	操作结果: 返回 cur_e 的值</span><br><span class="line">            Assign(T, cur_e, value);</span><br><span class="line">            	初始条件: 树 T 存在, cur_e 是 T 中某个结点</span><br><span class="line">            	操作结果: 结点 cur_e 赋值为 value</span><br><span class="line">            Parent(T, cur_e);</span><br><span class="line">            	初始条件: 树 T 存在, cur_e 是 T 中某个结点</span><br><span class="line">            	操作结果：若 cur_e 是 T 的非根节点，返回它的双亲,否则函数值为 空</span><br><span class="line">            LeftChild(T, cur_e);</span><br><span class="line">            	初始条件: 树 T 存在, cur_e 是 T 中某个结点</span><br><span class="line">            	操作结果：若 cur_e 是 T 的非叶子结点, 则返回它的最左孩子,否则返回 空</span><br><span class="line">            RightSibling(T, cur_e);</span><br><span class="line">            	初始条件: 树 T 存在, cur_e 是 T 中某个结点</span><br><span class="line">            	操作结果：若 cur_e 有右兄弟, 则返回它的右兄弟,否则函数值为 空</span><br><span class="line">            InsertChild(&amp;T, &amp;p, i, c);</span><br><span class="line">            	初始条件: 树 T 存在, cur_e 是 T 中某个结点, 1&lt;= i&lt;=p 所指结点的度+1, 非空树 c 与 T 不相交</span><br><span class="line">            	操作结果：插入 c 为 T 中 p 所指结点的第 i 棵子树</span><br><span class="line">            DeleteChild(&amp;T, &amp;p, i);</span><br><span class="line">            	初始条件: 树 T 存在, p 指向 T 中某个结点, 1&lt;=i&lt;=p 指向结点的度</span><br><span class="line">            	操作结果: 删除 T 中 p 所指向结点的第 i 棵子树</span><br><span class="line">            TraverseTree(T, Visit());</span><br><span class="line">            	初始条件: 树 T 存在, Visit 是对结点操作的应用函数</span><br><span class="line">            	操作结果: 按某种次序对 T 的每个结点调用函数 visit() 一次</span><br><span class="line">            			 一旦 visit() 失败, 则操作失败</span><br><span class="line">&#125; ADT Tree</span><br></pre></td></tr></table></figure></div>



<p><strong>树的结构定义是一个递归的定义</strong>，即在树的定义中又用到树的概念。</p>
<p>树结构的基本术语</p>
<ul>
<li><p>树的 <strong>结点</strong>：包含一个数据元素及若干指向其子树的分支</p>
</li>
<li><p>结点的 <strong>度</strong>：<u>结点拥有的子树数</u></p>
</li>
<li><p><strong>叶子</strong>（终端结点）：度为 0 的结点</p>
</li>
<li><p>除根节点以外的分支结点称为 内部结点</p>
</li>
<li><p><strong>树的 度</strong>：<u>树内各结点的度的最大值</u></p>
</li>
<li><p>结点的 <strong>孩子</strong>：结点子树的根</p>
<p>同时，该结点称为孩子的 <strong>双亲</strong></p>
<p>同一个双亲的孩子之间互称为 <strong>兄弟</strong></p>
<p>结点的 <strong>祖先</strong>：从根节点到该结点所经分支上的所有结点</p>
<p>结点的 <strong>子孙</strong>：以该结点为根的子树中的任一结点</p>
</li>
<li><p>结点的<strong>层次</strong>，从根开始定义起，<u>根为第一层</u>，根的孩子为第二层。若某结点在第 <code>l</code> 层，则其子树的根 就在 第 <code>l+1</code> 层。<br>其双亲在同一层的结点互称为 <strong>堂兄弟</strong>。</p>
</li>
<li><p><strong>深度</strong>（高度）：树中结点的最大层次。</p>
</li>
<li><p>如果将树中结点的各子树看成从左到右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。</p>
</li>
<li><p><strong>森林</strong> 是 $m(m\geqslant 0)$ 棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以森林和树互相递归定义来描述树。</p>
<p>就逻辑结构而言，任何一棵树是一个二元组 $Tree &#x3D; (root,F)$ ，其中：$root$ 是数据元素，称做树的根结点；$F$ 是 $m(m\geqslant 0)$ 棵树的森林，$F &#x3D; (T_1,T_2,\cdots,T_m)$ ，其中 $T_i &#x3D; (r_i, F_i)$ 称做根 $root$ 的第 $i$ 棵树；当 $m\not&#x3D;0$ 时，在树根和其子树森林之间存在下列关系：<br>$$<br>RF &#x3D; {&lt;root, r_i&gt; |\ i &#x3D; 1,2,\cdots,m, m&gt;0 }<br>$$</p>
</li>
</ul>
<h2 id="6-2-二叉树"><a href="#6-2-二叉树" class="headerlink" title="6.2 二叉树"></a>6.2 二叉树</h2><h3 id="6-2-1二叉树的定义"><a href="#6-2-1二叉树的定义" class="headerlink" title="6.2.1二叉树的定义"></a>6.2.1二叉树的定义</h3><p><strong>二叉树</strong> （Bianry Tree）是另一种树型结构，它的特点是每个结点至多只有两棵子树（即二叉树中不存在度大于 2 的结点），并且，二叉树的子树有左右之分，其次序不能任意颠倒。</p>
<p>抽象数据类型二叉树的定义如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">ADT BinaryTree:</span><br><span class="line">数据对象 D：D是具有相同特性的数据元素的集合</span><br><span class="line">数据关系 R: </span><br><span class="line">	若 D=⌀,则 R=⌀,称 BinaryTree 为空二叉树</span><br><span class="line">	若 D≠⌀,则 R=&#123;H&#125;,H是如下二元关系：</span><br><span class="line">		(1) 在 D 中存在惟一的成为根的数据元素 root,它在关系 H 下无前驱</span><br><span class="line">		(2) 若 D-&#123;root&#125;≠⌀,则存在 D-&#123;root&#125;=&#123;Dl,Dr&#125;, 且 Dl∩Dr=⌀</span><br><span class="line">		(3) 若 Dl≠⌀,则 Dl 中存在惟一的元素 xl,&lt;root,xl&gt;∈H,且存在 Dl 上的关系 Hl⊂H; 若 Dr≠⌀,则 Dr中存在惟一的元素 xr,&lt;root,xr&gt;∈H,且存在 Dr 上的关系 Hr⊂H; H=&#123;&lt;root,xl&gt;,&lt;root,xr&gt;, Hl,Hr&#125;;</span><br><span class="line">		(Dl,&#123;Hl&#125;)是一颗符合本定义的二叉树,称为根的左子树,(Dr,&#123;Hr&#125;) 是一颗符合本定义的二叉树,称为根的右子树</span><br><span class="line">		</span><br><span class="line">基本操作P:</span><br><span class="line">	InitBiTree(&amp;T);</span><br><span class="line">		操作结果：构造空二叉树T。</span><br><span class="line">    DestroyBiTree(&amp;T);</span><br><span class="line">    	初始条件：二叉树T存在。</span><br><span class="line">    	操作结果：销毁二叉树T。</span><br><span class="line">    CreateBiTree(&amp;T, definition);</span><br><span class="line">    	初始条件：definition给出二叉树T的定义。</span><br><span class="line">    	操作结果：按definition构造二叉树T。</span><br><span class="line">    ClearBiTree(&amp;T);</span><br><span class="line">    	初始条件：二叉树T存在。</span><br><span class="line">    	操作结果：将二叉树T清为空树。</span><br><span class="line">    BiTreeEmpty(T);</span><br><span class="line">    	初始条件：二叉树T存在。</span><br><span class="line">    	操作结果：若二叉树T为空二叉树,则返回TRUE,否则返回FALSE。</span><br><span class="line">    BiTreeDepth(T);</span><br><span class="line">    	初始条件：二叉树T存在。</span><br><span class="line">    	操作结果：返回二叉树T的深度。</span><br><span class="line">    Root(T);</span><br><span class="line">    	初始条件：二叉树T存在。</span><br><span class="line">    	操作结果：返回二叉树T的根。</span><br><span class="line">    Value(T, e);</span><br><span class="line">    	初始条件：二叉树T存在,e是T中某个结点。</span><br><span class="line">    	操作结果：返回e的值。</span><br><span class="line">    Assign(T, &amp;e, value);</span><br><span class="line">    	初始条件：二叉树T存在,e是T中某个结点。</span><br><span class="line">    	操作结果：将结点e赋值为value。</span><br><span class="line">    Parent(T, e);</span><br><span class="line">    	初始条件：二叉树T存在,e 是 T 中某个结点。</span><br><span class="line">    	操作结果：若 e 是 T 的非根节点,则返回它的双亲,否则返回“空”。</span><br><span class="line">    LeftChild(T, e);</span><br><span class="line">    	初始条件：二叉树T存在,e 是 T 中某个结点。</span><br><span class="line">    	操作结果：返回 e 的左孩子。若 e 无左孩子,则返回“空”。</span><br><span class="line">    RightChild(T, e);</span><br><span class="line">    	初始条件：二叉树T存在,e 是 T 中某个结点。</span><br><span class="line">    	操作结果：返回 e 的右孩子。若 e 无右孩子,则返回“空”。</span><br><span class="line">    LeftSibling(T, e);</span><br><span class="line">    	初始条件：二叉树T存在,e 是 T 中某个结点。</span><br><span class="line">    	操作结果：返回 e 的左兄弟。若 e 是 T 的左孩子或无左兄弟,则返回“空”。</span><br><span class="line">    RightSibling(T, e);</span><br><span class="line">    	初始条件：二叉树T存在,e 是 T 中某个结点。</span><br><span class="line">    	操作结果：返回 e 的右兄弟。若 e 是 T 的右孩子或无右兄弟,则返回“空”。</span><br><span class="line">    InsertChild(T, p, LR, c);</span><br><span class="line">    	初始条件：二叉树 T 存在,p指向T中某个结点,LR 为 0 或 1,非空二叉树c与T不相交且右子树为空。</span><br><span class="line">    	操作结果：根据 LR 为0或1,插入 c 为 T 中 p 所指结点的左或右子树。p 所指结点的原有左或右子树则成为 c 的右子树。</span><br><span class="line">    DeleteChild(T, p, LR);</span><br><span class="line">    	初始条件：二叉树T存在,p 指向T某个结点,LR为0或1。</span><br><span class="line">    	操作结果：根据 LR 为 0 或 1,删除 T 中p所指向结点的左或右子树。</span><br><span class="line">    PreOrderTraverse(T, Visit());</span><br><span class="line">    	初始条件: 二叉树T存在,Visit是对结点操作的应用函数。</span><br><span class="line">    	操作结果：先序遍历T,对每个结点调用函数Visit一次且仅一次。一旦visit()失败,则操作失败。</span><br><span class="line">    InOrderTraverse(T, Visit());</span><br><span class="line">    	初始条件: 二叉树T存在,Visit是对结点操作的应用函数。</span><br><span class="line">    	操作结果：中序遍历T,对每个结点调用函数Visit一次且仅一次。一旦visit()失败,则操作失败。</span><br><span class="line">    PostOrderTraverse(T, Visit());</span><br><span class="line">    	初始条件: 二叉树T存在,Visit是对结点操作的应用函数。</span><br><span class="line">    	操作结果：后序遍历T,对每个结点调用函数Visit一次且仅一次。一旦visit()失败,则操作失败。</span><br><span class="line">    LevelOrderTraverse(T, Visit());</span><br><span class="line">    	初始条件: 二叉树T存在,Visit是对结点操作的应用函数。</span><br><span class="line">    	操作结果：层序遍历T,对每个结点调用函数Visit一次且仅一次。一旦visit()失败,则操作失败。</span><br><span class="line">&#125;ADT BinaryTree</span><br></pre></td></tr></table></figure></div>

<p>上述数据结构的递归定义表明二叉树或为空，或是由一个根结点加上两棵分别成为左子树和右子树的、互不相交的的二叉树组成。二叉树有5个基本形态。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231204000733780.png" alt="image-20231204000733780" style="zoom:50%;">



<h3 id="6-2-2-二叉树的性质"><a href="#6-2-2-二叉树的性质" class="headerlink" title="6.2.2 二叉树的性质"></a>6.2.2 二叉树的性质</h3><img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231204002918691.png" alt="image-20231204002918691" style="zoom: 33%;">

<p><strong>性质1</strong> 在二叉树的第 i 层上至多有 $2^{i-1}$ 个结点（$i\geqslant 1$）。</p>
<p><strong>性质2</strong> 深度为 k 的二叉树至多有 $2^{k}-1$ 个结点，（$k\geqslant 1$）。</p>
<p><strong>性质3</strong> 对任何一棵二叉树 $T$ ，如果其终端结点数为 $n_0$ ，度为 2 的结点数为 $n_2$ ，则 $n_0 &#x3D; n_2+1$ 。</p>
<p><strong>性质4</strong> 具有 $n$ 个结点的完全二叉树的深度 $⌊\mathrm{log}_2n⌋+1$ 。</p>
<p><strong>性质5</strong> 如果对一棵有 n 个结点的完全二叉树（其深度为 $⌊\mathrm{log}_2n⌋+1$）的结点按层序编号（从第 1 层到第 $⌊\mathrm{log}_2n⌋+1$ 层，每层从左到右），则对任一结点 $i(1\leqslant i \leqslant n)$ ，有</p>
<p>​	（1）如果 $i &#x3D; 1$ ，则结点 $i$ 是二叉树的根，无双亲；如果 $i&gt;1$，则其双亲 $\mathrm{PARENT}(i)$ 是结点 $⌊i&#x2F;2⌋$ 。</p>
<p>​	（2）如果 $2i&gt;n$，则结点 $i$ 无左孩子（结点 $i$ 为叶子结点）；否则其左孩子 $\mathrm{LCHILD}(i)$ 是结点 $2i$ 。</p>
<p>​	（3）如果 $2i+1&gt;n$，则结点 $i$ 无右孩子；否则其有孩子 $\mathrm{RCHILD}(i)$ 是结点 $2i+1$ 。</p>
<h3 id="6-2-3二叉树的存储结构"><a href="#6-2-3二叉树的存储结构" class="headerlink" title="6.2.3二叉树的存储结构"></a>6.2.3二叉树的存储结构</h3><ol>
<li><p>顺序存储结构</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----- 二叉树的顺序存储表示 -----</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100                     <span class="comment">// 二叉树的最大结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE];    <span class="comment">// 0 号单元存储根结点</span></span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure></div>

<p>用一组地址连续的存储单元依次 自上而下、自左至右 存储完全二叉树上的结点元素，即将完全二叉树 上编号为 $i$ 的结点存储在如上定义的一维数组中下标为 $i-1$ 的分量中。顺序存储结构仅适用于完全二叉树。</p>
</li>
<li><p>链式存储结构</p>
<p>表示二叉树的链表中的结点至少包含 3 个域：数据域 和 左、右指针域。有时为了方便查找双音，则还可在结点结构中增加一个指向其双亲结点的指针域。利用这两种结点结构所得二叉树的存储结构分别称之为二叉链表和三叉链表。</p>
<p>链表的头结点指向二叉树的根结点。在含有 $n$ 个结点的二叉链表中有 $n+1$ 个空链域。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----- 二叉树的二叉链表存储表示 -----</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTnode</span>* lchild, *rchild;   <span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"><span class="comment">//----- 基本操作的函数原型说明 -----</span></span><br><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span></span>;  </span><br><span class="line">	<span class="comment">// 先序顺序输入二叉树中结点的值(一个字符)，空格字符表示空树</span></span><br><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(BiTree T, Status(*Visit)(TElemType e))</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T, Status(*Visit)(TElemType e))</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(BiTree T, Status(*Visit)(TElemType e))</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">LevelOrderTraverse</span><span class="params">(BiTree T, Status(*Visit)(TElemType e))</span></span>;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204121811909.png" class title="image-20231204121811909">



<h2 id="6-3-遍历二叉树和线性二叉树"><a href="#6-3-遍历二叉树和线性二叉树" class="headerlink" title="6.3 遍历二叉树和线性二叉树"></a>6.3 遍历二叉树和线性二叉树</h2><h3 id="6-3-1-遍历二叉树"><a href="#6-3-1-遍历二叉树" class="headerlink" title="6.3.1 遍历二叉树"></a>6.3.1 遍历二叉树</h3><p><strong>遍历二叉树</strong>（traversing binary tree），按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。</p>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>若二叉树为空，则空操作，否则</p>
<ol>
<li>访问根节点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ol>
<p>先序遍历算法描述：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(BiTree T, Status(* Visit)(TElemType e))</span></span>&#123;</span><br><span class="line">    <span class="comment">// 采用二叉链表存储结构, Visit 是对数据元素操作的应用函数</span></span><br><span class="line">    <span class="comment">// 先序遍历二叉树 T 的递归算法，对每个数据元素调用函数 Visit 是对数据元素操作的应用函数</span></span><br><span class="line">    <span class="comment">// 最简单的 Visit 函数是：</span></span><br><span class="line">    <span class="comment">// 		Status PrintElement(TElemType e)&#123;</span></span><br><span class="line">    <span class="comment">//			printf(e);</span></span><br><span class="line">    <span class="comment">//			return OK;</span></span><br><span class="line">	<span class="comment">//		&#125;</span></span><br><span class="line">    <span class="comment">// 调用实例：PreOrderTraverse(T, PrintElement);</span></span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Visit</span>(T-&gt;data))</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">PreOderTraverse</span>(T-&gt;lchild.Visit))</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">PreOrderTraverse</span>(T-&gt;rchild.Visit))	<span class="keyword">return</span> OK;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// PreOrderTraverse</span></span><br></pre></td></tr></table></figure></div>

<p>可类似地实现中序遍历和后序遍历的递归算法</p>
<p>可运行的递归代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">traversal</span>(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node, vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">    <span class="built_in">traversal</span>(node-&gt;left,res);</span><br><span class="line">    <span class="built_in">traversal</span>(node-&gt;right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>先序遍历</p>
<p>非递归代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    stk.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* node = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) stk.<span class="built_in">emplace</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) stk.<span class="built_in">emplace</span>(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>若二叉树为空，则空操作，否则</p>
<ol>
<li>中序遍历左子树</li>
<li>访问根节点</li>
<li>中序遍历右子树</li>
</ol>
<p>递归代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">Traversal</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Traversal</span><span class="params">(TreeNode* node, vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Traversal</span>(node-&gt;left, res);</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">Traversal</span>(node-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>



<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>若二叉树为空，则空操作，否则</p>
<ol>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根结点</li>
</ol>
<p>递归代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">Traversal</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Traversal</span><span class="params">(TreeNode* node, vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Traversal</span>(node-&gt;left, res);</span><br><span class="line">        <span class="built_in">Traversal</span>(node-&gt;right, res);</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>



<h4 id="遍历的非递归算法"><a href="#遍历的非递归算法" class="headerlink" title="遍历的非递归算法"></a>遍历的非递归算法</h4><p>如图所示的二叉树表示表达式：a+b*(c-d)-e&#x2F;f</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231204134424785.png" alt="image-20231204134424785" style="zoom: 33%;">

<p>若先序遍历此二叉树，按访问结点的先后次序将结点排列起来，可得到二叉树的先序序列为：-+a*b-cd&#x2F;ef</p>
<p>类似地，中序遍历此二叉树，可得到此二叉树的中序序列：a+b*c-d-e&#x2F;f</p>
<p>后序遍历此二叉树，可得到此二叉树的后序序列：abcd-*+ef&#x2F;-</p>
<p>从表达式来看，以上 3 个序列恰好为表达式的前缀表示（波兰式）、中缀表示和后缀表示（逆波兰式）</p>
<p>由以上二叉树遍历的定义可知，3种遍历算法之不同处仅在于访问根结点和遍历左、右子树的先后关系。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231204141023744.png" alt="image-20231204141023744" style="zoom: 50%;">

<p>仿照递归算法执行过程中<strong>递归工作栈</strong>的状态变化状况可直接写出相应的非递归算法。</p>
<p>例如，从中序遍历递归算法执行过程中递归工作栈的状态可见：<br>（1）工作记录中包含两项，其一是递归调用的语句编号，其二是指向根结点的指针，则当栈顶记录中的指针非空时，则应遍历左子树，即指向树根的指针进栈；<br>（2）若栈顶记录中的指针值为空，则应退至上一层，若是从左子树返回，则应访问当前层即栈顶记录中指针所指的根结点<br>（3）若是从右子树返回，则表明当前层的遍历结束，应继续退栈。这意味着，遍历右子树时，不需要保留当前层的根指针，可直接修改栈顶记录中的指针即可。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T, Status(*Visit)(TElemType e))</span></span>&#123;</span><br><span class="line">    <span class="comment">// 采用二叉链表存储结构, Visit 是对数据元素操作的应用函数</span></span><br><span class="line">    <span class="comment">// 中序遍历二叉树 T 的非递归算法, 对每个数据元素调用函数 Visit</span></span><br><span class="line">    <span class="built_in">InitStack</span>(S); <span class="built_in">Push</span>(S, T);    <span class="comment">// 根指针进栈</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(S))&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">GetTop</span>(S, p) &amp;&amp; p)  <span class="built_in">Push</span>(S, p-&gt;lchild);  <span class="comment">// 向左走到尽头</span></span><br><span class="line">        <span class="built_in">Pop</span>(S, p);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">StackEmpty</span>(S))&#123;</span><br><span class="line">            <span class="built_in">Pop</span>(S, p); <span class="keyword">if</span>(!<span class="built_in">Visit</span>(p-&gt;data)) <span class="keyword">return</span> ERROR;</span><br><span class="line">            <span class="built_in">Push</span>(S, p-&gt;rchild);</span><br><span class="line">        &#125; <span class="comment">// if</span></span><br><span class="line">    &#125; <span class="comment">// while</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// InOrderTraverse</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T, Status(*Visit)(TElemType e))</span></span>&#123;</span><br><span class="line">    <span class="comment">// 采用二叉链表存储结构, Visit 是对数据元素操作的应用函数</span></span><br><span class="line">    <span class="comment">// 中序遍历二叉树 T 的非递归算法, 对每个数据元素调用函数 Visit</span></span><br><span class="line">    <span class="built_in">InitStack</span>(S);  p = T;</span><br><span class="line">    <span class="keyword">while</span>(p || !<span class="built_in">StackEmpty</span>(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p) &#123;	<span class="comment">// 根指针进栈，遍历左子树</span></span><br><span class="line">            <span class="built_in">Push</span>(S, p); </span><br><span class="line">            p = p-&gt;lchild; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">Pop</span>(S, p);  </span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">Visit</span>(p-&gt;data)) <span class="keyword">return</span> ERROR;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125; <span class="comment">// else</span></span><br><span class="line">    &#125; <span class="comment">// while</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// InOrderTraverse</span></span><br></pre></td></tr></table></figure></div>



<p><strong>先序遍历的非递归算法</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder2</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S); BiTree p = T;	<span class="comment">// 初始化栈S; p是遍历指针 </span></span><br><span class="line">    <span class="keyword">while</span>(p || !<span class="built_in">IsEmpty</span>(S))&#123;	<span class="comment">// 栈不空或p不空时循环</span></span><br><span class="line">        <span class="keyword">if</span>(p)&#123;					<span class="comment">// 一路向左</span></span><br><span class="line">            <span class="built_in">Visit</span>(p);			<span class="comment">// 访问当前节点</span></span><br><span class="line">            <span class="built_in">Push</span>(S,p);			<span class="comment">// 入栈</span></span><br><span class="line">            p = p-&gt;lchild;		<span class="comment">// 左孩子不空，则一直向左走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;					<span class="comment">// 出栈,并转向栈节点的右子树</span></span><br><span class="line">            <span class="built_in">Pop</span>(S,p);			<span class="comment">// 栈顶元素出栈</span></span><br><span class="line">            p = p-&gt;rchild;	<span class="comment">// 向右子树走，p赋值为当前结点的右孩子</span></span><br><span class="line">        &#125;					<span class="comment">// 返回while循环继续进入if-else语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>后序遍历的非递归算法</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    p = T;</span><br><span class="line">    r = <span class="literal">NULL</span>;	<span class="comment">// 辅助指针，指向最近访问过的结点</span></span><br><span class="line">    <span class="keyword">while</span>(p || !<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p)	<span class="comment">// 走到最左边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Push</span>(S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">// 向右</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">GetTop</span>(S, p);	<span class="comment">// 读栈顶结点（非出栈）</span></span><br><span class="line">            <span class="comment">// 若右子树存在，且未被访问过</span></span><br><span class="line">            <span class="comment">// 转向右子树</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild &amp;&amp; p-&gt;rchild != r)</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            <span class="keyword">else</span> 	<span class="comment">// 否则弹出结点，并访问</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Pop</span>(S,p);		<span class="comment">// 将结点弹出</span></span><br><span class="line">                <span class="built_in">Visit</span>(p-&gt;data);	<span class="comment">// 访问该结点</span></span><br><span class="line">                r = p;			<span class="comment">// 记录最近访问过的结点</span></span><br><span class="line">                p = <span class="literal">NULL</span>;		<span class="comment">// 结点访问完后，重置p指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><u>每次出栈访问完一个结点就相当于 遍历完以该结点为根的子树，需将 p 置 NULL。</u></p>
<p>“遍历” 是二叉树各种操作的基础，可以在遍历过程中对结点进行各种操作，如：对于一棵已知树可求结点的双亲，求结点的孩子结点，判定结点所在层次等，反之，也可在遍历过程中生成结点，建立二叉树的存储结构。</p>
<p>按下列次序顺序读入字符：<code>A B C ⌀ ⌀ D E ⌀ G ⌀ ⌀ F ⌀ ⌀ ⌀</code>，（其中 <code>⌀</code> 表示空格字符）可建立相应的二叉链表。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 按先序次序输入二叉树中结点的值（一个字符），空格字符表示空树</span></span><br><span class="line">    <span class="comment">// 构造二叉链表表示的二叉树 T</span></span><br><span class="line">    <span class="built_in">scanf</span>(&amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27; &#x27;</span>) T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(T = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode)))) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        T-&gt;data = ch;				<span class="comment">// 生成根结点</span></span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;lchild);	<span class="comment">// 构造左子树</span></span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;rchild);	<span class="comment">// 构造右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// CreateBiTree</span></span><br></pre></td></tr></table></figure></div>



<p>遍历二叉树的算法，无论按哪种次序进行遍历，对含 $n$ 个结点的二叉树，其时间复杂度均为 $O(n)$。</p>
<p>所需的空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为 $n$ ，则空间复杂度也为 $O(n)$。</p>
<p>先序&#x2F;后序&#x2F;中序 遍历的非递归算法的通用代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">//将该节点弹出避免重复操作，下面再将左中节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">//添加右节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(node);</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">//中节点访问过，但是还没有进行处理，加入空节点作为标记</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.<span class="built_in">top</span>(); <span class="comment">//重新取出栈中元素</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);<span class="comment">//加入结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>





<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);					<span class="comment">// 初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,T);					<span class="comment">// 将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(Q))&#123;				<span class="comment">// 队列不空则循环</span></span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,p);				<span class="comment">// 队头结点出队</span></span><br><span class="line">        <span class="built_in">visit</span>(p);					<span class="comment">// 访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)		</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;lchild);<span class="comment">// 左子树不空，则左子树根节点入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;rchild);<span class="comment">// 右子树不空，则右子树根结点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">    que.<span class="built_in">emplace</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            v.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">emplace</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">emplace</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h3 id="6-3-2-线索二叉树"><a href="#6-3-2-线索二叉树" class="headerlink" title="6.3.2 线索二叉树"></a>6.3.2 线索二叉树</h3><p>试作如下规定：若结点有左子树，则其 lchild 域指示其左孩子，否则令 lchild 域指示其前驱；若结点有右子树，则令其 rchild 域指示其右孩子，否则令 rchild 域指示其后继。所以需要增加两个标志域：</p>
<table>
<thead>
<tr>
<th>lchild</th>
<th>LTag</th>
<th>data</th>
<th>RTag</th>
<th>rchild</th>
</tr>
</thead>
</table>
<p>其中：<br>$$<br>\mathrm{LTag} &#x3D; \begin{cases}<br>0&amp;\mathrm{lchild} 域指示结点的左孩子\<br>1&amp;\mathrm{lchild} 域指示结点的前驱<br>\end{cases}\<br>\mathrm{RTag} &#x3D; \begin{cases}<br>0&amp;\mathrm{rchild} 域指示结点的右孩子\<br>1&amp;\mathrm{rchild} 域指示结点的后继<br>\end{cases}<br>$$<br>以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做<strong>线索链表</strong>。其中指向结点前驱和后继的指针，叫做<strong>线索</strong>。加上线索的二叉树称之为 <strong>线索二叉树</strong>（Threaded Binary Tree）。</p>
<p>例如，下图(a)为中序线索二叉树，与其对应的中序线索链表如图(b)所示。其中实线为指针（指示左、右子树），虚线为线索（指向前驱和后继）。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231204150913950.png" alt="image-20231204150913950" style="zoom:50%;">

<p><strong>线索化</strong>：对二叉树以某种次序遍历使其变为线索二叉树的过程。</p>
<p>在线索树上进行遍历，只要先找到序列中的第一个结点，然后依次找结点后继直至其后继为空时而止。</p>
<p>如何在搜索树中找结点的后继？以上图的中序搜索树为例来看，树中所有叶子结点的右链是线索，则右链域直接指示了结点的后继，如结点 <code>b</code> 的后继为结点 <code>*</code>。树中所有非终端结点的右链均为指针，则由此无法得到后继的信息。</p>
<p>然而，根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右子树中最左下的结点。例如在<strong>找结点</strong> <code>*</code> <strong>的后继</strong>时，<u>首先沿右指针找到其右子树的根结点</u> <code>-</code> ，然后<u>顺其左指针往下直至其左标志为1的结点</u>，记为 <code>*</code> 的后继，在图中是结点 <code>c</code> 。</p>
<p>反之，在<strong>中序搜索树中找结点前驱</strong>的规律是：若其左标志为 1，则左链为线索，指示其前驱，否则遍历左子树时最后访问的一个结点（左子树中最右下的结点）为其前驱。</p>
<p>在后序搜索树中找结点后继可分为3种情况：<br>（1）若结点 x 是二叉树的根，则其后继为空<br>（2）若结点 x 是其双亲的右孩子或是双亲的左孩子且其双亲没有右子树，则其后继即为双亲结点<br>（3）若结点 x 是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后序遍历列出的第一个结点</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231204183115402.png" alt="image-20231204183115402" style="zoom:33%;">

<p>在中序线索二叉树上遍历二叉树，虽然时间复杂度亦为 $O(n)$ ，但常数因子要比之前讨论的算法小，且不需要设栈。因此，若在某程序中所用二叉树需经常遍历或查找结点在遍历所得线性序列中的前驱和后继，则应采用线索链表存储结构。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----- 二叉树的二叉线索存储表示 -----</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">PointerTag</span> &#123;Link, Thread&#125;; </span><br><span class="line"><span class="comment">// Link == 0:指针，Thread == 1: 线索</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiThrNode</span>&#123;</span><br><span class="line">    TElemType 			data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiThrNode</span> 	* lchild, * rchild;  <span class="comment">// 左右孩子</span></span><br><span class="line">    PointerTag 			LTag, RTag;  		<span class="comment">// 左右标志</span></span><br><span class="line">&#125;BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure></div>



<p>为了方便起见，仿照线性表的存储结构，在二叉树的线性链表上也添加一个头结点，并令其 lchild 域的指针指向二叉树的根结点，其 rchild 域的指针指向中序遍历时访问的最后一个结点。令二叉树中序序列中的第一个结点的 lchild 域指针和最后一个结点 rchild 域的指针均指向头结点。<br>类似为二叉树建立了一个双向线性链表，既可从第一个结点起顺后继进行遍历，也可从最后一个结点起顺前驱进行遍历。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T, Status(*Visit)(TElemType e))</span></span>&#123;</span><br><span class="line">    <span class="comment">// T 指向头结点，头结点的左链 lchild 指向根结点</span></span><br><span class="line">    <span class="comment">// 中序遍历二叉线索树 T 的非递归算法，对每个数据元素调用函数 Visit</span></span><br><span class="line">    p = T-&gt;lchild;   <span class="comment">// p 指向根结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=T)&#123;     <span class="comment">// 空树或遍历结束时，p==T</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;LTag == Link) p = p-&gt;lchild;   <span class="comment">// p-&gt;lchild 存储的是左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">Visit</span>(p-&gt;data)) <span class="keyword">return</span> ERROR;  		<span class="comment">// 访问其左子树为空的结点</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != T)&#123;</span><br><span class="line">            p = p-&gt;rchild; <span class="built_in">Visit</span>(p-&gt;data); 		<span class="comment">// 访问后继结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// InOrderTraverse_Thr</span></span><br></pre></td></tr></table></figure></div>



<p>线索化的实质：将二叉链表中的空指针改为指向前驱或后继的线索，而前驱或后继的信息只有在遍历时才能得到，因为线索化过程即为在遍历的过程中修改空指针的过程。</p>
<p>为了记下遍历过程中访问节点的先后关系，附设一个指针 pre 始终指向刚刚访问过的结点，若指针 p 指向当前访问的结点，则 pre 指向它的前驱。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderThreading</span><span class="params">(BiThrTree &amp; Thrt, BiThrThree T)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 中序遍历二叉树 T，并将其中序线索化，Thrt 指向头结点</span></span><br><span class="line">    <span class="keyword">if</span>(!(Thrt = (BiThrTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiThrNode)))) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Thrt-&gt;LTag = Link; 	Thrt-&gt;RTag = Tread;			<span class="comment">// 建立头结点</span></span><br><span class="line">    Thrt-&gt;rchild = Thrt;							<span class="comment">// 右指针回指</span></span><br><span class="line">    <span class="keyword">if</span>(!T) Thrt-&gt;lchild = Thrt;						<span class="comment">// 若二叉树空, 则左指针回指</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Thrt-&gt;lchild = T;	pre = Thrt;</span><br><span class="line">        <span class="built_in">InThreading</span>(T);								<span class="comment">// 中序遍历进行中序线索化</span></span><br><span class="line">        pre-&gt;rchild = Thrt;	pre-&gt;RTag= Tread;		<span class="comment">// 最后一个结点线索化</span></span><br><span class="line">        Thrt-&gt;rchild = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// InOrderThreading</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        <span class="built_in">InThreading</span>(p-&gt;lchild);  <span class="comment">// 左子树线索化</span></span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;lchild) &#123;p-&gt;LTag = Thread;	p-&gt;lchild = pre; &#125;	<span class="comment">// 前驱线索</span></span><br><span class="line">        <span class="keyword">if</span>(!pre-&gt;rchild) &#123;pre-&gt;RTag = Thread; pre-&gt;rchild = p; &#125; <span class="comment">// 后继线索</span></span><br><span class="line">        pre = p;	<span class="comment">// 保持 pre 指向 p 的前驱</span></span><br><span class="line">        <span class="built_in">InThreading</span>(p-&gt;rchild);  <span class="comment">// 右子树线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// InThreading</span></span><br></pre></td></tr></table></figure></div>



<p><strong>线索树的示例</strong>：</p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204190227265.png" class title="image-20231204190227265">

<p><strong>例题</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204190411494.png" class title="image-20231204190411494">

<p><strong>答案</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="./数据结构/b9fe69db719078c7006664369b19e856.jpg" alt="b9fe69db719078c7006664369b19e856" style="zoom:10%;"> <img lazyload src="/images/loading.svg" data-src="./数据结构/df406fce44167347b7ce3a897992150a.jpg" alt="df406fce44167347b7ce3a897992150a" style="zoom:10%;"> <img lazyload src="/images/loading.svg" data-src="./数据结构/80d5b8ee64b399d63435062e71e63bda.jpg" alt="80d5b8ee64b399d63435062e71e63bda" style="zoom:10%;"></p>
<h2 id="6-4-树和森林"><a href="#6-4-树和森林" class="headerlink" title="6.4 树和森林"></a>6.4 树和森林</h2><h3 id="6-4-1-树的存储结构"><a href="#6-4-1-树的存储结构" class="headerlink" title="6.4.1 树的存储结构"></a>6.4.1 树的存储结构</h3><ol>
<li><p>双亲表示法</p>
<p>假设以一组连续空间存储树的结点，同时在每个结点中附设一个指示器指示其双亲结点在链表中的位置，其形式说明如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----- 树的双亲表存储表示 -----</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PTNode</span>&#123;   <span class="comment">// 结点结构</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="type">int</span>       parent;    <span class="comment">// 双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;          <span class="comment">// 树结构</span></span><br><span class="line">    PTNode node[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span>    r, n;         <span class="comment">// 根的位置和结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure></div>

<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231204195339788.png" alt="image-20231204195339788" style="zoom:25%;">

<p>这种结构充分利用了每个结点（除根以外）只有惟一的双亲的性质。PARENT(T,x) 操作可以在常量时间内实现。反复调用 PARENT 操作，直到遇见无双亲的结点时，便找到了树的根，这就是 ROOT(x) 操作的执行过程。但是，在这种表示法中，求结点的孩子时需要遍历整个结构。</p>
</li>
<li><p>孩子表示法</p>
<p>由于树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，此时链表中的结点可以有如下两种结点格式：</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231204195533018.png" alt="image-20231204195533018" style="zoom: 50%;">

<p>第一种结点格式，多重链表中的结点是同构的，其中 d 为树的度。由于树中很多结点的度小于 d，所以链表中有很多空链域，空间较浪费。若采用第二个结点格式，多重链表的结点不同构，操作不方便。</p>
<p>另一种方法就是：把每个结点的孩子结点排列起来，看成一个线性表，且以链表作存储结构，则 n 个结点有 n 个孩子链表（叶子的孩子链表为空表）。而 n 个头指针又组成一个线性表，为了方便查找，可采用顺序存储结构。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----- 树的孩子链表存储表示 -----</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CTNode</span>&#123;   	<span class="comment">// 孩子结点</span></span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CTNode</span>* next;</span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr firstchild;  	<span class="comment">// 孩子链表头结点</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n, r; 				<span class="comment">// 结点数和根的位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure></div>

<p>孩子表示法便于涉及孩子的操作的实现，却不适用于 PARENT(T,x) 操作。</p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204214803077.png" class title="image-20231204214803077">


</li>
<li><p>孩子兄弟表示法</p>
<p>又称二叉树表示法，或二叉链表表示法。链表中的结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，分别命名为 firstchild 域 和 nextsibling 域</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----- 树的二叉链表（孩子-兄弟）存储表示 -----</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CSNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CSNode</span> * firstchild, * nextsibling;</span><br><span class="line">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure></div>



<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231204214831681.png" alt="image-20231204214831681" style="zoom:33%;">

<p>利用这种存储结构便于实现各种树的操作。首先易于实现找结点孩子等的操作。例如：若要访问结点 x 的第 i 个孩子，则只要先从 firstchild 域找到第 1 个孩子结点，然后沿着孩子结点的 nextsibling 域连续走 i-1 步，便可找到 x 的第 i 个孩子。</p>
</li>
</ol>
<h3 id="6-4-2-森林和二叉树的转换"><a href="#6-4-2-森林和二叉树的转换" class="headerlink" title="6.4.2 森林和二叉树的转换"></a>6.4.2 森林和二叉树的转换</h3><img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204215644750.png" class title="image-20231204215644750">

<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231204215755020.png" class title="image-20231204215755020">

<p>给定一棵树，可以找到惟一的一棵二叉树与之对应。任何一棵和树对应的二叉树，其右子树必空。若把森林的第二棵树的根结点看成第一棵树的根结点的兄弟，同样可导出森林和二叉树的对应关系。</p>
<p><strong>树与二叉树的转换</strong></p>
<p>约定树中每个结点的孩子结点按<strong>从左到右</strong>的次序顺序编号。将树转为二叉树的方法是：<br>（1）树中所有相邻兄弟之间加一条连线。<br>（2）对树中的每个结点，只保留它与第一个孩子之间的连线，删去它与其他孩子结点之间的连线。<br>（3）以树的根结点为轴心，将整棵树顺时针转动一定的角度，使之结构层次分明。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231204221138133.png" alt="image-20231204221138133" style="zoom: 25%;">

<p>在二叉树中，左分支上的各结点在原来的树中是父子关系，而右分支上的各结点在原来的树中是兄弟关系。由于树的根结点没有兄弟，所以<strong>转换后的二叉树的根结点的右孩子必为空</strong>。</p>
<p>事实上，一棵树采用孩子兄弟表示法建立的存储结构与它所对应的二叉树的二叉链表存储结构是完全相同的。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231204232434350.png" alt="image-20231204232434350" style="zoom:33%;">



<p><strong>森林与二叉树的转换</strong></p>
<ul>
<li><p>由森林的概念可知，森林是若干棵树的若干棵树的集合，只要将森林中各棵树的根视为兄弟，每棵树又可以用二叉树表示，这样，森林也同样可以用二叉树表示。</p>
</li>
<li><p>森林转换为二叉树的方法如下：<br>（1）将森林中的每棵树转换为相同的二叉树。<br>（2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子，当所有二叉树连起来后，此时所得到的二叉树就是由森林转换得到的二叉树。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231204233719046.png" alt="image-20231204233719046" style="zoom:25%;"></li>
</ul>
<p><strong>二叉树转换为树和森林</strong></p>
<p>（1）若某结点是其双亲的左孩子，则把该结点的右孩子、右孩子的右孩子……都与该结点的双亲结点用线连起来</p>
<p>（2）删去原二叉树中所有的双亲结点与右孩子结点的连线</p>
<p>（3）整理由（1）、（2）两步所得到的树或森林，使之结构层次分明。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231204235017538.png" alt="image-20231204235017538" style="zoom:33%;">

<ol>
<li>树与二叉树的转换<br>对于一棵无序树，树中结点的各孩子的次序是无关紧要的，而二叉树 中结点的左、右孩子结点是有区别的。为避免发生混淆，我们约定树中每一个结点的孩子结点按从左到右的次序顺序编号。</li>
<li>森林转换为二叉树<br>由森林的概念可知，森林是若干棵树的集合，只要将森林中各棵树的根视为兄弟，每棵树又可以用二叉树表示，这样，森林也同样可以用二叉树表示。 </li>
<li>二叉树转换为树和森林<br>树和森林都可以转换为二叉树，二者不同的是树转换成的二叉树，其根结点无右分支，而森林转换后的二叉树，其根结点有右分支。</li>
</ol>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231204235411235.png" alt="image-20231204235411235" style="zoom:33%;">

<h3 id="6-4-3-树和森林的遍历"><a href="#6-4-3-树和森林的遍历" class="headerlink" title="6.4.3 树和森林的遍历"></a>6.4.3 树和森林的遍历</h3><p>由树结构的定义可引出两种次序遍历树的方法：一种是先根（次序）遍历树，即：先访问树的根结点，然后依次先根遍历根的每棵子树；另一种是后根（次序）遍历，即：先依次后根遍历每棵子树，然后访问根结点。</p>
<ol>
<li><p>先根遍历</p>
<p>先根遍历的定义为： ① 访问根结点； ② 按照从左到右的顺序先根遍历根结点的每一棵子树。</p>
</li>
<li><p>后根遍历</p>
<p>后根遍历的定义为： ① 按照从左到右的顺序后根遍历根结点的每一棵子树； ② 访问根结点。</p>
</li>
<li><p>层次遍历<br> 按从上到下、从左到右访问各结点。</p>
</li>
<li><p>先序遍历森林</p>
<p>若森林非空，则可按下述规则遍历之：</p>
<p>（1）访问森林中第一棵树的根结点</p>
<p>（2）先序遍历第一棵树根结点的子树森林</p>
<p>（3）先序遍历除去第一棵树之后剩余的树构成的森林</p>
</li>
<li><p>中序遍历森林</p>
<p>（1）中序遍历森林中第一棵树的根结点的子树森林</p>
<p>（2）访问第一棵树的根结点</p>
<p>（3）中序遍历除去第一棵树之后剩余的树构成的森林</p>
</li>
</ol>
<p><strong>树的先根次序遍历</strong></p>
<ul>
<li><p>当树非空时</p>
<ul>
<li><p>访问根结点</p>
</li>
<li><p>依次先根遍历根的各棵子树</p>
</li>
</ul>
</li>
</ul>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231205001149352.png" alt="image-20231205001149352" style="zoom:33%;">

<ul>
<li><p>树的先序遍历：ABEFCDG</p>
</li>
<li><p>对应二叉树先序遍历 ABEFCDG</p>
</li>
<li><p>树的先根遍历结果与其对应二叉树表示的先序遍历结果相同</p>
</li>
<li><p>树的先根遍历可以借助对应二叉树的先序遍历算法实现</p>
</li>
<li><p>递归算法实现：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> Tree&lt;Type&gt;::<span class="built_in">PreOrder</span>()&#123;</span><br><span class="line">    <span class="comment">// 以当前指针 current 为根，先根次序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsEmpty</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">Visit</span>();  						   <span class="comment">// 访问根结点</span></span><br><span class="line">        TreeNode&lt;Type&gt; *p = current;</span><br><span class="line">        current = current-&gt;firstChild;   	<span class="comment">// 第一棵子树</span></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">PreOrder</span>();					   <span class="comment">// 递归先根遍历子树</span></span><br><span class="line">            current = current-&gt;nextSibling;</span><br><span class="line">        &#125;</span><br><span class="line">        current = p;    				   <span class="comment">// 恢复当前指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231205002538761.png" alt="image-20231205002538761" style="zoom:33%;">



<p><strong>树的后根次序遍历</strong></p>
<ul>
<li><p>当树非空时</p>
<ul>
<li><p>依次后根遍历根的各棵子树</p>
</li>
<li><p>访问根结点。</p>
</li>
</ul>
</li>
<li><p>树的后根遍历：EFBCGDA</p>
</li>
<li><p>对应二叉树中序遍历：EFBCGDA</p>
</li>
<li><p>树的后根遍历结果与其对应二叉树表示的中序遍历结果相同。</p>
</li>
<li><p>树的后根遍历可以借助<u>对应二叉树的中序遍历算法</u>实现。</p>
</li>
<li><p>递归算法实现：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> Tree&lt;Type&gt;::<span class="built_in">PostOrder</span>()&#123;</span><br><span class="line">    <span class="comment">// 以当前指针 current 为根，按后根次序遍历树</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsEmpty</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">        TreeNode&lt;Type&gt; *p = current;</span><br><span class="line">        current = current-&gt;firstChild;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">PostOrder</span>();		<span class="comment">// 递归先根遍历子树</span></span><br><span class="line">            current = current-&gt;nextSibling;</span><br><span class="line">        &#125;</span><br><span class="line">        current = p;  			<span class="comment">// 恢复当前指针</span></span><br><span class="line">        <span class="built_in">Visit</span>();	 		 	<span class="comment">// 最后访问根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231205003310705.png" alt="image-20231205003310705" style="zoom:33%;">



<p><strong>树的层次遍历</strong></p>
<ul>
<li><p>广度优先（层次次序）遍历</p>
</li>
<li><p>按广度优先次序遍历树的结果：ABCDEFG</p>
</li>
<li><p>层序遍历算法：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> Tree&lt;Type&gt; ::<span class="built_in">LevelOrder</span>()&#123;</span><br><span class="line">    <span class="comment">// 按广度优先次序分层遍历树，树的根结点是当前指针current，算法中使用了队列</span></span><br><span class="line">    Queue&lt;TreeNode&lt;Type&gt;*&gt; <span class="built_in">Qu</span>(DefaultSize);</span><br><span class="line">    TreeNode&lt;Type&gt;*p;</span><br><span class="line">    <span class="keyword">if</span>(current != <span class="literal">NULL</span>)&#123;		<span class="comment">// 当前指针不空</span></span><br><span class="line">        p = current;			<span class="comment">// 保存当前指针</span></span><br><span class="line">        Qu.<span class="built_in">EnQueue</span>(current);</span><br><span class="line">        <span class="keyword">while</span>(Qu.<span class="built_in">IsEmpty</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            current = Qu.<span class="built_in">getFront</span>();</span><br><span class="line">            Qu.<span class="built_in">DeQueue</span>();</span><br><span class="line">            <span class="built_in">Visit</span>();						   <span class="comment">// 队列中取一个并访问之</span></span><br><span class="line">            <span class="keyword">while</span>(current != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                Qu.<span class="built_in">EnQueue</span>(current);			<span class="comment">// 待访问结点的子女结点进队列</span></span><br><span class="line">                current = current-&gt;nextSibling;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="6-6-赫夫曼编码"><a href="#6-6-赫夫曼编码" class="headerlink" title="6.6 赫夫曼编码"></a>6.6 赫夫曼编码</h2><h3 id="6-6-1-最优二叉树（赫夫曼树）"><a href="#6-6-1-最优二叉树（赫夫曼树）" class="headerlink" title="6.6.1 最优二叉树（赫夫曼树）"></a>6.6.1 最优二叉树（赫夫曼树）</h3><p>路径长度：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称作路径长度。</p>
<p>树的路径长度：是从树根到每一结点的路径长度之和。</p>
<p>路的带权路径长度：树中所有叶子结点的带权路径长度之和，通常记为 $WPL&#x3D;\sum^n_{k&#x3D;1}w_kl_k$ 。</p>
<p>假设有 n 个权值 ${w_1, w_2, \cdots, w_n}$ ，试构造一棵有 n 个叶子结点的二叉树，每个叶子结点带权为 $w_i$ ，则其中带权路径长度 $WPL$ 最小的二叉树称作 <strong>最优二叉树</strong> 或 <strong>赫夫曼树</strong>。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231205085907191.png" alt="image-20231205085907191" style="zoom: 33%;">

<p>图中 3 棵二叉树，都有 4 个叶子结点 a、b、c、d，分别带权 7、5、2、4，则它们的带权路径长分别为：<br>（a）$WPL &#x3D; 7\times2+5\times2+2\times2+4\times2&#x3D;36$<br>（b）$WPL &#x3D; 7\times3+5\times3+2\times1+4\times2&#x3D;46$<br>（c）$WPL &#x3D; 7\times1+5\times2+2\times3+4\times3&#x3D;35$</p>
<p><strong>赫夫曼算法</strong>：<br>（1）根据给定的 n 个权值 ${w_1, w_2, \cdots, w_n}$ 构成 n 棵二叉树的集合 $F&#x3D;{T_1, T_2, \cdots, T_n}$ ，其中每棵二叉树 $T_i$ 只有一个带权为 $w_i$ 的根结点，其左右子树均空。<br>（2）在 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和|（3）在 F 中删除这两棵树，同时将得到的新的二叉树加入 F 中<br>（4）重复（2）和（3），直到 F 只含一棵树为止。这棵树便是赫夫曼树。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231205090918799.png" alt="image-20231205090918799" style="zoom:33%;">

<h3 id="6-6-2-赫夫曼编码"><a href="#6-6-2-赫夫曼编码" class="headerlink" title="6.6.2 赫夫曼编码"></a>6.6.2 赫夫曼编码</h3><p>若要设计长度不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码叫做 <strong>前缀编码</strong>。</p>
<p>可以利用二叉树来设计二进制的前缀编码。</p>
<p>为电文设计总长最短的二进制前缀编码：假设每种字符在电文中出现的次数为 $w_i$ ，其编码长度为 $l_i$ ，电文中只有 $n$ 中字符，则电文总长度为 $\sum^n_{i&#x3D;1}w_il_i$。对应到二叉树上，若置 $w_i$ 为叶子结点的权，$l_i$ 恰为从根到叶子的路径长度，$\sum^n_{i&#x3D;1}w_il_i$ 恰为二叉树上带权路径长度。设计电文总长最短的二进制前缀编码即为以 n 种字符出现的频率作权，设计一棵赫夫曼树的问题。</p>
<p><strong>具体做法</strong>：由于赫夫曼树中没有度为1的结点（这类树又称严格的（strict）（或正则的）二叉树），则一棵拥有 n 个叶子结点的赫夫曼编码共有 2n-1 个结点。在构成赫夫曼树之后，求编码需从叶子节点出发走一条从叶子到根的路径；而为译码需从根出发走一条从根到叶子的路径。则对每个结点而言，既需告知双亲的信息，又需知孩子结点的信息。</p>
<p>设定下述存储结构：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----- 赫夫曼树和赫夫曼编码的存储表示 -----</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> parent, lchild, rchild;</span><br><span class="line">&#125;HTNode, *HuffmanTree;       <span class="comment">// 动态分配数组存储赫夫曼树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>** HuffmanCode;  <span class="comment">//动态分配数组存储赫夫曼编码表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求赫夫曼编码的算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HuffmanCoding</span><span class="params">(HuffmanTree &amp;HT, HuffmanCode &amp;HC, <span class="type">int</span>* w, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// w 存放n个字符的权值(均 &gt;0),构造赫夫曼树HT,并求出n个字符的赫夫曼编码HC</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    m = <span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">    HT = (HuffmanTree)<span class="built_in">malloc</span>((m+<span class="number">1</span>)*<span class="built_in">sizeof</span>(HTNode));   <span class="comment">// 0号单元未用</span></span><br><span class="line">    <span class="keyword">for</span>(p = HT, i = <span class="number">1</span>; i&lt;=n; ++i, ++p, ++w) *p = &#123;*w, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;=m; ++i, ++p) *p = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=n+<span class="number">1</span>; i&lt;=m; ++i)&#123;   <span class="comment">// 构建赫夫曼树 </span></span><br><span class="line">        <span class="comment">// 在 HT[1...i-1] 选择 parent 为 0 且 weight 最小的两个结点，</span></span><br><span class="line">        <span class="comment">// 其序号分别为 s1 和 s2</span></span><br><span class="line">        <span class="built_in">Select</span>(HT, i<span class="number">-1</span>, s1, s2);</span><br><span class="line">        HT[s1].parent = i, HT[s2].parent = i;</span><br><span class="line">        HT[i].lchild = s1, HT[i].rchild = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight+HT[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --- 从叶子到根逆向求每个字符的赫夫曼编码 ---</span></span><br><span class="line">    HC = (HuffmanCode)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">char</span>*));	<span class="comment">// 分配 n 个字符编码的头指针向量</span></span><br><span class="line">    cd = (<span class="type">char</span>*)<span class="built_in">malloc</span>(n*<span class="built_in">sizeof</span>(<span class="type">char</span>)); 			<span class="comment">// 分配求编码的工作空间</span></span><br><span class="line">    cd[n<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;									<span class="comment">// 编码结束符</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)&#123;							<span class="comment">// 逐个字符求赫夫曼编码</span></span><br><span class="line">        start = n<span class="number">-1</span>;								<span class="comment">// 编码结束符位置</span></span><br><span class="line">        <span class="keyword">for</span>(c=i, f=HT[i].parent; f!=<span class="number">0</span>; c=f, f=HT[f].parent) <span class="comment">// 从叶子到根逆向求编码</span></span><br><span class="line">            <span class="keyword">if</span>(HT[f].lchild == c) cd[--start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        	<span class="keyword">else</span> cd[--start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        HC[i] = (<span class="type">char</span>*)<span class="built_in">malloc</span>((n-start)*<span class="built_in">sizeof</span>(<span class="type">char</span>)); <span class="comment">// 为第 i 个字符编码分配空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], &amp;cd[start]); 					<span class="comment">// 从 cd 赋值编码(串)到 HC</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cd);			<span class="comment">// 释放工作空间</span></span><br><span class="line">&#125; <span class="comment">// HuffmanCoding</span></span><br></pre></td></tr></table></figure></div>

<p>从根出发求得各个叶子结点所表示的字符的赫夫曼编码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HC = (HuffmanCode)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">p = m; cdlen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;=m; ++i)  HT[i].weight = <span class="number">0</span>;  	<span class="comment">// 遍历赫夫曼树时作结点状态标志</span></span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line">    <span class="keyword">if</span>(HT[p].weight == <span class="number">0</span>)&#123;					<span class="comment">// 向左</span></span><br><span class="line">        HT[p].weight = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(HT[p].lchild == <span class="number">0</span>) &#123;p = HT[p].lchild; cd[cdlen++] = <span class="string">&#x27;0&#x27;</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(HT[p].rchild == <span class="number">0</span>)&#123;</span><br><span class="line">            HC[p] = (<span class="type">char</span>*)<span class="built_in">malloc</span>((cdlen+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">            cd[cdlen] = <span class="string">&#x27;\0&#x27;</span>; <span class="built_in">strcpy</span>(HC[p], cd);  <span class="comment">// 复制编码(串)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(HT[p].weight == <span class="number">1</span>)&#123;				<span class="comment">// 向右</span></span><br><span class="line">        HT[p].weight = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(HT[p].rchild != <span class="number">0</span>)&#123;p = HT[p].rchild; cd[cdlen++] = <span class="string">&#x27;1&#x27;</span>;&#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;									<span class="comment">// HT[p].weight == 2，退回</span></span><br><span class="line">        HT[p].weight = <span class="number">0</span>; p = HT[p].parent;  --cdlen;  <span class="comment">// 退到父结点，编码长度减1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>







<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="1-堆的定义及其实现"><a href="#1-堆的定义及其实现" class="headerlink" title="1 堆的定义及其实现"></a>1 堆的定义及其实现</h3><img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231205101134528.png" alt="image-20231205101134528" style="zoom: 50%;">

<p>最小堆：根节点是所有结点中最小的</p>
<p>最大堆：根结点是所有结点中最大的</p>
<p><strong>堆的性质</strong>：</p>
<ul>
<li>从逻辑的角度来讲，<strong>堆是一种树形结构</strong>，而且是一种特殊的完全二叉树。每个结点对应于序列中的一个关键码。</li>
<li>堆序，只是<strong>局部有序</strong>，即 <strong>最小堆</strong> 对应的完全二叉树中<strong>所有内部结点的值均不大于其左右孩子关键码值</strong>，而一个结点和其兄弟之间没有必然的联系。</li>
<li>最小堆不像二叉排序树那样实现了关键码的完全排序。相比较而言，<strong>只有当结点之间是父子关系时候，才可以确定这两个关键码的大小关系</strong>。</li>
</ul>
<p><strong>最小堆的类定义</strong>：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DefaultSize 10</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span>: <span class="keyword">public</span> MinPQ&lt;type&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type * heap;					<span class="comment">// 存放最小堆元素的数组</span></span><br><span class="line">    <span class="type">int</span> CurrentSize;				<span class="comment">// 最小堆当前元素个数</span></span><br><span class="line">    <span class="type">int</span> MaxHeapSize;				<span class="comment">// 最多允许元素的个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FilterDown</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> m)</span></span>;	<span class="comment">// 从 i 到 m 自顶向下进行调整成为最小堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FilterUp</span><span class="params">(<span class="type">int</span> i)</span></span>;			<span class="comment">// 从 i 到 0 自底向上进行调整成最小堆</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinHeap</span>(<span class="type">int</span> sz);</span><br><span class="line">    <span class="built_in">MinHeap</span>(Type arr[], <span class="type">int</span> n);</span><br><span class="line">    <span class="built_in">MinHeap</span>(<span class="type">const</span> MinHeap&amp; R);</span><br><span class="line">    ~<span class="built_in">MinHeap</span>()&#123; <span class="keyword">delete</span>[]heap; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> Type&amp; x)</span></span>;		<span class="comment">// 插入</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">IsEmpty</span><span class="params">()</span><span class="type">const</span>				<span class="comment">// 判断堆空否</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> CurrentSize == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">IsFull</span><span class="params">()</span><span class="type">const</span>				<span class="comment">// 判断堆满否</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> CurrentSize == MaxHeapSize; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MakeEmpty</span><span class="params">()</span> </span>&#123;CurrentSize = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>



<p><strong>最小堆向下调整调整算法</strong>：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;Type&gt;::<span class="built_in">FilterDown</span>(<span class="type">int</span> start, <span class="type">int</span> EndOfHeap)&#123;</span><br><span class="line">    <span class="type">int</span> i = start, j = <span class="number">2</span>*i+<span class="number">1</span>;	<span class="comment">// j 是 i 的左孩子</span></span><br><span class="line">    Type temp = heap[i];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= EndOfHeap)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;EndOfHeap &amp;&amp; heap[j]&gt;heap[j+<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(temp &lt;= heap[j]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            heap[i] = heap[j];·<span class="comment">// 下面的上浮</span></span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span>*j+<span class="number">1</span>;			<span class="comment">// 向下滑动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>最小堆向上调整算法</strong>：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;Type&gt;::<span class="built_in">FilterUp</span>(<span class="type">int</span> start)&#123;</span><br><span class="line">    <span class="comment">// 从 start 开始，向上直到 0,调整堆</span></span><br><span class="line">    <span class="type">int</span> j = start, i = (j<span class="number">-1</span>)/<span class="number">2</span>; <span class="comment">// i是j的双亲</span></span><br><span class="line">    Type temp = heap[j];</span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap[i]&lt;=temp) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;heap[j] = heap[i]; j = i, i = (i<span class="number">-1</span>)/<span class="number">2</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>最小堆的插入</strong>：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">int</span> MinHeap&lt;Type&gt;::<span class="built_in">Insert</span>(<span class="type">const</span> Type &amp;x)&#123;</span><br><span class="line">    <span class="comment">// 从堆中插入新元素 x</span></span><br><span class="line">    <span class="keyword">if</span>(CurrentSize == MaxHeapSize)</span><br><span class="line">    &#123; cerr &lt;&lt; <span class="string">&quot;堆已满&quot;</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    heap[CurrentSize] = x; 		<span class="comment">// 插在表尾</span></span><br><span class="line">    <span class="built_in">FilterUp</span>(CurrentSize);		<span class="comment">// 向上调整为堆</span></span><br><span class="line">    CurrentSize++;				<span class="comment">// 堆元素大小+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>最小堆的删除</strong>：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; </span><br><span class="line"><span class="type">int</span> MinHeap&lt;Type&gt;::<span class="built_in">Remove</span> ( Type &amp;x ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !CurrentSize )</span><br><span class="line">    &#123; cout &lt;&lt; “ 堆已空 <span class="string">&quot; &lt;&lt; endl; return 0; &#125;</span></span><br><span class="line"><span class="string">    x = heap[0]; 						//最小元素出队列</span></span><br><span class="line"><span class="string">    heap[0] = heap[CurrentSize-1];</span></span><br><span class="line"><span class="string">    CurrentSize--; 						//用最小元素填补</span></span><br><span class="line"><span class="string">    FilterDown ( 0, CurrentSize-1 ); 	//调整</span></span><br><span class="line"><span class="string">    return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></div>





<h1 id="7-图"><a href="#7-图" class="headerlink" title="7 图"></a>7 图</h1><p>图（graph），结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。</p>
<h2 id="7-1-图的定义和术语"><a href="#7-1-图的定义和术语" class="headerlink" title="7.1 图的定义和术语"></a>7.1 图的定义和术语</h2><p>抽象数据类型图的定义：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">ADT Graph&#123;</span><br><span class="line">    数据对象 V: V 是具有相同特性的数据元素的集合，称为顶点集</span><br><span class="line">    数据关系 R: </span><br><span class="line">    	R = &#123;VR&#125;</span><br><span class="line">    	VR = &#123;&lt;v,w&gt;| v,w ∈ V 且 P(v,w), &lt;v,w&gt; 表示从 v 到 w 的弧,</span><br><span class="line">    				谓词 P(v,w) 定义了弧&lt;v,w&gt;的意义或信息&#125;</span><br><span class="line">    基本操作 P:</span><br><span class="line">    	CreateGraph(&amp;G, V, VR);</span><br><span class="line">    		初始条件: V 是图的顶点集, VR 是图中弧的集合</span><br><span class="line">    		操作结果: 按 V 和 VR 的定义构造图 G</span><br><span class="line">    	DestroyGraph(&amp;G);</span><br><span class="line">            初始条件: 图G存在</span><br><span class="line">            操作结果: 销毁图G</span><br><span class="line">    	LocateVex(G, u);</span><br><span class="line">            初始条件: 图 G 存在, u 和 G 中顶点有相同特征</span><br><span class="line">            操作结果: 若 G 存在顶点 u, 则返回该顶点在图中位置;否则返回其他信息</span><br><span class="line">    	GetVex(G, v);</span><br><span class="line">            初始条件: 图 G 存在, v 是 G 中某个顶点</span><br><span class="line">            操作结果: 返回 v 的值</span><br><span class="line">    	PutVex(&amp;G, v, value);</span><br><span class="line">            初始条件: 图 G 存在, v 是 G 中某个顶点</span><br><span class="line">            操作结果: 对 v 赋值 value</span><br><span class="line">    	FirstAdjVex(G, v);</span><br><span class="line">            初始条件: 图 G 存在, v 是 G 中某个顶点</span><br><span class="line">            操作结果: 返回 v 的第一个邻接顶点.若顶点在 G 中没有邻接顶点，则返回 &quot;空&quot;</span><br><span class="line">    	NextAdjVex(G, v, w);</span><br><span class="line">            初始条件: 图 G 存在, v 是 G 中某个顶点, w 是 v 的邻接顶点</span><br><span class="line">            操作结果: 返回 v 的(相对于 w 的)下一个邻接顶点。若 w 是 v 的最后一个邻接点, 则返回 &quot;空&quot;</span><br><span class="line">    	InsertVex(&amp;G, v);</span><br><span class="line">            初始条件: 图 G 存在, v 和图中顶点有相同特征</span><br><span class="line">            操作结果: 在图 G 中增添新顶点 v</span><br><span class="line">    	DeleteVex(&amp;G, v);</span><br><span class="line">            初始条件: 图 G 存在, v 是 G 中某个顶点</span><br><span class="line">            操作结果: 删除 G 中顶点 v 及其相关的弧</span><br><span class="line">    	InsertArc(&amp;G, v, w);</span><br><span class="line">            初始条件: 图 G 存在, v 和 w 是 G 中两个顶点</span><br><span class="line">            操作结果: 在 G 中增添弧 &lt;v,w&gt;,若 G 是无向的,则还增添对称弧 &lt;w,v&gt;</span><br><span class="line">    	DeletetArc(&amp;G, v, w);</span><br><span class="line">            初始条件: 图 G 存在, v 和 w 是 G 中两个顶点</span><br><span class="line">            操作结果: 在 G 中删除弧 &lt;v,w&gt;,若 G 是无向的,则还删除对称弧 &lt;w,v&gt;</span><br><span class="line">    	DFSTraverse(G, Visit());</span><br><span class="line">    		初始条件: 图 G 存在, Visit 是顶点的应用函数</span><br><span class="line">    		操作结果: 对图进行深度优先遍历。在遍历过程中对每个顶点调用函数 Visit 一次且仅一次。一旦 visit() 失败, 则操作失败。</span><br><span class="line">        BFSTraverse(G, Visit());</span><br><span class="line">        	初始条件: 图 G 存在, Visit 是顶点的应用函数</span><br><span class="line">    		操作结果: 对图进行广度优先遍历。在遍历过程中对每个顶点调用函数 Visit 一次且仅一次。一旦 visit() 失败, 则操作失败。</span><br><span class="line">&#125;ADT Graph</span><br></pre></td></tr></table></figure></div>

<p>在图中的数据元素通常称为 <strong>顶点</strong>（Vertex），V 是顶点的有穷非空集合；VR 是两个顶点之间的关系的集合。若 $&lt;v, w&gt;\in VR$ ，则 $&lt;v,w&gt;$ 表示从 $v$ 到 $w$ 的一条弧（Arc），且称 $v$ 为弧尾（Tail）或初始点（Initial node），称 $w$ 为弧头（Head）或终端点（Terminal node），此时的图称为 <strong>有向图</strong>（Digraph） 。若 $&lt;v,w&gt;\in VR$，则必有 $&lt;w,v&gt;\in VR$，即 $VR$ 是对称的，则以无序对$(v,w)$ 代替 这两个有序对，表示 $v$ 和 $w$ 之间的一条边（Edge），这时的图称为 <strong>无向图</strong>（Undigraph）。例如：</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231206145850919.png" alt="image-20231206145850919" style="zoom:50%;">

<p>图(a)中，$G_1$ 是有向图，定义此图的谓词 $P(v,w)$ 则表示从 $v$ 到 $w$ 的一条单向通路。$G_1 &#x3D; (V_1, {A_1})$ </p>
<p>其中：	$V_1 &#x3D; {v_1, v_2, v_3, v_4}$</p>
<p>​				$A_1 &#x3D; {&lt;v_1, v_2&gt;, &lt;v_1, v_3&gt;, &lt;v_3, v_4&gt;, &lt;v_4, v_3&gt;}$</p>
<p>图(b)中，$G_2$ 是无向图。$G_2 &#x3D; (V_2, {E_2})$ 。</p>
<p>其中：	$V_2 &#x3D; {v_1, v_2, v_3, v_4, v_5}$</p>
<p>​				$E_2 &#x3D; {(v_1, v_2),(v_1, v_4), (v_2, v_3),(v_2, v_5),(v_3, v_4),(v_3, v_5)}$ </p>
<p>用 n 表示图中顶点数目，用 e 表示边和弧的数目。若考虑 $&lt;v_i,v_j&gt;\in VR,v_i\not&#x3D;v_j$ ，那么对于无向图，e 的取值范围是 0 到 $\cfrac12n(n-1)$ 。有 $\cfrac12n(n-1)$ 条边的无向图称为 <strong>完全图</strong>。对于有向图，e 的取值范围为 0 到 n(n-1)。具有 n(n-1) 条弧的有向图称为 <strong>有向完全图</strong>。</p>
<p>有很少条边或弧的图称为 <strong>稀疏图</strong>，反之称为 <strong>稠密图</strong>。</p>
<p>有时图的边或弧具有与它有关的数，这种与图的边或弧相关的数叫做 <strong>权</strong>。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种 <strong>带权的图</strong> 通常称为 <strong>网</strong>。</p>
<p>假设有两个图 $G &#x3D; (V, {E})$ 和 $G’ &#x3D; (V’, {E’})$ ，如果 $V’\subseteq V$ ，且 $E’\subseteq E$ ，则称 $G’$ 为 $G$ 的 <strong>子图</strong>。</p>
<p>对于无向图 $G&#x3D;(V,{E})$ ，如果边 $(v, v’)\in E$ ，则称顶点 $v$ 和 $v’$ 互为 <strong>邻接点</strong>（Adjacent），即 $v$ 和 $v’$ 相邻接。边 $(v,v’)$ 依附于顶点 $v$ 和 $v’$ ，或者说 $(v,v’)$ 和顶点 $v$ 和 $v’$ 相关联。顶点 $v$ 的<strong>度</strong>是和 $v$ 相关联的边的数目，记为 $TD(V)$ 。</p>
<p>对于有向图 $G&#x3D;(V,{A})$，如果弧 $&lt;v,v’&gt;\in A$，则称顶点 $v$ 邻接到顶点 $v’$ ，顶点 $v’$ 邻接自顶点 $v$ 。弧 $&lt;v,v’&gt;$ 和顶点 $v$ 和 $v’$ 相关联。以顶点 $v$ 为头的弧的数目成为 $v$ 的 <strong>入度</strong>，记为 $ID(v)$；以 $v$ 为尾的弧的数目成为 $v$ 的 <strong>出度</strong>，记为 $OD(v)$。顶点 $v$ 的度为 $TD(v) &#x3D; ID(v)+OD(v)$。</p>
<p>一般地，如果顶点 $v_i$ 的度记为 $TD(v_i)$ ，那么一个有 $n$ 个顶点，$e$ 条边或弧的图，满足：<br>$$<br>e &#x3D; \cfrac12\sum^n_{i &#x3D; 1}TD(v_i)<br>$$<br>无向图 $G&#x3D;(V,{E})$ 中从顶点 $v$ 到顶点 $v’$ 的路径（Path）是一个顶点序列（$v &#x3D; v_{i,0},v_{i,1},\cdots,v_{i,m}&#x3D;v’$），其中 $(v_{i,j-1},v_{i,j})\in E,1\leqslant j \leqslant m$。</p>
<p> $G$ 有向图，则路径是有向的，顶点序列应满足 $&lt;v_{i,j-1},v_{i,j}&gt;\in E,1\leqslant j \leqslant m$ 。</p>
<p><strong>路径长度</strong> 是路径上边或弧的数目。第一个顶点和最后一个顶点相同的路径 称为 <strong>回路</strong> 或 <strong>环</strong>。序列中 顶点不重复出现的路径 称为 <strong>简单路径</strong>。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为 简单回路 或 简单环。</p>
<p>在无向图 $G$ 中，如果从顶点 $v$ 到 顶点 $v’$ 有路径，则称 $v$ 和 $v’$ 是连通的。如果对于图中任意两个顶点 $v_i,v_j \in V$ ，$v_i$ 和 $v_j$ 都是连通的，则称 $G$ 是 <strong>连通图</strong>。<strong>连通分量</strong> 指的是 无向图 中 <strong>极大连通子图</strong>。</p>
<p>在有向图 $G$ 中，如果对于每一对  $v_i,v_j \in V$ ，$v_i \not&#x3D;v_j$，从 $v_i$ 到 $v_j$ 和 从 $v_j$ 到 $v_i$ 都存在路径，则称 G 是 <strong>强连通图</strong>。有向图中的极大强连通子图称作 有向图的 <strong>强连通分量</strong>。</p>
<p>一个连通图的 <strong>生成树</strong> 是一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的 $n-1$ 条边。一棵有 $n$ 个顶点的 生成树 有且仅有 $n-1$ 条边。如果一个图有 $n$ 个顶点和 小于 $n-1$ 条边，则是非连通图。如果它多于 $n-1$ 条边，则一定有环。但是，有 $n-1$ 条边的图不一定是生成树。</p>
<p>如果一个有向图恰好有一个顶点的入度为 0，其余顶点的入度均为 1，则是一棵有向树。一个有向图的 <strong>生成森林</strong> 由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</p>
<p>图中的顶点之间不存在全序的关系（即无法将图中顶点排列成一个线性序列），任何一个顶点都可以被看成是第一个顶点；另一方面，任一顶点的邻接点之间也不存在次序关系。</p>
<h2 id="7-2-图的存储结构"><a href="#7-2-图的存储结构" class="headerlink" title="7.2 图的存储结构"></a>7.2 图的存储结构</h2><p>图没有顺序映像的存储结构。</p>
<p>常用的有 邻接表、邻接多重表 和 十字链表。</p>
<h3 id="7-2-1-数组表示法"><a href="#7-2-1-数组表示法" class="headerlink" title="7.2.1 数组表示法"></a>7.2.1 数组表示法</h3><p>用两个数组分别存储数据元素（顶点）的信息和数据元素之间的关系（边或弧）的信息。其形式描述如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//- - - - - 图的数组（邻接矩阵）存储表示 - - - - -//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY   INT_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTER_NUM 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;DG, DN, UDG, UDN&#125; GraphKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcCell</span>&#123;</span><br><span class="line">    VRType adj;       <span class="comment">// VRType 是顶点关系类型。对无权图，用 1 或 0</span></span><br><span class="line">                      <span class="comment">// 表示是否相邻，对带权图，表示为权值类型</span></span><br><span class="line">    InfoType * info;  <span class="comment">// 该弧相关信息的指针</span></span><br><span class="line">&#125;ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    VertexType vexs[MAX_VERTEX_NUM];  <span class="comment">// 顶点向量</span></span><br><span class="line">    AdjMatrix  arcs;                  <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="type">int</span>        vexnum, arcnum;        <span class="comment">// 图的当前顶点数 和 弧数</span></span><br><span class="line">    GraphKind  kind;                  <span class="comment">// 图的种类标志</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure></div>

<p>借助于邻接矩阵，容易判定任意两个顶点之间是否有边（或弧）相连，并容易求得各个顶点的度。对于无向图，顶点 $v_i$ 的度是邻接矩阵中第 $i$ 行（或第 $i$ 列）的元素之和，即<br>$$<br>TD(v_i) &#x3D; \sum^{n-1}_{j&#x3D;0}A[i]<a href="n=MAX_VERTEX_NUM">j</a><br>$$<br>对于有向图，第 $i$ 行的元素之和为 顶点 $v_i$ 的出度 $OD(v_i)$，第 $j$ 列的元素之和 为顶点 $v_j$ 的入度 $ID(v_j)$ 。</p>
<p>网的邻接矩阵可定义为<br>$$<br>A[i][j] &#x3D; \begin{cases}<br>w_{i,j} &amp;若&lt;v_i,v_j&gt; 或 (v_i,v_j) \in VR\<br>\infin &amp; 反之<br>\end{cases}<br>$$</p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206193025842.png" class title="image-20231206193025842">

<p>在邻接矩阵存储结构 MGraph 上对图的构造操作的实现框架，它根据图 G 的种类调用具体构造算法。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateGraph</span><span class="params">(MGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 采用 数组（邻接矩阵）表示法，构造图G</span></span><br><span class="line">    <span class="built_in">scanf</span>(&amp;G.kind);</span><br><span class="line">    <span class="keyword">switch</span>(G.kind)&#123;</span><br><span class="line">        <span class="keyword">case</span> DG: <span class="keyword">return</span> <span class="built_in">CreateDG</span>(G);	<span class="comment">// 构造有向图 G</span></span><br><span class="line">        <span class="keyword">case</span> DN: <span class="keyword">return</span> <span class="built_in">CreateDN</span>(G);	<span class="comment">// 构造有向网 G</span></span><br><span class="line">        <span class="keyword">case</span> UDG: <span class="keyword">return</span> <span class="built_in">CreateUDG</span>(G);	<span class="comment">// 构造无向图 G</span></span><br><span class="line">        <span class="keyword">case</span> UDN: <span class="keyword">return</span> <span class="built_in">CreateUDN</span>(G);	<span class="comment">// 构造无向网 G</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// CreateGraph</span></span><br></pre></td></tr></table></figure></div>

<p>构造 无向网：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateUDN</span><span class="params">(MGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 采用数组（邻接矩阵）表示法，构造无向网 G</span></span><br><span class="line">    <span class="built_in">scanf</span>(&amp;G.vexnum, &amp;G.arcnum, &amp;IncInfo);	<span class="comment">// IncInfo为0则各弧不含其他信息</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;G.vexnum; ++i) <span class="built_in">scanf</span>(&amp;G.vexs[i]); <span class="comment">// 构造顶点向量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;G.vexnum; ++i)	<span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;G.vexnum; ++j)</span><br><span class="line">            G.arcs[i][j] = &#123;INFINITY, <span class="literal">NULL</span>&#125;;  <span class="comment">// &#123;adj, info&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;G.arcnum; ++k)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(&amp;v1, &amp;v2, &amp;w);	<span class="comment">// 输入一条边依附的顶点及权值</span></span><br><span class="line">        i = <span class="built_in">LocateVex</span>(G,v1);</span><br><span class="line">        j = <span class="built_in">LocateVex</span>(G,v2); 	<span class="comment">// 确定v1和v2在 G 中位置</span></span><br><span class="line">        G.arcs[i][j].adj = w;	<span class="comment">// 弧&lt;v1,v2&gt;的权值</span></span><br><span class="line">        <span class="keyword">if</span>(IncInfo)	</span><br><span class="line">            <span class="built_in">Input</span>(*G.arcs[i][j].info); <span class="comment">// 若弧含有相关信息，则输入</span></span><br><span class="line">        G.arcs[j][i] = G.arcs[i][j];	<span class="comment">// 置&lt;v1,v2&gt;的对称弧</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;  <span class="comment">// CreateUDN</span></span><br></pre></td></tr></table></figure></div>



<h3 id="7-2-2-邻接表"><a href="#7-2-2-邻接表" class="headerlink" title="7.2.2 邻接表"></a>7.2.2 邻接表</h3><p><strong>邻接表</strong> 是图的一个链式存储结构。在邻接表中，对图中每个顶点建立一个单链表，第 $i$ 个单链表中的结点表示依附于顶点 $v_i$ 的边（对有向图是以顶点 $v_i$ 为尾的弧）。每个结点由 3 个域组成，其中 邻接点域（adjvex）指示与顶点 $v_i$ 邻接的点在图中的位置，链域（nextarc）指示下一条边或弧的结点；数据域（info）存储和边或弧相关的信息，如权值等。每个链表上附设一个表头结点。在表头结点中，除了 设有链域指向链表中的第一个结点之外，还设有存储顶点 $v_i$ 的名或其他有关信息的数据域（data）。</p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206195619668.png" class title="image-20231206195619668">

<p>表头结点（可以链相接）通常以顺序结构的形式存储，以便随机访问顶点的链表。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----- 图的邻接表存储表示 -----</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="comment">// 表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> 			adjvex;		<span class="comment">// 该弧所指向的顶点的位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span>*	nextarc;	<span class="comment">// 指向下一条弧的指针</span></span><br><span class="line">    InfoType	  * info;		<span class="comment">// 该弧相关信息的指针	</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span>&#123;</span><br><span class="line">    VertexType data;			<span class="comment">// 顶点信息</span></span><br><span class="line">    ArcNode	  * firstarc;		<span class="comment">// 指向第一条依附该顶点的弧的指针</span></span><br><span class="line">&#125;VNode, AdjList[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span>		vexnum, arcnum;		<span class="comment">// 图的当前顶点数和弧数</span></span><br><span class="line">    <span class="type">int</span>		kind;				<span class="comment">// 图的种类标志</span></span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure></div>

<p>若无向图中有 $n$ 个顶点、$e$ 条边，则它的邻接表需 $n$ 个头结点和 $2e$ 个表结点。显然，在边稀疏（$e\ll \cfrac{n(n-1)}2$）的情况下，用邻接表表示图比邻接矩阵节省存储空间，当和边相关的信息较多时更是如此。</p>
<p>在无向图的邻接表中，顶点 $v_i$ 的度恰为第 $i$ 个链表中的结点数；而在有向图中，第 $i$ 个链表中的结点个数 只是顶点 $v_i$ 的出度，为求入度，必须遍历整个邻接表。</p>
<h3 id="7-2-3-十字链表"><a href="#7-2-3-十字链表" class="headerlink" title="7.2.3 十字链表"></a>7.2.3 十字链表</h3><p>十字链表是有向图的另一种链式存储结构。可以看成将有向图的邻接表和逆邻接表结合起来得到的一种链表。在十字链表中，对应于有向图中每一条弧有一个结点，对应于每个顶点也有一个结点。这些结点的结构如下：</p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206203424046.png" class title="image-20231206203424046">

<p>弧结点：<br>尾域 tailvex：指示弧尾顶点在图中的位置<br>头域 headvex：指示弧头顶点在图中的位置<br>链域 hlink 指向弧头相同的下一条弧<br>链域 tlink 指向弧尾相同的下一条弧<br>info 域：指向该弧的相关信息</p>
<p>头结点：<br>data 存储和顶点相关的信息<br>firstin链域，指向以顶点为弧头的第一个弧结点<br>firstout链域，指向以顶点为弧尾的第一个弧结点</p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206204037559.png" class title="image-20231206204037559">

<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----- 有向图的十字链表存储表示 -----</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcBox</span>&#123;</span><br><span class="line">    <span class="type">int</span> 			tailvex, headvex;	<span class="comment">// 该弧的尾和头顶点的位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcBox</span> * hlink, *tlink;		<span class="comment">// 分别为弧头相同和弧尾相同的链域</span></span><br><span class="line">    InfoType	 *	info;				<span class="comment">// 该弧相关信息的指针</span></span><br><span class="line">&#125;ArcBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VexNode</span>&#123;</span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcBox   * firstin, * firstout;		<span class="comment">// 分别指向该顶点第一条入弧和出弧</span></span><br><span class="line">&#125;VexNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    VexNode xlist[MAX_VERTEX_NUM];		<span class="comment">// 表头向量</span></span><br><span class="line">    <span class="type">int</span> 	vexnum, arcnum;				<span class="comment">// 有向图的当前顶点数和弧数</span></span><br><span class="line">&#125;OLGraph;</span><br></pre></td></tr></table></figure></div>



<p>只要输入 $n$ 个顶点的信息和 $e$ 条弧的信息，便可建立该有向图的十字链表：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateDG</span><span class="params">(OLGraph &amp;G)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 采用十字链表存储表示，构造有向图G(G.kind=DG)</span></span><br><span class="line">    <span class="built_in">scanf</span>(&amp;G.vexnum, &amp;G.arcnum, &amp;IncInfo);</span><br><span class="line">    <span class="comment">// IncInfo为0则各弧不含其他信息</span></span><br><span class="line">    <span class="comment">// 构造表头向量</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;G.arcnum; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(&amp;G.xlist[i].data);	<span class="comment">// 输入顶点值</span></span><br><span class="line">        G.xlist[i].firstin = <span class="literal">NULL</span>;	<span class="comment">// 初始化指针</span></span><br><span class="line">        G.xlist[i].firstout = <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;G.arcnum, ++k)&#123;		<span class="comment">// 输入各弧并构造十字链表</span></span><br><span class="line">        <span class="built_in">scanf</span>(&amp;v1, &amp;v2);			<span class="comment">// 输入一条弧的始点和终点</span></span><br><span class="line">        i = <span class="built_in">LocateVex</span>(G, v1); j = <span class="built_in">LocateVex</span>(G, v2);	<span class="comment">// 确定v1和v2在G中位置</span></span><br><span class="line">        p = (ArcBox*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ArcBox)); <span class="comment">// 假定有足够空间</span></span><br><span class="line">        *p = &#123;i, j, G.xlist[j].firstin, G.xlist[i].firstout, <span class="literal">NULL</span>&#125;;  <span class="comment">// 对弧结点赋值</span></span><br><span class="line">        G.xlist[j].firstin = G.xlist[i].firstout = p; <span class="comment">// 完成在入弧和出弧链头的插入</span></span><br><span class="line">        <span class="keyword">if</span>(IncInfo) <span class="built_in">Input</span>(*p-&gt;info);	<span class="comment">// 若弧含有相关信息，则输入</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="comment">// CreateDG</span></span><br></pre></td></tr></table></figure></div>



<h3 id="7-2-4-邻接多重表"><a href="#7-2-4-邻接多重表" class="headerlink" title="7.2.4 邻接多重表"></a>7.2.4 邻接多重表</h3><p>邻接多重表是无向图的另一种链式存储结构。</p>
<p>每一条边用一个结点表示，它由如下所示的 6 个域组成：</p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206210541751.png" class title="image-20231206210541751">

<p>每个 顶点也用一个结点表示，由两个域组成：data 和 firstedge。</p>
<h2 id="7-3-图的遍历"><a href="#7-3-图的遍历" class="headerlink" title="7.3 图的遍历"></a>7.3 图的遍历</h2><p><strong>图的遍历</strong>：从某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次。</p>
<h3 id="7-3-1-深度优先搜索"><a href="#7-3-1-深度优先搜索" class="headerlink" title="7.3.1 深度优先搜索"></a>7.3.1 深度优先搜索</h3><p><strong>深度优先搜索</strong>（Depth_First Search）</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用的全局变量</span></span><br><span class="line">Boolean visited[MAX];    <span class="comment">// 访问标志数组</span></span><br><span class="line"><span class="built_in">Status</span> (* VisitFunc)(<span class="type">int</span> v);   <span class="comment">// 函数变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G, Status(*Visit)(<span class="type">int</span> v))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对图 G 作深度优先遍历</span></span><br><span class="line">    VisitFunc = Visit;<span class="comment">// 使用全局变量 VisitFunc，使用 DFS 不必设置函数指针参数</span></span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v&lt;G.vexnum; ++v) visit[v] = FALSE;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v&lt;G.vexnum, ++v)</span><br><span class="line">        <span class="keyword">if</span>(!visit[v]) <span class="built_in">DFS</span>(G, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 从第 v 个顶点出发递归地深度优先遍历图G</span></span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    <span class="built_in">VisitFunc</span>(v);  <span class="comment">// 访问第 v 个顶点</span></span><br><span class="line">    <span class="keyword">for</span>(w = <span class="built_in">FirstAdjVex</span>(G, v); w&gt;=<span class="number">0</span>; w = <span class="built_in">NextAdjVex</span>(G, v, w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w]) <span class="built_in">DFS</span>(G, w);  <span class="comment">// 对 v 的尚未访问的邻接顶点 w 递归调用 DFS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h3 id="7-3-2-广度优先搜索"><a href="#7-3-2-广度优先搜索" class="headerlink" title="7.3.2 广度优先搜索"></a>7.3.2 广度优先搜索</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G, Status(*Visit)(<span class="type">int</span> v))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v&lt;G.vexnum; ++v) visited[v] = FALSE;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;G.vexnum; ++v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">        &#123;</span><br><span class="line">            visited[v] = TRUE; <span class="built_in">Visit</span>(v);</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q.v);</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">DeQueue</span>(Q, v);</span><br><span class="line">                <span class="keyword">for</span>(w = <span class="built_in">FirstAdjVex</span>(G, u); w&gt;=<span class="number">0</span>; w = <span class="built_in">NextAdjVex</span>(G, u, w))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[w])</span><br><span class="line">                    &#123;</span><br><span class="line">                        visited[w] = True; <span class="built_in">Visit</span>(w);</span><br><span class="line">                        <span class="built_in">EnQueue</span>(Q, w);</span><br><span class="line">                    &#125;</span><br><span class="line">				&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h2 id="7-4-图的连通性问题"><a href="#7-4-图的连通性问题" class="headerlink" title="7.4 图的连通性问题"></a>7.4 图的连通性问题</h2><h3 id="7-4-1-无向图的连通分量和生成树"><a href="#7-4-1-无向图的连通分量和生成树" class="headerlink" title="7.4.1 无向图的连通分量和生成树"></a>7.4.1 无向图的连通分量和生成树</h3><p>在对无向图进行遍历时，对于连通图，仅需从图中任一顶点出发，进行深度优先搜索或广度优先搜索，便可访问到图中所有顶点。对于非连通图，需要从多个顶点出发进行搜索，而每一次从新的起始点出发进行搜索的过程中得到的顶点访问序列恰为其各个连通分量的顶点集。</p>
<p>设 $E(G)$ 为连通图 $G$ 中所有边的集合，则从图中任一顶点出发遍历图时，必定将 $E(G)$ 分成两个集合 $T(G)$ 和 $B(G)$，其中 $T(G)$ 是遍历图过程中历经的边的集合；$B(G)$ 是剩余的边的集合。显然，$T(G)$ 和图 $G$ 中所有顶点一起构成连通图 $G$ 的 <strong>极小连通子图</strong>，它是连通子图的一棵生成树，并且称由 深度优先搜索 得到的为 <strong>深度优先生成树</strong>，由 广度有线搜索 得到的为 <strong>广度优先生成树</strong>。</p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206212931462.png" class title="image-20231206212931462">

<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206213022944.png" class title="image-20231206213022944">

<p>对于非连通分量，每个连通分量中的顶点集，和遍历时走过的边一起构成若干棵生成树，这些连通分量的生成树组成非连通图的生成森林。</p>
<p>生成非连通图的深度优先生成森林：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSForest</span><span class="params">(Graph G, CSTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 建立无向图G的深度优先生成森林的</span></span><br><span class="line">    <span class="comment">// (最左)孩子(右)兄弟链表 T</span></span><br><span class="line">    T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v&lt;G.vexnum; ++v)</span><br><span class="line">        visited[v] = FALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v&lt;G.vexnum; ++v)</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])&#123;	<span class="comment">// 第v顶点为新的生成树的根结点</span></span><br><span class="line">            p = (CSTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(CSNode)); <span class="comment">// 分配根结点</span></span><br><span class="line">            *p = &#123;<span class="built_in">GetVex</span>(G, v), <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;; <span class="comment">// 给该结点赋值</span></span><br><span class="line">            <span class="keyword">if</span>(!T) T = p;				<span class="comment">// 是第一棵生成树的根</span></span><br><span class="line">            <span class="keyword">else</span> q-&gt;nextsibling = p; 	<span class="comment">// 是其他生成树的根</span></span><br><span class="line">            q = p;						<span class="comment">// q 指示当前生成树的根</span></span><br><span class="line">            <span class="built_in">DFSTree</span>(G, v, p);			<span class="comment">// 建立以p为根的生成树</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125; <span class="comment">// DFSForest</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTree</span><span class="params">(Graph G, <span class="type">int</span> v, CSTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从第 v 个顶点出发深度优先搜索遍历图G，建立以T为根的生成树</span></span><br><span class="line">    visited[v] = TRUE; first = TRUE;</span><br><span class="line">    <span class="keyword">for</span>(w = <span class="built_in">FIrstAdjVex</span>(G, v); v&gt;=<span class="number">0</span>; w = <span class="built_in">NextAdjVex</span>(G,v,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">            p = (CSTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(CSNode)); <span class="comment">// 分配孩子结点</span></span><br><span class="line">            *p = &#123;<span class="built_in">GetVex</span>(G,w), <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span>(first)&#123;			<span class="comment">// w是v的第一个未被访问的邻接顶点</span></span><br><span class="line">                T-&gt;lchild = p;  <span class="comment">// 是根的左孩子结点</span></span><br><span class="line">                first = FALSE;</span><br><span class="line">			&#125; <span class="comment">// if</span></span><br><span class="line">            <span class="keyword">else</span>&#123;				<span class="comment">// w是v的其他未被访问的邻接顶点</span></span><br><span class="line">                q-&gt;nextsibling = p; <span class="comment">// 是上一邻接顶点的右兄弟结点</span></span><br><span class="line">            &#125; <span class="comment">// else</span></span><br><span class="line">            q = p;</span><br><span class="line">            <span class="built_in">DFSTree</span>(G, w, q); <span class="comment">// 从第w个顶点出发深度优先遍历图G，建立子生成树</span></span><br><span class="line">        &#125; <span class="comment">// if</span></span><br><span class="line">&#125; <span class="comment">// DFSTree</span></span><br></pre></td></tr></table></figure></div>



<h3 id="7-4-2-有向图的强连通分量"><a href="#7-4-2-有向图的强连通分量" class="headerlink" title="7.4.2 有向图的强连通分量"></a>7.4.2 有向图的强连通分量</h3><p>求有向图 G 的强连通分量的基本步骤是：</p>
<p>（1）对 G 进行深度优先遍历，生成 G 的 <strong>深度优先生成森林</strong> T</p>
<p>（2）对森林 T 的顶点按 <strong>中序遍历</strong> 顺序进行编号</p>
<p>（3）改变 G 中每一条弧的方向，构成一个新的有向图 G’</p>
<p>（4）按（2）中标出的顶点编号，从<strong>编号最大的顶点</strong>开始对G’进行<strong>深度优先搜索</strong>，得到一棵深度优先生成树。<br>若一次完整的搜索过程没有遍历G’的所有顶点，则从未访问的顶点中选择一个<strong>编号最大的顶点</strong>，由它开始再进行深度优先搜索，并得到另一棵深度优先生成树。<br>在该步骤中，每一次深度优先搜索所得到的生成树中的顶点就是G的一个强连通分量的所有顶点。</p>
<p>（5）重复步骤（4），直到 G’ 所有顶点都被访问。</p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206215457461.png" class title="image-20231206215457461">

<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connected_DG</span><span class="params">(OLGraph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>, v, j;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v&lt;G-&gt;vexnum; v++)</span><br><span class="line">        visited[v] = FALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v&lt;G-&gt;vexnum; v++)</span><br><span class="line">        <span class="keyword">if</span>(!visited[v]) <span class="built_in">DFS</span>(G,v);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v&lt;G-&gt;vexnum; v++)</span><br><span class="line">        visited[v] = FALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(j = G-&gt;vexnum<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        v = in_order[j];</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n第%d个连通分量顶点:&quot;</span>,k++);</span><br><span class="line">            <span class="built_in">Rev_DFS</span>(G,v);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(OLGraph*G,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArcNode* p;</span><br><span class="line">    Count = <span class="number">0</span>;</span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    <span class="keyword">for</span>(p = G-&gt;xlist[v].firstout; p != <span class="literal">NULL</span>; p = p-&gt;tlink)</span><br><span class="line">        <span class="keyword">if</span>(!visited[p-&gt;headvex])</span><br><span class="line">            <span class="built_in">DFS</span>(G, p-&gt;headvex);</span><br><span class="line">    in_order[count++] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rev_DFS</span><span class="params">(OLGraph *G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,v);</span><br><span class="line">    <span class="keyword">for</span>(p = G-&gt;xlist[v].firstin; p!=<span class="literal">NULL</span>; p = p-&gt;hlink)</span><br><span class="line">        <span class="keyword">if</span>(!visited[p-&gt;tailvex])</span><br><span class="line">            <span class="built_in">Rev_DFS</span>(G,p-&gt;tailvex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>❗ <strong>tarjan 算法</strong></p>
<h3 id="7-4-3-最小生成树"><a href="#7-4-3-最小生成树" class="headerlink" title="7.4.3 最小生成树"></a>7.4.3 最小生成树</h3><ul>
<li>如果连通图是一个带权图，则其生成树中的边也带权，生成树中所有边的权值之和称为生成树的代价。</li>
<li>最小生成树：<strong>带权连通图中代价最小的生成树</strong> 称为最小生成树</li>
</ul>
<p>构造最小生成树的算法，基本原则：</p>
<ul>
<li>尽可能选取权值最小的边，但不能构成回路</li>
<li>选择 n-1 条边构成最小生成树</li>
</ul>
<p>Kruskal 算法，是用来寻找最小生成树的算法。</p>
<p>Prim 算法，可在加权连通图里搜索最小生成树。</p>
<h4 id="Kruskal-算法思想"><a href="#Kruskal-算法思想" class="headerlink" title="Kruskal 算法思想"></a>Kruskal 算法思想</h4><ul>
<li>设有一个有 $n$ 个顶点的连通网络 $N&#x3D;{V,E}$ ，最初先构造只有 $n$ 个顶点，没有边的非连通图 $T &#x3D; {V,\varnothing}$ ，图中每个项目自成一个连通分量。</li>
<li>在 $E$ 中选到一条具有 <strong>最小权值的边</strong> 时，若该边的两个顶点落在不同的连通分量上，则将此边加入到 $T$ 中。</li>
<li>否则将此边舍弃，重新选择一条权值最小的边。</li>
<li>如此重复下去，知道所有顶点在同一连通分量上为止。</li>
</ul>
<p>算法的关键：</p>
<ul>
<li>如何判断边 e 所连接的两个节点 v 和 u 在不同的一棵树上</li>
<li>如何把两个节点 u 和 v 所在的树合并为一棵树</li>
</ul>
<p>适合边比较稀疏的情况</p>
<p>并查集</p>
<p>树如何合并的问题，属于子集归并的并查集问题</p>
<p>并查集的子集合并运算，即要合并两个元素所属的子集</p>
<h4 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h4><p>基本思想：</p>
<ul>
<li>从连通网络 $N &#x3D; {V,E}$ 中的某一顶点 $u_0$ 出发，选择与它关联的具有最小权值的边 $(u_0,v)$ ，将其顶点加入到生成树顶点集合 U 中。</li>
<li>以后每一步从一个顶点在 U 中，而另一个顶点不在 U 中的各条边中选择权值最小的边 $(u,v)$ ，把它的顶点加入到集合 $U$ 中。如此下去，知道所有顶点都加入到生成树集合 $U$ 中。</li>
</ul>
<p>设置两个辅助数组：</p>
<ul>
<li><code>lowcost[]</code> ：存放生成树顶点集合内顶点到生成树外各顶点的各边上的当前最小权值。</li>
<li><code>nearvex[]</code> ：记录生成树顶点集合外各顶点距离集合内哪个顶点最近 (即权值最小)</li>
</ul>
<p>适合顶点数量少的情况</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MiniSpanTree_PRIM</span><span class="params">(MGraph G, VertexType u)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 用 prim 算法从第 u 个顶点出发构造网G的最小生成树T,输出T的各条边</span></span><br><span class="line">    <span class="comment">// 记录从顶点集U到V-U的代价最小的边的辅助数组定义:</span></span><br><span class="line">    <span class="comment">//struct&#123;</span></span><br><span class="line">    <span class="comment">//	VertexType adjvex;</span></span><br><span class="line">    <span class="comment">//	VRType lowcost;</span></span><br><span class="line">	<span class="comment">//&#125;closedge[MAX_VERTEX_NUM];</span></span><br><span class="line">    </span><br><span class="line">    k = <span class="built_in">LocateVex</span>(G,u);</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;G.vexnum; ++j)		<span class="comment">// 辅助数组初始化</span></span><br><span class="line">        <span class="keyword">if</span>(j!=k)</span><br><span class="line">            closedge[j]=&#123;u,G.arcs[k][j].adj&#125;; <span class="comment">// &#123;adjvex, lowcost&#125;</span></span><br><span class="line">    </span><br><span class="line">    closedge[k].lowcost = <span class="number">0</span>;		<span class="comment">// 初始, U=&#123;u&#125;</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;G.vexnum; ++i)&#123;		<span class="comment">// 选择其余 G.vexnum-1 个顶点</span></span><br><span class="line">        k = <span class="built_in">minimum</span>(closedge);		<span class="comment">// 求出T的下一个结点: 第k顶点</span></span><br><span class="line">        <span class="comment">// 此时 closedge[k].lowcost =</span></span><br><span class="line">  <span class="comment">//MIN&#123;closedge[vi].lowcost|closedge[vi].lowcost &gt;0,vi∈V-U&#125;</span></span><br><span class="line">        <span class="built_in">printf</span>(closedge[k].adjvex, G.vexs[k]);  <span class="comment">// 输出生成树的边</span></span><br><span class="line">        closedge[k].lowcost = <span class="number">0</span>;	<span class="comment">// 第k顶点并入U集</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;G.vernum; ++j)</span><br><span class="line">            <span class="keyword">if</span>(G.arcs[k][j].adj &lt; closedge[j].lowcost)	<span class="comment">// 新顶点并入U后重新选择最小边</span></span><br><span class="line">                closedge[j] = &#123;G.vexs[k], G.arcs[k][j].adj&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// MiniSpanTree</span></span><br></pre></td></tr></table></figure></div>



<h3 id="7-4-4-关节点和重连通分量"><a href="#7-4-4-关节点和重连通分量" class="headerlink" title="7.4.4 关节点和重连通分量"></a>7.4.4 关节点和重连通分量</h3><p>假若在删去顶点 $v$ 以及和 $v$ 相关联的各边之后，将图的一个连通分量分割成两个或两个以上的连通分量，则称顶点 $v$ 为该图的一个 <strong>关节点</strong>。一个没有关节点的连通图为 <strong>重连通图</strong>。</p>
<p>利用深度优先搜索便可求得图的关节点，并由此判断图是否重连通的。</p>
<p>由深度优先生成树可得出两类关节点的特性：</p>
<p>（1）若生成树的根有两棵或两棵以上的子树，则此根顶点必为关节点。</p>
<p>（2）若生成树中某个非叶子顶点 $v$，其某棵子树的根和子树中其他结点均没有指向 $v$ 的祖先的回边，则 $v$ 为关节点。</p>
<h2 id="7-5-有向无环图及其应用"><a href="#7-5-有向无环图及其应用" class="headerlink" title="7.5 有向无环图及其应用"></a>7.5 有向无环图及其应用</h2><p>一个无环的有向图称做 <strong>有向无环图</strong>，简称 DAG图。DAG图是一类较有向树更一般的特殊有向图。</p>
<h3 id="7-5-1-拓扑排序"><a href="#7-5-1-拓扑排序" class="headerlink" title="7.5.1 拓扑排序"></a>7.5.1 拓扑排序</h3><p><strong>拓扑排序</strong>：由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为 拓扑排序。</p>
<blockquote>
<p>偏序关系：集合X上的关系R是自反的、反对称的和传递的<br>设 R 是集合X上的 <strong>偏序</strong> ，如果对每个 $x,y\in X$ 必有 $xRy$ 或 $yRx$，则称 $R$ 是集合 $X$ 上的全序关系</p>
</blockquote>
<p>偏序指的是集合中仅有部分成员之间可比较，全序是指集合中全体成员之间均可比较。</p>
<p>例如：下图两个有向图，图中弧$&lt;x,y&gt;$ 表示 $x\leqslant y$，则(a)表示偏序，(b)表示全序</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231207002833708.png" alt="image-20231207002833708" style="zoom: 50%;">

<p>若在(a)的有向图上人为地加一个表示 $v_2\leqslant v_3$ 的弧（符号“$\leqslant$”表示 $v2$ 领先于 $v3$），则(a) 表示的亦为全序，且这个全序称为 <strong>拓扑有序</strong>，而由偏序定义得到拓扑有序的操作便是 <strong>拓扑排序</strong>。</p>
<p><strong>例</strong> 一个软件专业学生必须学习一系列基本课程，其中有些是基础课，独立于其他课程，而另一些课程必须在学完作为它的基础的先修课程才能开始。下图中，把顶点表示课程，有向边（弧）表示先决条件。若课程 $i$ 是课程 $j$ 的先决条件，则有弧 $&lt;i,j&gt;$</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231207003715136.png" alt="image-20231207003715136" style="zoom:33%;">



<p>这种用 顶点表示活动，用弧表示活动间的优先关系的有向图称为顶点表示活动的网，简称 AOV-网。</p>
<p><strong>拓扑排序-算法思想</strong></p>
<p>（1）在有向图中选一个没有前驱的顶点且输出之</p>
<p>（2）从图中删除该顶点和所有以它为尾的弧</p>
<p>重复上述两步，直至全部顶点均已输出，或者当前图中不存在无前驱的顶点为止（说明有向图中存在环）。</p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231207101130506.png" class title="image-20231207101130506">

<p>为了避免重复检测入度为0的顶点，可另设</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TopologicalSort</span><span class="params">(ALGraph G)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 有向图G采用邻接表存储结构</span></span><br><span class="line">    <span class="comment">// 若G无回路，则输出G的顶点的一个拓扑序列并返回OK,否则ERROR</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对各顶点求入度 indegree[0...vernum-1]</span></span><br><span class="line">    <span class="built_in">FindInDegree</span>(G, indegree);		</span><br><span class="line">    <span class="built_in">InitStack</span>(S);					<span class="comment">// 建零入读顶点栈S</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;G.vexnum; ++i)		</span><br><span class="line">        <span class="keyword">if</span>(!indegree[i]) <span class="built_in">Push</span>(S,i);	<span class="comment">// 入度为0者进栈</span></span><br><span class="line">    count = <span class="number">0</span>;						<span class="comment">// 对输出顶点计数</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(S))&#123;</span><br><span class="line">        <span class="built_in">Pop</span>(S,i);</span><br><span class="line">        <span class="built_in">printf</span>(i, G.vertices[i].data); <span class="comment">// 输出 i 号顶点并计数</span></span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[i].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">            k = p-&gt;adjvex;		</span><br><span class="line">            <span class="comment">// 对i号顶点的每个邻接点的入度-1</span></span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[k])) <span class="built_in">Push</span>(S,k);	<span class="comment">// 入度减为0，则入栈</span></span><br><span class="line">        &#125; <span class="comment">// for</span></span><br><span class="line">    &#125; <span class="comment">// while</span></span><br><span class="line">    <span class="keyword">if</span>(count &lt; G.vernum) <span class="keyword">return</span> ERROR;		<span class="comment">// 该有向图有回路</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// TopologicalSort</span></span><br></pre></td></tr></table></figure></div>



<h3 id="7-5-2-关键路径"><a href="#7-5-2-关键路径" class="headerlink" title="7.5.2 关键路径"></a>7.5.2 关键路径</h3><p>与 <strong>AOV-网</strong> 相对应的是 <strong>AOE-网</strong> ，即边表示活动的网。 AOE-网 是一个带权的有向无环图，其中 <strong>顶点</strong> 表示 事件，弧 表示 活动，权 表示活动持续的时间。通常，AOE-网 可用来估算工程的完成时间。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20231207103226348.png" alt="image-20231207103226348" style="zoom:50%;">

<p>例如，上图是一个假想的有11项活动的AOE-网。其中有 9 个事件 $v_1,v_2,v_3,\cdots,v_9$，每个事件表示在它之前的活动已经完成，在它之后的活动可以开始。由于整个工程只有一个开始点和一个完成点，故在正常的情况（无环）下，网中只有一个入度为零的点（称作<strong>源点</strong>）和一个出度为零的点（叫做<strong>汇点</strong>）。</p>
<p>AOE-网有待研究的问题是：（1）完成整项工程至少需要多少时间？（2）哪些活动是影响工程进度的关键？</p>
<p>活动可以并行进行，故 <strong>完成工程的最短时间</strong> 是从开始点到完成点的 <strong>最长路径的长度</strong>（这里说的路径长度是指路径上各活动持续时间之和)。路径长度最长的路径叫做 <strong>关键路径</strong>。</p>
<ul>
<li>事件 $v_i$ 的最早发生时间：从 $v_1$（设为开始点） 到 $v_i$ 的最长路径长度。这个时间决定了 所有以 $v_i$ 为尾的弧所表示的活动的最早开始时间。</li>
<li>$e(i)$：活动 $a_i$ 的最早开始时间</li>
<li>$l(i)$：活动的最迟开始时间，这是在推迟整个工程完成的前提下，活动 $a_i$ 最迟必须开始进行的时间。</li>
<li>两者之差 $l(i)-e(i)$ 表示活动 $a_i$ 的时间余量。</li>
<li>把 $l(i) &#x3D; e(i)$ 的活动叫做 <strong>关键活动</strong>。</li>
</ul>
<p><strong>关键路径上的所有活动都是关键活动</strong>，因此提前完成非关键活动并不能加快工程的进度。辨别关键活动就是要找到 $e(i)&#x3D;l(i)$ 的活动。为了求得 AOE-网中活动的 $e(i)$ 和 $l(i)$。首先应求得事件的<strong>最早发生时间</strong> $ve(j)$ 和<strong>最迟发生时间</strong> $vl(j)$。如果活动$a_i$ 由弧 $&lt;j,k&gt;$ 表示，其<strong>持续时间</strong>记为 $dut(&lt;j,k&gt;)$，则有如下关系：<br>$e(i) &#x3D; ve(j)$，$l(i) &#x3D; vl(k)-dut(&lt;j,k&gt;)$ 。</p>
<p>求 $ve(j)$ 和 $vl(j)$ 需分两步进行：</p>
<p>（1）从 $ve(0) &#x3D; 0$ 开始向前递推：$ve(j) &#x3D; \mathrm{Max}{ve(i)+dut(&lt;i,j&gt;)}$，$&lt;i,j&gt;\in T,j&#x3D;1,2,\cdots,n-1$。其中，$T$ 是所有以第 $j$ 个顶点为头的弧的集合。</p>
<p>（2）从 $vl(n-1)&#x3D;ve(n-1)$ 起向后递推：$ve(i) &#x3D; \mathrm{Max}{ve(j)+dut(&lt;i,j&gt;)}$，$&lt;i,j&gt;\in S,i&#x3D;n-2,\cdots,0$。其中，$S$ 是所有以第 $i$ 个顶点为尾的弧的集合。</p>
<p>这两个递推公式的计算必须分别在拓扑有序和逆拓扑有序的前提下进行。</p>
<p><strong>AOE-网求关键路径和关键活动的算法</strong></p>
<p>（1）输入 $e$  条弧 $&lt;j,k&gt;$，建立 AOE-网的存储结构</p>
<p>（2）从源点 $v_0$ 出发，令 $ve[0] &#x3D; 0$，按拓扑有序求其余各顶点的最早发生时间 $ve[i](1\leqslant i \leqslant n-1)$。如果得到拓扑有序中的顶点个数小于网中定点数 $n$ ，则说明网中存在环，不能求关键路径，算法终止，否则执行步骤（3）</p>
<p>（3）从汇点 $v_n$ 出发，令 $vl[n-1]&#x3D;ve[n-1]$，按 逆拓扑有序求其余各顶点的最迟发生时间 $vl[i](n-1\geqslant i \geqslant 2)$ ；</p>
<p>（4）根据各顶点的 $ve$ 和 $vl$ 值，求每条弧 $s$ 的最早开始时间 $e(s)$ 和 最迟开始时间 $l(s)$。若某条弧满足 $e(s) &#x3D; l(s)$，则为关键活动。</p>
<p>计算各顶点的 $ve$ 值是在拓扑排序的过程中进行的，需对拓扑排序的算法作如下修改：（a）在拓扑排序之前设初值，令 $ve[i] &#x3D; 0(0\leqslant i \leqslant n-1)$；（b）在算法中增加一个计算 $v_j$ 的直接后继 $v_k$ 的最早发生时间的操作：若 $ve[j]+dut(&lt;j,k&gt;)&gt;ve[k]$，则 $ve[k] &#x3D; ve[j]+dut(&lt;j,k&gt;)$；（c）为了能逆拓扑有序序列的顺序计算各顶点的 $vl$ 值，需要记下在拓扑排序过程中求得的拓扑有序序列，这需要在拓扑算法中，增设一个栈以记录拓扑有序序列，则在计算求得各顶点的 $ve$ 值之后，从栈顶到栈底便为逆拓扑有序序列。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TopologicalOrder</span><span class="params">(ALGraph G, Stack &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 有向网G采用邻接表存储结构，求各顶点时间的最早发生时间 ve(全局变量)</span></span><br><span class="line">    <span class="comment">// T 为拓扑序列顶点栈, S 为零入度顶点栈</span></span><br><span class="line">    <span class="comment">// 若G无回路,则用栈T返回G的一个拓扑序列，且函数值为 OK,否则为 ERROR</span></span><br><span class="line">    <span class="built_in">FindInDegree</span>(G,indegree);<span class="comment">// 对各顶点求入度indegree[vernum-1]</span></span><br><span class="line">    <span class="comment">// 建 零入度顶点栈S</span></span><br><span class="line">    <span class="built_in">InitStack</span>(T); count = <span class="number">0</span>; ve[<span class="number">0.</span>.G.vexnum<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(S))&#123;</span><br><span class="line">        <span class="built_in">Pop</span>(S,j); <span class="built_in">Push</span>(T, j); ++count;</span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[j].firstarc; p; p = p-&gt;nextarc)&#123;</span><br><span class="line">            k = p-&gt;adjvex;	</span><br><span class="line">            <span class="comment">// 对j号顶点的每个邻接点的入度-1</span></span><br><span class="line">            <span class="keyword">if</span>(--indegree[k] == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">Push</span>(S,k);	<span class="comment">// 若入度减为0，则入栈</span></span><br><span class="line">            <span class="keyword">if</span>(ve[j] + *(p-&gt;info) &gt; ve[k])</span><br><span class="line">                ve[k] = ve[j]+*(p-&gt;info); </span><br><span class="line">            <span class="comment">// *(p-&gt;info)=dut(&lt;i,j&gt;)</span></span><br><span class="line">        &#125; <span class="comment">// for</span></span><br><span class="line">    &#125; <span class="comment">// while</span></span><br><span class="line">    <span class="keyword">if</span>(count &lt; G.vexnum) <span class="keyword">return</span> ERROR; <span class="comment">// 该有向网有回路</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// TopologicalOrder</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CriticalPath</span><span class="params">(ALGraph G)</span></span>&#123;</span><br><span class="line">    <span class="comment">// G 为有向网, 输出G的各项关键活动</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">TopologicalOrder</span>(G,T)) <span class="keyword">return</span> ERROR;</span><br><span class="line">    vl[<span class="number">0.</span>.G.vexnum<span class="number">-1</span>] = ve[G.vexnum<span class="number">-1</span>]; <span class="comment">//初始化时间的最迟发生时间</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">StackEmpty</span>(T))&#123;	<span class="comment">// 按 拓扑逆序求各顶点的 vl 值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">Pop</span>(T,j), p = G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">            k=p-&gt;adjvex;</span><br><span class="line">            dut = *(p-&gt;info);</span><br><span class="line">            <span class="keyword">if</span>(vl[k]-dut &lt; vl[j])</span><br><span class="line">                vl[j] = vl[k]-dut;</span><br><span class="line">        &#125; <span class="comment">// for</span></span><br><span class="line">    &#125; <span class="comment">// while</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 逐个打印关键</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;G.vexnum; ++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">            k = p-&gt;adjvex; dut = *(p-&gt;info);</span><br><span class="line">            ee = ve[j]; el = vl[k]-dut;</span><br><span class="line">            tag = (ee==el)?<span class="string">&#x27;*&#x27;</span>:<span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string">            printf(j,k,dut,ee,el,tag);	// 输出关键活动</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125; // CriticalPath</span></span><br></pre></td></tr></table></figure></div>



<p><strong>算法分析</strong></p>
<p>设AOE网有n个事件，e个活动，则算法的主要执行是：</p>
<ul>
<li>进行拓扑排序：时间复杂度是O(n+e)</li>
<li>求每个事件的ve值和vl值：时间复杂度是O(n+e) </li>
<li>根据ve值和vl值找关键活动：时间复杂度是O(n+e)</li>
</ul>
<p>据ve值和vl值找关键活动：时间复杂度是O(n+e)</p>
<h2 id="7-6-最短路径问题"><a href="#7-6-最短路径问题" class="headerlink" title="7.6 最短路径问题"></a>7.6 最短路径问题</h2><h3 id="7-6-1-从某个源点到其余各顶点的最短路径"><a href="#7-6-1-从某个源点到其余各顶点的最短路径" class="headerlink" title="7.6.1 从某个源点到其余各顶点的最短路径"></a>7.6.1 从某个源点到其余各顶点的最短路径</h3><p>单源点的最短路径问题：给定带权有向图 $G$ 和 源点 $v$，求从 $v$ 到 $G$ 中其余各顶点的最短路径。</p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231206232532102.png" class title="image-20231206232532102">

<p>Dijkstra 算法</p>
<p>解决问题：<strong>单源点的最短路径</strong></p>
<blockquote>
<p>其主要思想是贪心，具体地说：</p>
<ul>
<li><p>将所有节点分成两类：<strong>已确定从起点到当前点的最短路长度的节点</strong>，以及<strong>未确定从起点到当前点的最短路长度的节点</strong>（下面简称「未确定节点」和「已确定节点」）。</p>
</li>
<li><p>每次从「<strong>未确定节点</strong>」中<strong>取一个与起点距离最短的点</strong>，将它归类为「<strong>已确定节点</strong>」，并用它「<strong>更新</strong>」从起点到其他所有「<strong>未确定节点</strong>」的距离。<strong>直到所有点都被归类为「已确定节点」</strong>。</p>
</li>
<li><p>用节点 A「<strong>更新</strong>」节点 B 的意思是，用 起点到节点 A 的最短路长度 加上 从节点 A 到节点 B 的边的长度，去比较 起点到节点 B 的最短路长度，如果前者小于后者，就用前者更新后者。这种操作也被叫做「<strong>松弛</strong>」。</p>
</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(MGraph G, <span class="type">int</span> v0, PathMatrix &amp;P, ShortPathTable &amp;D)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 用 Dijkstra 算法求有向网G的v0顶点到其余顶点v的最短路径P[v]及其带权长度D[v]</span></span><br><span class="line">    <span class="comment">// 若 P[v][w] 为TRUE,则w是从v0到v当前求得最短路径上的顶点</span></span><br><span class="line">    <span class="comment">// final[v] 为TRUE当且仅当 v∈S,即已经求得从v0到v的最短路径</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;G.vexnum; ++v)&#123;</span><br><span class="line">        <span class="keyword">final</span>[v] = FALSE;  D[v] = G.arcs[v0][v];</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>; w&lt;G.vexnum; ++w) P[v][w] = FALSE;</span><br><span class="line">        <span class="keyword">if</span>(D[v]&lt;INFINITY) &#123;P[v][v0] = TRUE; P[v][v] = TRUE;&#125;</span><br><span class="line">    &#125; <span class="comment">// for</span></span><br><span class="line">    D[v0] = <span class="number">0</span>; <span class="keyword">final</span>[v0] = TRUE;  	<span class="comment">// 初始化,v0顶点属于S集</span></span><br><span class="line">    <span class="comment">// 开始主循环，每次求得v0到某个v顶点的最短路径,并加v到S集</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;G.vexnum; ++i)&#123;	  	<span class="comment">// 其余 G.vexnum-1 个顶点</span></span><br><span class="line">        min = INFINITY;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>; w&lt;G.vexnum; ++w)</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">final</span>[w])			<span class="comment">// w顶点在V-S中</span></span><br><span class="line">                <span class="keyword">if</span>(D[w]&lt;min)&#123;v=w; min = D[w];&#125; <span class="comment">// w顶点离v0顶点最近</span></span><br><span class="line">        <span class="keyword">final</span>[v] = TRUE;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>; w&lt;G.vexnum; ++w)  	<span class="comment">// 更新当前最短路径及距离</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">final</span>[w] &amp;&amp; (min+G.arcs[v][w]&lt;D[w]))&#123;	<span class="comment">// 修改D[w]和P[w],w∈V-S</span></span><br><span class="line">                D[w] = min+G.arcs[v][w];</span><br><span class="line">                P[w] = P[v];</span><br><span class="line">                p[w][w] = TRUE;  	<span class="comment">// P[w] = p[v]+[w]</span></span><br><span class="line">            &#125; <span class="comment">// if</span></span><br><span class="line">    &#125; <span class="comment">// for</span></span><br><span class="line">&#125; <span class="comment">// ShortestPath_DIJ</span></span><br></pre></td></tr></table></figure></div>



<h3 id="7-6-2-每一对顶点之间的最短路径"><a href="#7-6-2-每一对顶点之间的最短路径" class="headerlink" title="7.6.2 每一对顶点之间的最短路径"></a>7.6.2 每一对顶点之间的最短路径</h3><p>形式简单的算法：Floyd 算法。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath_FLOYD</span><span class="params">(MGraph G, PathMatrix &amp;P[], DistancMatrix &amp;D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Floyd 算法求有向网G中各对顶点v和w之间的最短路径P[v][w]及其带权长度 D[v][w]</span></span><br><span class="line">    <span class="comment">// 若P[v][w][u]为TRUE,则u是从v到w当前求得最短路径上的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;G.vexnum; ++v)			<span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>; w&lt;G.vexnum; ++v)&#123;</span><br><span class="line">            D[v][w] = G.arcs[v][w];</span><br><span class="line">            <span class="keyword">for</span>(u=<span class="number">0</span>;u&lt;G.vexnum;++u)</span><br><span class="line">                P[v][w][u] = FALSE;</span><br><span class="line">            <span class="keyword">if</span>(D[v][w]&lt;INFINITY)&#123;		<span class="comment">// 从v到w有直接路径</span></span><br><span class="line">                P[v][w][v] = TRUE;</span><br><span class="line">                P[v][w][w] = TRUE;</span><br><span class="line">            &#125; <span class="comment">// if</span></span><br><span class="line">        &#125; <span class="comment">// for</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(u=<span class="number">0</span>; u&lt;G.vexnum; ++u)			<span class="comment">// 中间点</span></span><br><span class="line">        <span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;G.vexnum; ++v)		<span class="comment">// 起点</span></span><br><span class="line">            <span class="keyword">for</span>(w=<span class="number">0</span>; w&lt;G.vexnum; ++w)	<span class="comment">// 终点</span></span><br><span class="line">                <span class="keyword">if</span>(D[v][u]+D[u][w]&lt;D[v][w])&#123;</span><br><span class="line">                    D[v][w] = D[v][u]+D[u][w];</span><br><span class="line">                    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum; ++i)</span><br><span class="line">                        P[v][w][i] = P[v][u][i]||P[u][w][i];</span><br><span class="line">                &#125; <span class="comment">// if</span></span><br><span class="line">&#125; <span class="comment">// ShortestPath_FLOYD</span></span><br></pre></td></tr></table></figure></div>



<h1 id="第9章-查找"><a href="#第9章-查找" class="headerlink" title="第9章 查找"></a>第9章 查找</h1><ul>
<li><p>关键字（Key）：数据元素（或记录）中某个数据项的值，用它可以识别一个数据元素（或记录）</p>
</li>
<li><p>查找（Searching）：根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的记录，则称查找是成功的。</p>
</li>
<li><p>查找表（查找结构）：用于查找的数据集合，由同一类型的数据元素组成。</p>
<p>对查找表经常进行的一般操作：</p>
<ol>
<li>查询某个特定数据元素是否在查找表中</li>
<li>检索满足条件的某个特定的数据元素的各种属性</li>
<li>在查找表中插入一个数据元素</li>
<li>从查找表中删除某个数据元素</li>
</ol>
</li>
<li><p>静态查找表：查找表的操作只涉及查询和检索。</p>
<p>查找方法：顺序查找、折半查找、散列查找等。</p>
</li>
<li><p>动态查找表：需要动态地插入或删除的查找表。</p>
<p>查找方法：二叉排序树的查找、散列查找等。</p>
</li>
<li><p>查找算法在查找成功时的 <strong>平均查找长度</strong></p>
<p>对于含有 n 个记录的表，查找成功时的平均查找长度为<br>$$<br>ASL &#x3D; \sum_{i&#x3D;1}^nP_iC_i<br>$$<br>其中：$P_i$ 为查找表中第 i 个记录的概率，且 $\sum_{i&#x3D;1}^nP_i &#x3D; 1$ </p>
<p>$C_i$ 为找到表中其关键字与给定值相等的第 i 个记录时，和给定值已进行过比较的关键字个数。</p>
</li>
<li><p>典型的关键字类型和数据元素类型：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* KeyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    KeyType key;	<span class="comment">// 关键字域</span></span><br><span class="line">    ...				<span class="comment">// 其他域</span></span><br><span class="line">&#125;SElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数值型关键字的比较</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EQ(a,b) ((a) == (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LT(a,b) ((a) &lt;  (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LQ(a,b) ((a) &lt;= (b))</span></span><br><span class="line"><span class="comment">// 对字符串型关键字的比较</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EQ(a,b) (!strcmp((a),(b)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LT(a,b) (strcmp((a), (b)) &lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LQ(a,b) (strcmp((a), (b)) &lt;= 0)</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="9-1-静态查找表"><a href="#9-1-静态查找表" class="headerlink" title="9.1 静态查找表"></a>9.1 静态查找表</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADT StaticSearchTable&#123;</span><br><span class="line">    <span class="built_in">Create</span>(&amp;ST, n);</span><br><span class="line">    <span class="built_in">Destroy</span>(&amp;ST);</span><br><span class="line">    <span class="built_in">Search</span>(ST, key);</span><br><span class="line">    <span class="built_in">Traverse</span>(ST, <span class="built_in">Visit</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="9-1-1-顺序查找"><a href="#9-1-1-顺序查找" class="headerlink" title="9.1.1 顺序查找"></a>9.1.1 顺序查找</h3><p>又称线性查找。对顺序表和链表都适用。</p>
<p>1.一般线性表的顺序查找</p>
<p>作为一种最直观的查找方法，其基本思想是从线性表的一端开始，逐个检查关键字是否满足给定的条件。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;			<span class="comment">// 查找表的数据结构</span></span><br><span class="line">    ElemType* elem;		<span class="comment">// 元素存储空间基址，建表时按实际长度分配，0号单元留空</span></span><br><span class="line">    <span class="type">int</span> TableLen;		<span class="comment">// 表的长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, ElemType key)</span></span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>] = key;									<span class="comment">// 哨兵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = ST.TableLen; ST.elem[i] != key; --i);	<span class="comment">// 从后往前找</span></span><br><span class="line">    <span class="keyword">return</span> i;	<span class="comment">// 若表中不存在关键字为 key 的元素，将查找到i为0时退出for循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上述算法中，将 ST.elem[0] 称为哨兵，引入它的目的是使得 Search_Seq 内的循环不必判断数组是否会越界。引入“哨兵”可以避免很多不必要的判断语句，从而提高程序效率。</p>
<p>顺序表查找的平均查找长度（各记录查找概率相等情况下）：<br>$$<br>ASL_{SS} &#x3D; \cfrac{n+1}2<br>$$</p>
<p>查找不成功的比较次数显然是 $n+1$ 次。</p>
<ol start="2">
<li>有序表的顺序查找</li>
</ol>
<p>有序线性表的顺序查找中，查找成功的平均查找长度和一般线性表的顺序查找一样。</p>
<p>查找失败的平均查找长度在相等查找概率的情形下为<br>$$<br>ASL_{不成功} &#x3D; \sum_{j&#x3D;1}^n q_j(l_j-1) &#x3D; \cfrac{1+2+\cdots+n+n}{n+1} &#x3D; \cfrac{n}2+\cfrac{n}{n+1}<br>$$<br>式中，$q_j$ 是达到第 $j$ 个失败结点的概率，在相等查找概率的情形下，它为 $1&#x2F;(n+1)$；$l_j$ 是第 $j$ 个失败结点所在的层数。</p>
<h3 id="9-1-2-折半查找"><a href="#9-1-2-折半查找" class="headerlink" title="9.1.2 折半查找"></a>9.1.2 折半查找</h3><p>折半查找，又称二分查找，它仅适用于有序的顺序表。</p>
<p>折半查找的基本思想：首先将给定值 key 与表中中间位置的元素比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_Search</span><span class="params">(SSTable L, ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = L.TableLen<span class="number">-1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid] &gt; key)</span><br><span class="line">            high = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>折半查找的过程可用二叉树来描述，称为 <strong>判定树</strong>。树中每个圆形结点表示一个记录，结点中的值为该记录的关键字值；树中最下面的叶节点都是方形的，它表示查找不成功的情况。</p>
<ul>
<li>查找成功时的查找长度为从根结点到目的节点的路径上的节点数</li>
<li>查找不成功时的查找长度为从根结点到对应失败结点的父结点的路径上的结点数。</li>
</ul>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240101165055003.png" class title="image-20240101165055003">

<p>【注】判定树也是二叉排序树，所以中序遍历的结果应该是有序的，且左子树的关键字值&lt;根结点关键字值&lt;右子树关键之值</p>
<p>查找成功的平均查找长度为<br>$$<br>\begin{eqnarray}    \label{eq}<br>ASL&amp;&#x3D;&amp;\cfrac1n\sum_{i&#x3D;1}^n l_i  &#x3D; \cfrac1n(1\times1+2\times2+\cdots+h\times2^{h-1})&#x3D;\cfrac{n+1}{n}\log_2(n+1)-1 \nonumber    \<br>~&amp;\approx&amp; \log_1(n+1)-1<br>\end{eqnarray}<br>$$<br>式中，h 是折半查找判定树的高度，并且，元素个数为 n 时树高 $h &#x3D; \lceil \log_2(n+1) \rceil$ 。所以，折半查找的时间复杂度为 $O(\log_2n)$</p>
<p>上图的判定树中，在等概率的情况下，查找成功（圆形结点）的 </p>
<p>$\mathrm{ASL_{成功}} &#x3D; (1\times1+2\times2+3\times4+4\times4)&#x2F;11&#x3D;3$</p>
<p>查找不成功（方形结点）的</p>
<p>$\mathrm{ASL_{失败}} &#x3D; (3\times4+4\times8)&#x2F;12&#x3D;11&#x2F;3$ </p>
<h3 id="9-1-3-分块查找"><a href="#9-1-3-分块查找" class="headerlink" title="9.1.3 分块查找"></a>9.1.3 分块查找</h3><p>分块查找，又称索引顺序查找。吸取了顺序查找和折半查找各自的优点，既有动态结构，又适合于快速查找。</p>
<p>分块查找的基本思想：将查找表分为若干子块。块内元素可以无序，但块间的元素是有序的。第一块中的最大关键字小于第二块中所有记录的关键字，以此类推。</p>
<p>分块查找的过程分为两步：第一步是在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表，第二步是在块内顺序查找。</p>
<p>分块查找的平均查找长度为索引查找和块内查找的平均长度之和。设索引查找和块内查找的平均查找长度分别为 $L_I$，$L_S$，则分块查找的平均查找长度为<br>$$<br>ASL &#x3D; L_I+L_S<br>$$<br>将长度为 n 的查找表均匀地分为 b 块，每块有 s 个记录，在等概率情况下，若在块内和索引表中均采用顺序查找，则平均查找长度为<br>$$<br>ASL &#x3D; L_I+L_S &#x3D; \cfrac{b+1}2+\cfrac{s+1}2 &#x3D; \cfrac{s^2+2s+n}{2s}<br>$$<br>此时，若 $s &#x3D; \sqrt{n}$ ，则平均查找长度取最小值 $\sqrt{n}+1$ </p>
<h2 id="9-2-动态查找表"><a href="#9-2-动态查找表" class="headerlink" title="9.2 动态查找表"></a>9.2 动态查找表</h2><h3 id="9-2-1-二叉排序树和平衡二叉树"><a href="#9-2-1-二叉排序树和平衡二叉树" class="headerlink" title="9.2.1 二叉排序树和平衡二叉树"></a>9.2.1 二叉排序树和平衡二叉树</h3><p><strong>二叉排序树</strong>，或者是一棵空树，或者是具有一下性质的二叉树：</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
<p>二叉排序树的查找：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">SearchBST</span><span class="params">(BiTree T, KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在根指针 T 所指二叉排序树中递归地查找某关键字等于 key 的数据元素</span></span><br><span class="line">    <span class="comment">// 若查找成功，则返回指向该数据元素结点的指针，否则返回空指针</span></span><br><span class="line">    <span class="keyword">if</span>(!T || <span class="built_in">EQ</span>(key, T-&gt;data.key)) <span class="keyword">return</span> (T);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">LT</span>(key, T-&gt;data.key) <span class="built_in">return</span> (<span class="built_in">SearchBST</span>(T-&gt;lchild, key));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">return</span> (<span class="built_in">SearchBST</span>(T-&gt;rchild, key));</span><br><span class="line">&#125; <span class="comment">// SearchBST</span></span><br></pre></td></tr></table></figure></div>



<p>二叉排序树的插入，在查找不成功时进行插入，插入的结点一定是一个新添加的叶子结点，并且查找不成功时候查找路径上访问的最后一个结点一定是新添加的左孩子或右孩子结点。要对上面的查找函数进行一些修改。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BiTree T, KeyType key, BiTree f, BiTree &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)&#123;p = f; <span class="keyword">return</span> FALSE;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">EQ</span>(key, T-&gt;data.key)) &#123;p = T; <span class="keyword">return</span> TRUE;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">LT</span>(key, T-&gt;data.key)) <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;lchild, key, T, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;rchild, key, T, p);</span><br><span class="line">&#125; <span class="comment">// SearchBST</span></span><br></pre></td></tr></table></figure></div>

<p>插入结点：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BiTree&amp;T, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">SearchBST</span>(T, e.key, <span class="literal">NULL</span>, p))&#123;</span><br><span class="line">        s = (BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p) T = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">LT</span>(e.key, p-&gt;data.key)) p-&gt;lchild = s;</span><br><span class="line">        <span class="keyword">else</span> p-&gt;rchild = s;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>二叉排序树既拥有类似于折半查找的特性，又采用链表作存储结构，因此是动态查找表的一个适宜表示。对于二叉排序树，删去树上一个结点相当于删去有序序列的一个记录，只要在删除某个结点之后依旧保持二叉排序树的特性即可。</p>
<p>删除结点的三种情况：（假设 *p 为被删除结点，其双亲结点为 *f，不失一般性，假设 *p 是 *f 的左孩子）</p>
<ol>
<li>若 *p 结点为叶子结点，即 $\mathrm{P_L}$ 和  $\mathrm{P_R}$ 均有空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。</li>
<li>若 *p 结点只有左子树  $\mathrm{P_L}$ 或者只有右子树  $\mathrm{P_R}$ ，此时只要令  $\mathrm{P_L}$ 或  $\mathrm{P_R}$ 直接成为其双亲结点 *f 的左子树即可。</li>
<li>若 *p 的结点的左子树和右子树均不空。有两种处理方法：<ol>
<li>令 *p 的左子树 为 *f 的左子树，而 *p 的右子树为 *s 的右子树。（图(c)）</li>
<li>令 *p 的直接前驱（或直接后继）代替 *p，然后再从二叉排序树中删去它的直接前驱（或直接后继）。（图(d)）</li>
</ol>
</li>
</ol>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240101151548473.png" class title="image-20240101151548473">

<p>综合上述情况得到的删除算法：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeleteBST</span><span class="params">(BiTree  &amp;T, KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">EQ</span>(key, T-&gt;data.key)) &#123;<span class="keyword">return</span> <span class="built_in">Delete</span>(T)&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">LT</span>(key, T-&gt;data.key)) <span class="keyword">return</span> <span class="built_in">DeleteBST</span>(T-&gt;lchild, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">DeleteBST</span>(T-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	<span class="comment">// DeleteBST</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BiTree &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从二叉排序树中删除结点p，并重新连接它的左右子树</span></span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;rchild)&#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;lchild)&#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;	<span class="comment">// 利用的第二种方法</span></span><br><span class="line">        q = p;</span><br><span class="line">        s = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)&#123;</span><br><span class="line">            q = s;</span><br><span class="line">            s= s-&gt;rchild;</span><br><span class="line">        &#125;					<span class="comment">// s 指向的是被删除结点的前驱</span></span><br><span class="line">        p-&gt;data = s-&gt;data;	<span class="comment">// s 代替被删除结点</span></span><br><span class="line">        <span class="keyword">if</span>(q != p)			</span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span>				<span class="comment">// 说明被删结点的前驱结点就是左子树</span></span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;</span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125; <span class="comment">// Delete</span></span><br></pre></td></tr></table></figure></div>



<p><strong>二叉排序树效率分析</strong></p>
<p>成功：每个结点的深度相加除以结点个数</p>
<p>失败：每个结点的外点深度相加除以外点个数</p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240101153203645.png" class title="image-20240101153203645">

<p>对于上面这幅图，$ASL_{失败} &#x3D; (2+2+3+3+3+3)&#x2F;6 &#x3D; 2.67$</p>
<p><strong>平衡二叉树</strong></p>
<p>平衡二叉树，又称 AVL 树，它或者是一棵空树，或者是具有以下性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。</p>
<p>二叉树上结点的平衡因子 BF（Balance Factor）：该节点的左子树的深度减去它的右子树的深度，则平衡二叉树上所有结点的平衡因子只可能就是 -1、0 和 1。</p>
<p><strong>平衡二叉树的插入</strong></p>
<p>二叉排序树保证平衡的基本思想：每当在二叉树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为这次操作而导致了不平衡。若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A，再以A为根的子树，再保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。</p>
<p>注意：每次调整的对象都是 <strong>最小不平衡子树</strong>。</p>
<p>平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上某个结点不再平衡，则需要作出相应的调整。可将调整的规律归纳为下列 4 种情况：</p>
<ol>
<li><p>LL 平衡旋转（右单旋转）</p>
<p>情况：由于在结点A的左孩子的左子树上插入了新结点，A的平衡因子由 1 增至 2，导致以 A 为根的子树失去平衡，需要一次向右的旋转操作。</p>
<p>操作：将A的左孩子 B 向上旋转代替 A 成为根结点，将 A 结点向右下旋转成为 B 的右子树的根结点，而B的原右子树则作为 A 结点的左子树。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20240101195643494.png" alt="image-20240101195643494" style="zoom: 67%;">
</li>
<li><p>RR平衡旋转（左单旋转）</p>
<p>情况：由于在结点 A 的右孩子的右子树上插入了新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。</p>
<p>操作：将 A 的右孩子 B 向左上旋转代替 A 成为根结点，将 A 结点向左下旋转成为 B 的左子树的根结点，而 B 的原左子树则作为 A 结点的右子树。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20240101200013294.png" alt="image-20240101200013294" style="zoom: 33%;">
</li>
<li><p>LR 平衡旋转（先左后右双旋转</p>
<p>情况：由于在 A 的左孩子 L 的右子树 R 上插入新结点，A 的平衡因子由 1 增至 2，导致以 A 为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。</p>
<p>操作：先将 A 结点的左孩子B的右子树的根结点 C 向左上旋转提升到 B 的位置，然后把该 C 结点向右上旋转提升到 A 结点的位置。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20240101200424507.png" alt="image-20240101200424507" style="zoom:33%;">
</li>
<li><p>RL 平衡旋转（先右后左）</p>
<p>情况：由于 A 的右孩子 R 的左子树 L 上插入新结点，A 的平衡因子由 -1 减至 -2，导致以 A 为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。</p>
<p>操作：将 A 结点的右孩子 B 的左子树的根结点 C 向右上旋转提升到 B 结点的位置，然后把该 C 结点向左上旋转提升到 A 结点的位置。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20240101200820982.png" alt="image-20240101200820982" style="zoom:33%;"></li>
</ol>
<p><strong>平衡二叉树的删除</strong></p>
<p>删除平衡二叉树的步骤，以删除结点 w 为例：</p>
<ol>
<li>用二叉排序树的方法对结点 w 执行删除操作</li>
<li>若导致了不平衡，则从结点 w 开始向上回溯，找到第一个不平衡的结点 z（即最小不平衡子树）：y 为结点 z 的高度最高的孩子结点 ，x 是结点 y 的高度最高的孩子结点。</li>
<li>然后对以 z 为根的子树进行平衡调整，其中 x、y 和 z  可能的位置有 4 种情况：<ul>
<li>y 是 z 的左孩子，x 是 y 的左孩子（LL，右单旋转）</li>
<li>y 是 z 的左孩子，x 是 y 的右孩子（LR，先左后右双旋转）</li>
<li>y 是 z 的右孩子，x 是 y 的右孩子（RR，左单旋转）</li>
<li>y 是 z 的右孩子，x 是 y 的左孩子（RL，先右后左双旋转）</li>
</ul>
</li>
</ol>
<p>这四种情况与插入操做的调整方式一样。不同之处在于，插入操作仅需要以 z 为根的子树进行平衡调整；而删除操作就不一样，先对以 z 为根的子树进行平衡调整，如果调整后子树的高度减 1，则可能需要对 z 的祖先结点进行平衡调整，甚至回溯到根结点（导致树高减1）</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20240101202400186.png" alt="image-20240101202400186" style="zoom: 33%;">





<p><strong>平衡二叉树查找的分析</strong></p>
<p>在平衡树上进行查找的时间复杂度为 $O(\log n)$ 。</p>
<h2 id="9-3-散列表"><a href="#9-3-散列表" class="headerlink" title="9.3 散列表"></a>9.3 散列表</h2><p><strong>散列表</strong>：根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。</p>
<p><strong>散列函数</strong>：一个把查找表中的关键字映射成关键字对应的地址的函数，记为 Hash(key) &#x3D; Addr</p>
<p>散列函数可能会把两个或两个以上的不同关键字映射到同一地址，这种情况称为 <strong>冲突</strong>，这些发生碰撞的不同关键字称为 <strong>同义词</strong>。</p>
<p>一般情况下，冲突只能尽可能地少，而不能完全避免。</p>
<h3 id="9-3-1-散列函数的构造方法"><a href="#9-3-1-散列函数的构造方法" class="headerlink" title="9.3.1 散列函数的构造方法"></a>9.3.1 散列函数的构造方法</h3><ol>
<li><p>直接定址法</p>
<p>取关键字或关键字的某个线性函数值为哈希地址。即：<br>$$<br>H(key) &#x3D; key\ 或\ H(key) &#x3D; a\ \cdot\ key+b<br>$$<br>其中，a 和 b 为常数</p>
</li>
<li><p>数学分析法</p>
</li>
<li><p>平方取中法</p>
</li>
<li><p>折叠法</p>
</li>
<li><p><strong>除留余数法</strong></p>
<p>取关键字被某个不大于哈希表表长 m 的数 p 除后所得到余数为哈希地址。即：<br>$$<br>H(key) &#x3D; key\ \mathrm{MOD}\ p,p\leqslant m<br>$$<br>一般情况下，可以 <strong>选 p 为质数</strong> 或不包含小于 20 的质因数的合数。</p>
</li>
<li><p>随机数法</p>
</li>
</ol>
<h3 id="9-3-2-处理冲突的方法"><a href="#9-3-2-处理冲突的方法" class="headerlink" title="9.3.2 处理冲突的方法"></a>9.3.2 处理冲突的方法</h3><ol>
<li><p>开放定址法<br>$$<br>H_i &#x3D; (H(key)+d_i)\ \mathrm{MOD}\ m, i &#x3D; 1,2,\cdots, k(k\leqslant m-1)<br>$$<br>其中：$H(key)$ 为哈希函数；<strong>m 为哈希表表长</strong>，和 除留余数法的p不一样。$d_i$ 为增量序列，有下面三种取法：</p>
<ul>
<li>线性探测再散列：$d_i &#x3D; 1,2,3,\cdots, m-1$ </li>
<li>二次探测再散列：$d_i &#x3D; 1^2,-1^2, 2^2, -2^2, 3^2, \cdots, \pm k^2(k\leqslant m&#x2F;2)$</li>
<li>伪随机探测再散列：$d_i$ &#x3D; 伪随机探测序列</li>
</ul>
</li>
<li><p>再哈希法<br>$$<br>H_i &#x3D; RH_i(key),i &#x3D; 1,2,\cdots, k<br>$$</p>
</li>
<li><p>链地址法</p>
<p>所有关键字为同义词的记录存储在同一线性链表中。建立指针型向量（数组），每个分量的初始状态都是空指针。</p>
</li>
</ol>
<h3 id="9-3-3-哈希表的查找及其分析"><a href="#9-3-3-哈希表的查找及其分析" class="headerlink" title="9.3.3 哈希表的查找及其分析"></a>9.3.3 哈希表的查找及其分析</h3><p>注：查找失败的对比数量要包括和空值的一次比较</p>
<h1 id="10-内部排序"><a href="#10-内部排序" class="headerlink" title="10 内部排序"></a>10 内部排序</h1><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><p>如果按排序过程中依据的不同原则对内部排序方法进行分类，则大致可分为 插入排序、交换排序、选择排序、归并排序 和 计数排序 五类。</p>
<p>如果按内部排序过程中所需的工作量来区分，则可分为三类：</p>
<ul>
<li>简单的排序方法，其时间复杂度为 $O(n^2)$</li>
<li>先进的排序方法：时间复杂度为 $O(n\log n)$</li>
<li>基数排序：时间复杂度为 $O(d·n)$</li>
</ul>
<h2 id="10-3-快速排序"><a href="#10-3-快速排序" class="headerlink" title="10.3 快速排序"></a>10.3 快速排序</h2><p><strong>快速排序</strong> 是对冒泡排序的一种改进。</p>
<p>基本思想：通过一趟排序将待排序记录分割成独立的两部分，其中一部分的关键字均比另一部分的关键字小，则可分别将这两部分记录继续进行排序，以达到整个序列有序。</p>
<p>一趟快速排序的具体做法：附设两个指针 low 和 high，他们的初值分别是 low 和 high，设 枢轴记录的关键字为 pivotkey，则首先从 high 所指位置向前搜索找到第一个关键字小于 pivotkey 的记录和枢轴记录相互交换，然后从 low 所指位置向后搜索，找到第一个关键字大于 pivotkey 的记录和枢轴记录互相交换，重复这两步直至 low &#x3D; high 为止。</p>
<p>算法：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 交换顺序表 L 中子表L.r[low..high]的记录，使枢轴记录到位，并返回此位置，此时</span></span><br><span class="line">    <span class="comment">// 在它之前（后）的记录均不大（小）于它</span></span><br><span class="line">    pivotkey = L.r[low].key;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)		<span class="comment">// 用子表的第一个记录作为枢轴记录</span></span><br><span class="line">    &#123;					<span class="comment">// 从表的两端交替向中间扫描</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L.r[high].key &gt;= pivotkey) -- high;</span><br><span class="line">        L.r[low]←→L.r[high]; <span class="comment">// 将比枢轴记录小的记录交换到低端</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L.r[low].key &lt;= pivotkey) ++low;</span><br><span class="line">        L.r[low]←→L.r[high]; <span class="comment">// 将比枢轴记录大的记录交换到高端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125; <span class="comment">// Partition</span></span><br></pre></td></tr></table></figure></div>



<p>具体实现上述算法，每交换一对记录需进行3次记录移动操作，而实际上，在排序过程中对枢轴记录的过程是多余的，因为只有在一趟排序结束时，即 low &#x3D; high 的位置才是枢轴记录的最后位置。因此可改写上述算法，先将枢轴记录暂存在 r[0]的位置上，排序过程只作 r[low] 或 r[high] 的单向移动，直至一趟排序结束后再将枢轴记录移至正确位置上。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 交换顺序表 L 中子表L.r[low..high]的记录，使枢轴记录到位，并返回此位置，此时</span></span><br><span class="line">    <span class="comment">// 在它之前（后）的记录均不大（小）于它</span></span><br><span class="line">    L.r[<span class="number">0</span>] = L.r[low].key;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)		<span class="comment">// 用子表的第一个记录作为枢轴记录</span></span><br><span class="line">    &#123;					<span class="comment">// 从表的两端交替向中间扫描</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L.r[high].key &gt;= pivotkey) -- high;</span><br><span class="line">        L.r[low] = L.r[high]; 	<span class="comment">// 将比枢轴记录小的记录交换到低端</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L.r[low].key &lt;= pivotkey) ++low;</span><br><span class="line">        L.r[low] = L.r[high]; 	<span class="comment">// 将比枢轴记录大的记录交换到高端</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.r[low] = L.r[<span class="number">0</span>];			<span class="comment">// 枢轴记录到位</span></span><br><span class="line">    <span class="keyword">return</span> low;					<span class="comment">// 返回枢轴位置</span></span><br><span class="line">&#125; <span class="comment">// Partition</span></span><br></pre></td></tr></table></figure></div>





<p>排序过程举例</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20240102003452393.png" alt="image-20240102003452393" style="zoom:50%;">



<p>递归形式的快速排序算法：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 对顺序表L中的子序列 L.r[low..high] 作快速排序</span></span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;						<span class="comment">// 表长度大于1</span></span><br><span class="line">        pivotloc = <span class="built_in">Partion</span>(L,low, high); <span class="comment">// 将 L.r[low..high]一分为二</span></span><br><span class="line">        <span class="built_in">QSort</span>(L, low, pivotloc<span class="number">-1</span>);		<span class="comment">// 对低子表递归排序, pivotloc 是枢轴位置</span></span><br><span class="line">        <span class="built_in">QSort</span>(L, pivotloc+<span class="number">1</span>, high);		<span class="comment">// 对高子表进行排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// QSort</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="built_in">QSort</span>(L, <span class="number">1</span>, L.length);</span><br><span class="line">&#125; <span class="comment">// QuickSort</span></span><br></pre></td></tr></table></figure></div>



<p><strong>快速排序是所有内部排序算法中平均性能最优的排序算法</strong>。时间复杂度为 $O(n\log_2 n)$</p>
<h2 id="10-4-选择排序"><a href="#10-4-选择排序" class="headerlink" title="10.4 选择排序"></a>10.4 选择排序</h2><h3 id="10-4-1-简单选择排序"><a href="#10-4-1-简单选择排序" class="headerlink" title="10.4.1 简单选择排序"></a>10.4.1 简单选择排序</h3><p>一趟简单选择排序的操作为：通过 n-i 次关键字间的比较，从 n-i+1 个记录中选出关键字最小的记录，并和第 i ($1\leqslant i \leqslant n$) 个记录交换之。</p>
<h3 id="10-4-3-堆排序"><a href="#10-4-3-堆排序" class="headerlink" title="10.4.3 堆排序"></a>10.4.3 堆排序</h3><p>堆排序只需要一个记录大小的辅助空间，每个待排序的记录仅占一个存储空间。</p>
<p>堆的定义如下：n 个元素的序列 ${k_1, k_2, \cdots, k_n}$ 当且仅当满足下面的关系时，称之为 <strong>堆</strong><br>$$<br>\begin{cases}<br>k_i\leqslant k_{2i}\<br>k_i\leqslant k_{2i+1}<br>\end{cases}<br>或<br>\begin{cases}<br>k_i\geqslant k_{2i}\<br>k_i\geqslant k_{2i+1}<br>\end{cases}<br>$$<br>若将此序列对应的一维数组看成是一个完全二叉堆，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于其左、右孩子结点的值。由此，若序列 ${k_1, k_2, \cdots, k_n}$ 是堆，则堆顶元素必然为序列 n 个元素的最小值（或最大值）。</p>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20240102013827556.png" alt="image-20240102013827556" style="zoom:50%;">

<p>实现堆排序需要解决两个问题：</p>
<ul>
<li>如何由一个无序序列建成一个堆</li>
<li>如何在输出堆顶元素之后，调整剩余元素成为一个新的堆</li>
</ul>
<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20240102093446842.png" alt="image-20240102093446842" style="zoom: 33%;">

<p>例如，图 10.11所示，(a)是一个堆，假设输出栈顶元素之后，以堆中最后一个元素替代之，如(b)所示，此时根的左右子树均为堆，则仅需自上而下调整即可。首先以 堆顶元素和其左、右子树的根结点的值比较，由于右子树根结点的值小于左子树根结点的值，则将 27 和 97 交换。由于 97 替代了 27 之后破坏了右子树的 “堆”，则需进行上述同样的调整，直至叶子结点，调整后的状态如图(c)所示，此时堆顶为 n-1 个元素中的最小值。重复上述过程，将堆顶元素 27 和堆最后一个元素 97 交换且调整，得到 图(d) 所示的新堆。</p>
<p>这个过程称为 “<strong>筛选</strong>”。</p>
<img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240102094320842.png" class title="image-20240102094320842">

<p>从一个无序序列建堆的过程就是一个反复“筛选”的过程。若将此序列看成一个完全二叉树，则最后一个非终端结点是第 $\lfloor n&#x2F;2 \rfloor$ 个元素，由此“筛选”只需从第 $\lfloor n&#x2F;2 \rfloor$ 个元素开始。</p>
<p>例如：图10.12(a) 中的二叉树表示一个具有 8 个元素的无序序列 ${49,38,65,97,76,13,27,\overline{49} }$，则筛选从第 4 个元素开始，由于 $97&gt;\overline{49}$ ，则交换之，交换后的序列如图(b)，同理在第 3 个元素 65 被筛选后的序列状态如图(c) 所示，由于2个元素38不大于其左右子树根的值，所以筛选后的序列不变。图(e) 为筛选根元素 49 之后建成的堆。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> SqList HeapType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(HeapType &amp;H, <span class="type">int</span> s, <span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    rc = H.r[s];</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span>*s; j&lt;=m; j*=<span class="number">2</span>) <span class="comment">// 沿着 key 较大的孩子结点向下筛选</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;m &amp;&amp; <span class="built_in">LT</span>(H.r[j].key, H.r[j+<span class="number">1</span>].key)) ++j;	<span class="comment">// j 为 key 较大的记录的下标</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">LT</span>(rc.key, H.r[j].key)) <span class="keyword">break</span>; <span class="comment">// rc 应该插入到位置 s 上</span></span><br><span class="line">        H.r[s] = H.r[j]; s = j;</span><br><span class="line">    &#125;</span><br><span class="line">    H.r[s] = rc;</span><br><span class="line">&#125; <span class="comment">// HeapAdjust</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(HeapType &amp;H)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 对顺序表 H 进行堆排序</span></span><br><span class="line">    <span class="keyword">for</span>( i = H.length/<span class="number">2</span>; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(H, i, H.length);</span><br><span class="line">    <span class="keyword">for</span>( i = H.length; i&gt;<span class="number">1</span>; --i)&#123;</span><br><span class="line">        H.r[<span class="number">1</span>]←→H.r[i];</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(H,<span class="number">1</span>,i<span class="number">-1</span>);		</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// HeapSort</span></span><br></pre></td></tr></table></figure></div>



<p><strong>算法效率分析</strong></p>
<p>空间复杂度：仅适用了常数个辅助单元，空间复杂度为 O(1)</p>
<p>时间复杂度：</p>
<ul>
<li>建堆时间为 O(n)</li>
<li>之后有 n-1 次向下调整的操作，每次调整的时间复杂度为 O(h)，h为堆的树高，故在最好、最坏和平均情况下，堆排序的时间复杂度为 $O(n\log_2n)$</li>
</ul>
<p>稳定性：是一个 <strong>不稳定</strong> 的排序方法</p>
<h2 id="10-6-基数排序"><a href="#10-6-基数排序" class="headerlink" title="10.6 基数排序"></a>10.6 基数排序</h2><p><strong>基数排序</strong> 不需要进行关键字间的比较。基数排序 是一种借助多关键字排序的思维，对单逻辑关键字进行排序的方法。</p>
<h3 id="10-6-1-多关键字的排序"><a href="#10-6-1-多关键字的排序" class="headerlink" title="10.6.1 多关键字的排序"></a>10.6.1 多关键字的排序</h3><p>假设有 n 个记录的序列 ${R_1, R_2, \cdots, R_n}$ ，且每个记录 $R_i$ 中含有 d 个关键字 $(K_i^0, K_i^1, \cdots, K_i^{d-1})$ ，则称序列 对关键字有序是指：对于序列中任意两个记录 $R_i$ 和 $R_j(1\leqslant i &lt; j\leqslant n)$ 都满足下列有序关系：<br>$$<br>(K_i^0, K_i^1, \cdots, K_i^{d-1}) &lt; (K_j^0, K_j^1, \cdots, K_j^{d-1})<br>$$<br>其中 $K^0$ 称为最主位关键字，$K^{d-1}$ 称为最次位关键字。为实现多关键字排序，通常有两种方法：</p>
<ul>
<li>第一种方法，<strong>最高位优先法</strong>，MSD 法：先对最主位关键字 $K^0$ 进行排序，将序列分成若干子序列，每个子序列记录都具有相同给 $K^0$ 值，然后分别就每个子序列对关键字 $K^1$ 进行排序，按 $K^1$ 的值分成若干更小的子序列，依次重复，直至对 $K^{d-2}$ 进行排序之后得到的每一个子序列中的记录都具有相同的关键字$(K^0,K^1, \cdots, K^{d-2})$ ，而后分别每个子序列对 $K^{d-1}$ 进行排序，最后再对高一位的关键字 $K^{d-1}$ 进行排序。最后将所有子序列一次联接在一起成为一个有序序列。</li>
<li>第二种方法，<strong>最低位优先法</strong>，LSD 法：从最次位关键字 $K^{d-1}$ 进行排序。然后再对高一位的关键字 $K^{d-2}$ 进行排序，依次重复，直至对 $K^0$ 进行排序后便成为一个有序序列。</li>
</ul>
<h3 id="10-6-2-链式基数排序"><a href="#10-6-2-链式基数排序" class="headerlink" title="10.6.2 链式基数排序"></a>10.6.2 链式基数排序</h3><p>基数排序，是借助 <strong>分配</strong> 和 <strong>收集</strong> 两种操作对 <strong>单逻辑关键字</strong> 进行排序。</p>
<p>有的单逻辑关键字可以看成若干个关键字复合而成的。例如，若关键字是数值，且其值都在 $0\leqslant K \leqslant 999$ 范围，则可把每一个十进制数字看成一个关键字，可认为 $K$ 由 3 个关键字（$K^0,K^1, K^2$）组成。采取 LSD 进行排序更为方便。</p>
<p>只要从最低数位关键字起，按关键字的不同值将序列种记录 “分配”到 RADIX 个队列中后再“收集”之，如此重复 $d$ 次。按这种方法实现排序 称之为 <strong>基数排序</strong>。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM_OF_KEY 8			<span class="comment">// 关键字数项的最大值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADIX 10					<span class="comment">// 关键字基数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SPACE 10000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    KeysType keys[MAX_NUM_OF_KEY];	<span class="comment">// 关键字</span></span><br><span class="line">    InfoType otheritems;			<span class="comment">// 其他数据项</span></span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;SLCell;							<span class="comment">// 静态链表的结点类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    SLCell r[MAX_SPACE];			<span class="comment">// 静态链表的可利用空间，r[0] 为头结点</span></span><br><span class="line">    <span class="type">int</span> keynum;						<span class="comment">// 记录的当前关键字个数</span></span><br><span class="line">    <span class="type">int</span> recnum;						<span class="comment">// 静态链表当前的长度</span></span><br><span class="line">&#125;SLList;							<span class="comment">// 静态链表类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArrType[RADIX];			<span class="comment">// 指针数组类型</span></span><br></pre></td></tr></table></figure></div>

<img lazyload src="/images/loading.svg" data-src="./数据结构/image-20240109145224036.png" alt="image-20240109145224036" style="zoom:67%;">

<p>f[i] 和 e[i] 分别为 第 i 个队列的头指针和尾指针</p>
<p>链式基数排序中一趟分配的算法：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Distribute</span><span class="params">(SLCell &amp;r, <span class="type">int</span> i, ArrType &amp;f, ArrType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 静态链表 L 的 r 域中记录已按(keys[0], ..., keys[i-1]) 有序</span></span><br><span class="line">    <span class="comment">// 本算法按第 i 个关键字 keys[i] 建立 RADIX 个子表，使同一子表中记录的 keys[i] 相同</span></span><br><span class="line">    <span class="comment">// f[0..RADIX-1] 和 e[0..RADIX-1] 分别指向各子表中第一个和最后一个记录</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j&lt;Radix; ++j) f[j] = <span class="number">0</span>;		<span class="comment">// 各子表初始化为空表</span></span><br><span class="line">    <span class="keyword">for</span>(p = r[<span class="number">0</span>].next; p; p = r[p].next)&#123;</span><br><span class="line">        j = <span class="built_in">ord</span>(r[p].key);		<span class="comment">// ord 将记录中第i个关键字映射到[0..RADIX-1]</span></span><br><span class="line">        <span class="keyword">if</span>(!f[j]) f[j] = p;</span><br><span class="line">        <span class="keyword">else</span> r[e[j]].next = p;	<span class="comment">// 将 p 所指的结点插入第 j 个子表中</span></span><br><span class="line">        e[j] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// Distribute</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Collect</span><span class="params">(SLCell &amp;r, <span class="type">int</span> i, ArrType f, ArrType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 本算法按 keys[i] 自小到大 将 f[0...RADIX-1]所指各子表依次链接成一个链表</span></span><br><span class="line">    <span class="comment">// e[0...RADIX-1] 为各子表的尾指针</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; !f[j]; j = <span class="built_in">succ</span>(j));	<span class="comment">// 找第一个非空子表, succ 为求后继函数</span></span><br><span class="line">    r[<span class="number">0</span>].next = f[j]; t = e[j];	<span class="comment">// r[0].next 指向第一个非空子表中的第一个结点</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;RADIX)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="built_in">succ</span>(j); j&lt;RADIX<span class="number">-1</span> &amp;&amp; !f[j]; j=<span class="built_in">succ</span>(j));<span class="comment">// 找下一个非空子表</span></span><br><span class="line">        <span class="keyword">if</span>(f[j]) &#123;r[t].next = f[j]; t = e[j]; &#125;	<span class="comment">// 链接两个非空子表</span></span><br><span class="line">    &#125;</span><br><span class="line">    r[t].next = <span class="number">0</span>;			<span class="comment">// t 指向最后一个非空子表中的最后一个结点</span></span><br><span class="line">&#125; <span class="comment">// Collect</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(SLList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">// L 是采用静态链表表示的顺序表</span></span><br><span class="line">    <span class="comment">// 对 L 作基数排序，使得 L 成为按关键字自小到大的有序静态链表, L.r[0] 为头结点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;L.recnum; ++i) L.r[i].next = i+<span class="number">1</span>;</span><br><span class="line">    L.r[recnum].next = <span class="number">0</span>;			<span class="comment">// 将 L 改造为静态链表</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;L.keynum; ++i)&#123;		<span class="comment">// 按最低位优先依次对各关键字进行分配和收集</span></span><br><span class="line">        <span class="built_in">Distribute</span>(L.r, i, f, e);	<span class="comment">// 第i趟分配</span></span><br><span class="line">        <span class="built_in">Collect</span>(L.r, i, f, e);		<span class="comment">// 第i趟收集</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// RadixSort</span></span><br></pre></td></tr></table></figure></div>







<h2 id="10-7-各种内部排序方法的比较讨论"><a href="#10-7-各种内部排序方法的比较讨论" class="headerlink" title="10.7 各种内部排序方法的比较讨论"></a>10.7 各种内部排序方法的比较讨论</h2><img lazyload src="/images/loading.svg" data-src="/2024/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240102103006941.png" class title="image-20240102103006941">

<ul>
<li>稳定的内部排序：直接插入排序、冒泡排序、2路归并排序、基数排序</li>
<li>不稳定的内部排序：简单选择排序、写入排序、快速排序</li>
</ul>

        </div>

        
            <div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> 数据结构</li>
        <li><strong>Author:</strong> 卡布叻_米菲</li>
        <li><strong>Created at
                :</strong> 2024-01-13 09:29:29</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-01-13 00:39:28
            </li>
        
        <li>
            <strong>Link:</strong> https://carolinebaby.github.io/2024/01/13/数据结构/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/">#算法学习</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                    <div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="prev"
                        rel="prev"
                        href="/2024/02/07/%E8%AE%B0%E5%BD%95%E5%8E%86%E5%8F%B2/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">家庭历史映像——口述历史</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="next"
                        rel="next"
                        href="/2023/07/02/%E5%96%84%E7%94%A8STL/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">善用STL</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
            <div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
                <div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://caroline-world-42jy0ja18-carolinebaby.vercel.app',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          requiredMeta: ['nick', 'mail'],
          emoji: [],
          recaptchaV3Key: "wasd",
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

            </div>
        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">数据结构</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E7%BB%AA%E8%AE%BA"><span class="nav-text">1 绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="nav-text">1.1 基本概念和术语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-%E6%95%B0%E6%8D%AE"><span class="nav-text">1.1.1 数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">1.1.2 数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%90%E7%AE%97"><span class="nav-text">1.1.3 数据的运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">1.1.3 数据类型和抽象数据类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-text">1.2 算法和算法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E7%AE%97%E6%B3%95"><span class="nav-text">1.2.1 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-text">1.2.2 算法设计的要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-%E7%AE%97%E6%B3%95%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-text">1.2.3 算法的描述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-text">2 线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-text">2.1 线性表的类型定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%89%B9%E5%BE%81"><span class="nav-text">线性表的逻辑特征</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.2 线性表的顺序表示和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="nav-text">2.2.1 线性表的线性存储表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.2.2 线性表的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.2.3 顺序表基本操作的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.3 顺序表的链式表示和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8"><span class="nav-text">2.3.1 线性链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.3.2 线性链表的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.3.3 线性链表基本操作的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="nav-text">2.3.4 静态链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-5-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-text">2.3.5 循环链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-6-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-text">2.3.6 双向链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E7%9B%B8%E5%8A%A0"><span class="nav-text">2.4 一元多项式的表示和相加</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-text">3 栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E6%A0%88"><span class="nav-text">3.1 栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">3.1.1 抽象数据类型栈的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-text">3.1.2 栈的表示和实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">3.2 栈的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E6%95%B0%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-text">3.2.1 数制转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-text">3.2.2 表达式求值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">3.3 栈与递归的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-n-%E9%98%B6%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98"><span class="nav-text">3.3.1  n 阶汉诺塔问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E5%AE%9E%E8%B4%A8"><span class="nav-text">3.3.2  递归函数运行实质</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E9%98%9F%E5%88%97"><span class="nav-text">3.4 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">3.4.1 抽象数据类型队列的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E9%93%BE%E9%98%9F%E5%88%97-%E2%80%94%E2%80%94-%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-text">3.4.2 链队列 —— 队列的链式表示和实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-text">3.4.3  循环队列——队列的顺序表示和实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-4-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-text">3.4.4 优先队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-5-%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">3.4.5  队列的应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E4%B8%B2"><span class="nav-text">4 串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">4.1 串类型的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E4%B8%B2%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.2 串的表示和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-%E5%AE%9A%E9%95%BF%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="nav-text">4.2.1 定长顺序存储表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-%E5%A0%86%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="nav-text">4.2.2 堆分配存储表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-%E4%B8%B2%E7%9A%84%E5%9D%97%E9%93%BE%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="nav-text">4.2.3 串的块链存储表示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-text">4.3 串的模式匹配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-%E6%B1%82%E5%AD%90%E4%B8%B2%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%87%BD%E6%95%B0-Index-S-T-pos"><span class="nav-text">4.3.1 求子串位置的定位函数 Index(S, T, pos)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-KMP%E7%AE%97%E6%B3%95"><span class="nav-text">4.3.2 KMP算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-text">5 数组和广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">5.1 数组的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-text">5.2 数组的顺序表示和实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-text">5.3 矩阵的压缩存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5"><span class="nav-text">5.3.1 特殊矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="nav-text">5.3.2 稀疏矩阵</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">5.4 广义表的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">5.5 广义表的存储结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">6 树和二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-text">6.1 树的定义和基本术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">6.2 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">6.2.1二叉树的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-text">6.2.2 二叉树的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">6.2.3二叉树的存储结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E7%BA%BF%E6%80%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">6.3 遍历二叉树和线性二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">6.3.1 遍历二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">6.3.2 线索二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="nav-text">6.4 树和森林</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-1-%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">6.4.1 树的存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-2-%E6%A3%AE%E6%9E%97%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">6.4.2 森林和二叉树的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-3-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">6.4.3 树和森林的遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-text">6.6 赫夫曼编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%EF%BC%89"><span class="nav-text">6.6.1 最优二叉树（赫夫曼树）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-text">6.6.2 赫夫曼编码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86"><span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A0%86%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0"><span class="nav-text">1 堆的定义及其实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%9B%BE"><span class="nav-text">7 图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="nav-text">7.1 图的定义和术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">7.2 图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">7.2.1 数组表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-text">7.2.2 邻接表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="nav-text">7.2.3 十字链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-4-%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="nav-text">7.2.4 邻接多重表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">7.3 图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">7.3.1 深度优先搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">7.3.2 广度优先搜索</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">7.4 图的连通性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-1-%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E5%92%8C%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">7.4.1 无向图的连通分量和生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-2-%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-text">7.4.2 有向图的强连通分量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-3-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">7.4.3 最小生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-4-%E5%85%B3%E8%8A%82%E7%82%B9%E5%92%8C%E9%87%8D%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-text">7.4.4 关节点和重连通分量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="nav-text">7.5 有向无环图及其应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-1-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">7.5.1 拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-2-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-text">7.5.2 关键路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="nav-text">7.6 最短路径问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-1-%E4%BB%8E%E6%9F%90%E4%B8%AA%E6%BA%90%E7%82%B9%E5%88%B0%E5%85%B6%E4%BD%99%E5%90%84%E9%A1%B6%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-text">7.6.1 从某个源点到其余各顶点的最短路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-2-%E6%AF%8F%E4%B8%80%E5%AF%B9%E9%A1%B6%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-text">7.6.2 每一对顶点之间的最短路径</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC9%E7%AB%A0-%E6%9F%A5%E6%89%BE"><span class="nav-text">第9章 查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="nav-text">9.1 静态查找表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-1-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-text">9.1.1 顺序查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-2-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-text">9.1.2 折半查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-3-%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="nav-text">9.1.3 分块查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="nav-text">9.2 动态查找表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-1-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%92%8C%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">9.2.1 二叉排序树和平衡二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-%E6%95%A3%E5%88%97%E8%A1%A8"><span class="nav-text">9.3 散列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-1-%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">9.3.1 散列函数的构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-2-%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">9.3.2 处理冲突的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-3-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8F%8A%E5%85%B6%E5%88%86%E6%9E%90"><span class="nav-text">9.3.3 哈希表的查找及其分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="nav-text">10 内部排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">10.1 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">10.3 快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-4-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">10.4 选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-1-%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">10.4.1 简单选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-3-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-text">10.4.3 堆排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-6-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">10.6 基数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-6-1-%E5%A4%9A%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="nav-text">10.6.1 多关键字的排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-6-2-%E9%93%BE%E5%BC%8F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">10.6.2 链式基数排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-7-%E5%90%84%E7%A7%8D%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E8%AE%A8%E8%AE%BA"><span class="nav-text">10.7 各种内部排序方法的比较讨论</span></a></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">卡布叻_米菲</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        16 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.1</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>





    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>









<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>
