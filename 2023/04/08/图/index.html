<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="算法学习, 图">
    
    <meta name="author" content="卡布叻_米菲">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://carolinebaby.github.io/2023/04/08/图/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="学习图论ing">
<meta property="og:type" content="article">
<meta property="og:title" content="图论学习">
<meta property="og:url" content="https://carolinebaby.github.io/2023/04/08/%E5%9B%BE/index.html">
<meta property="og:site_name" content="Caroline&#39;s World">
<meta property="og:description" content="学习图论ing">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://carolinebaby.github.io/2023/04/08/%E5%9B%BE/%E5%9B%BE/image-20230401150129944.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/04/08/%E5%9B%BE/%E5%9B%BE/image-20230401150206160.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/04/08/%E5%9B%BE/%E5%9B%BE/image-20230401152044989.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/04/08/%E5%9B%BE/%E5%9B%BE/image-20230401152502884.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/04/08/%E5%9B%BE/%E5%9B%BE/image-20230401154651336.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/04/08/%E5%9B%BE/%E5%9B%BE/image-20230401155741189.png">
<meta property="og:image" content="https://pic4.zhimg.com/v2-4f10048ca88fda26f03cf38074b3a8bb_b.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-a4a9a98ff20adfd0d027013610ebc5e4_r.jpg">
<meta property="og:image" content="https://cdn.acwing.com/media/article/image/2022/03/07/64858_2a411f1d9e-floyd%E6%80%BB%E6%89%8E.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/04/08/%E5%9B%BE/%E5%9B%BE/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F.png">
<meta property="og:image" content="https://pic2.zhimg.com/v2-77e41054d2ea49e8f61ce8d98fa3c20d_b.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/08/26/d.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1611023745-EuGMdh-image.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex1.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex2.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex3.png">
<meta property="og:image" content="https://pic2.zhimg.com/v2-558540e634e5537df60a0f61bfa1829d_b.jpg">
<meta property="og:image" content="https://cdn.vijos.org/fs/1557c96115c93850f07546ed228ba7797f616190">
<meta property="og:image" content="https://pic2.zhimg.com/v2-c7cd484003b71bf480546ac21fd19669_b.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/v2-94394273ebce1f9cfd2ee50dfd1f22e1_b.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-952b78faeed7a68af4349357e34efe8f_b.jpg">
<meta property="article:published_time" content="2023-04-08T01:54:55.000Z">
<meta property="article:modified_time" content="2023-05-13T08:33:36.976Z">
<meta property="article:author" content="Caroline">
<meta property="article:tag" content="算法学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://carolinebaby.github.io/2023/04/08/%E5%9B%BE/%E5%9B%BE/image-20230401150129944.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
    <meta name="theme-color" content="#0072BC">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <!--- Page Info-->
    
    <title>
        
            图论学习 -
        
        卡布叻_米菲的世界
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
        <style>
    :root {
        --preloader-background-color: #fff;
        --preloader-text-color: #000;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --preloader-background-color: #202124;
            --preloader-text-color: #fff;
        }
    }

    @media (prefers-color-scheme: light) {
        :root {
            --preloader-background-color: #fff;
            --preloader-text-color: #000;
        }
    }

    @media (max-width: 600px) {
        .ml13 {
            font-size: 2.6rem !important; /* Adjust this value as needed */
        }
    }

    .preloader {
        display: flex;
        flex-direction: column;
        gap: 1rem; /* Tailwind 'gap-4' is 1rem */
        align-items: center;
        justify-content: center;
        position: fixed;
        padding: 12px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh; /* 'h-screen' is 100% of the viewport height */
        background-color: var(--preloader-background-color);
        z-index: 1100; /* 'z-[1100]' sets the z-index */
        transition: opacity 0.2s ease-in-out;
    }

    .ml13 {
        font-size: 3.2rem;
        /* text-transform: uppercase; */
        color: var(--preloader-text-color);
        letter-spacing: -1px;
        font-weight: 500;
        font-family: 'Chillax-Variable', sans-serif;
        text-align: center;
    }

    .ml13 .word {
        display: inline-flex;
        flex-wrap: wrap;
        white-space: nowrap;
    }

    .ml13 .letter {
        display: inline-block;
        line-height: 1em;
    }
</style>

<div class="preloader">
    
<script src="/js/libs/anime.min.js"></script>

    <h1 class="ml13">
        卡布叻_米菲的世界
    </h1>
    <script>
        var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });


        anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [100,0],
                translateZ: 0,
                opacity: [0,1],
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i
            }).add({
            targets: '.ml13 .letter',
            translateY: [0,-100],
            opacity: [1,0],
            easing: "easeInExpo",
            duration: 1200,
            delay: (el, i) => 100 + 30 * i
        });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            hidePreloaderAfterTimeout(1000); // Hide after 1000 milliseconds once the window has loaded
        });

        // Backup failsafe: Hide preloader after a maximum of 5000 milliseconds, regardless of the window load event
        hidePreloaderAfterTimeout(5000);

        function hidePreloaderAfterTimeout(delay) {
            setTimeout(function () {
                var preloader = document.querySelector('.preloader');
                preloader.style.opacity = '0';
                setTimeout(function () {
                    preloader.style.display = 'none';
                }, 200);
            }, delay);
        }
    </script>
</div>
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    <!--- Font Part-->
    
    
    
    


    <script id="hexo-configurations">
    window.config = {"hostname":"carolinebaby.github.io","root":"/","language":"en"};
    window.theme = {"articles":{"style":{"font_size":"18px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left","headings_top_spacing":{"h1":"5rem","h2":"4rem","h3":"2.8rem","h4":"2.5rem","h5":"2.2rem","h6":"2rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#0072BC","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"https://cdn.dynamicwallpaper.club/wallpapers/0lt9t1k10ae/thumbs/1600/2.jpg","dark":"https://cdn.dynamicwallpaper.club/wallpapers/0lt9t1k10ae/thumbs/1600/5.jpg"},"title":"Welcome to Caroline's world!","subtitle":{"text":["这里是 卡布叻_米菲 的世界！"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"style":"default","links":{"github":"https://github.com/Carolinebaby","instagram":null,"zhihu":null,"twitter":null,"email":"1474396199@qq.com"},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.6.1","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"About":{"icon":"fa-regular fa-user","submenus":{"Me":"/about","Blog":"https://carolinebaby.github.io/","Github":"https://github.com/Carolinebaby"}}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":"Hi~Welcome~","show_on_mobile":true,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"},"shuoshuo":{"path":"/shuoshuo","icon":"fa-regular fa-comment-dots"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2023/4/8 08:29:29"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
<!--        <span class="swup-progress-icon">-->
<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
<!--        </span>-->
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container px-6 md:px-12">

    <div class="navbar-content ">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/charlie3.jpg">
                </a>
            
            <a class="logo-title" href="/">
                
                卡布叻_米菲的世界
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-user fa-fw"></i>
                                    ABOUT
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a href="/about">
                                                    ME
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a href="https://carolinebaby.github.io/">
                                                    BLOG
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://github.com/Carolinebaby">
                                                    GITHUB
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-About"
                        >
                            <span>
                                ABOUT
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-About">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="/about">ME</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="https://carolinebaby.github.io/">BLOG</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://github.com/Carolinebaby">GITHUB</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/tags"
                        >
                            <span>Tags</span>
                            <i class="fa-regular fa-tags fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/shuoshuo"
                        >
                            <span>Shuoshuo</span>
                            <i class="fa-regular fa-comment-dots fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">4</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">3</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">16</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container flex relative justify-between box-border w-full h-full">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                <div class="w-full flex items-center pt-6 justify-start">
                    <h1 class="article-title-regular text-second-text-color text-4xl md:text-6xl font-bold px-2 sm:px-6 md:px-8 py-3">图论学习</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/images/QQ%E5%A4%B4%E5%83%8F.jpg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">卡布叻_米菲</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-04-08 09:54:55</span>
        <span class="mobile">2023-04-08 09:54:55</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-05-13 16:33:36</span>
            <span class="mobile">2023-05-13 16:33:36</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/">算法学习</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/">算法学习</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <p><strong>图论</strong></p>
<ul>
<li>基础：DFS，BFS</li>
<li>简单：拓扑排序，有向无环图，最短路，并查集，最小生成树</li>
<li>中等：网络流，tarjan 算法，树上技术</li>
<li>苦难：仙人掌问题，建图</li>
</ul>
<span id="more"></span>

<h2 id="图的定义和概念🧐"><a href="#图的定义和概念🧐" class="headerlink" title="图的定义和概念🧐"></a>图的定义和概念🧐</h2><ul>
<li>图可以表示为一个二元组G &#x3D; &lt;V, E&gt;，其中<ul>
<li>V 表示非空顶点集，其元素称为顶点（Vertex）</li>
<li>E 表示边集，其元素称为边（Edge）</li>
</ul>
</li>
<li>e &#x3D; (u, v) 表示一条边，其中 u∈V, v∈V, e∈E</li>
</ul>
<p><strong>分类</strong></p>
<ul>
<li>无向图 $G_1 &#x3D;&lt; V_1, E_1 &gt;$</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="图/image-20230401150129944.png"
                      alt="image-20230401150129944" style="zoom: 67%;" 
                >

<ul>
<li>有向图 $G_2 &#x3D;&lt; V_2, E_2 &gt;$</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="图/image-20230401150206160.png"
                      alt="image-20230401150206160" style="zoom:67%;" 
                >



<p>相邻（Adjacent）：边(u, v) 连接的顶点u和v相邻</p>
<p>关联（Incident）：边(u, v) 和其连接的顶点u(或v)相互关联</p>
<p><strong>度</strong></p>
<ul>
<li><p>顶点的度（Degree of a Vertex）</p>
<p>顶点v 的度 deg(v) 是 v 关联的边数</p>
</li>
<li><p>图的度（Degree of a Graph）</p>
<p>图 G &#x3D; &lt;V, E&gt; 的度，是图各顶点的度之和，$deg(G) &#x3D; ∑_{v∈V}deg(v)$  </p>
</li>
<li><p>握手定理</p>
<p>无向图的度是边数的两倍，deg(E) &#x3D; 2|E|</p>
</li>
<li><p>在无向图中，「度」就是每个节点相连的边的条数。由于有向图的边有方向，所以有向图中每个节点「度」被细分为<strong>入度</strong>（indegree）和<strong>出度</strong>（outdegree）</p>
</li>
</ul>
<p><strong>路径（Path）</strong></p>
<ul>
<li>图中一个顶点序列$&lt;v_0, v_1, …, v_k&gt;$ 称为 $v_0$ 到 $v_k$ 的路径</li>
<li>路劲包含顶点$v_0, v_1, …, v_k$ 和边$(v_0, v_1),(v_1,v_2),…,(v_{k-1}, v_k)$</li>
<li>存在路径$v_0, v_1, …, v_k$ ，则 $v_0$ 可到达 $v_k$</li>
<li>如果 $v_0, v_1, …, v_k$ 互不相同，则该路径是简单的</li>
</ul>
<p><strong>环路（Cycle）</strong></p>
<ul>
<li>如果路径$&lt;v_0, v_1, …, v_k&gt;$ 中 $v_0 &#x3D; v_k$且至少包含一条边，则该路径构成环路</li>
<li>如果 $v_0, v_1, …, v_k$ 互不相同，则该环路是简单的</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="图/image-20230401152044989.png"
                      alt="image-20230401152044989" style="zoom:33%;" 
                >

<p><strong>连通（Connectivity）</strong></p>
<ul>
<li>如果图的任意对顶点相互可达，则称该图是连通的，反之称为非联通</li>
<li>连通分量（Connected Components）根据是否连通将顶点进行分组，相互可达的顶点集称为连通分量</li>
</ul>
<p><strong>子图（Subgraph）</strong></p>
<p>如果𝑽′ ⊆ 𝑽, 𝑬′ ⊆ 𝐄，则称图𝑮’ &#x3D;&lt; 𝑽’, 𝑬’ &gt;是图𝑮的一个子图</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="图/image-20230401152502884.png"
                      alt="image-20230401152502884" style="zoom: 33%;" 
                >

<p><strong>树（Tree）</strong>：连通、无环图𝑻 &#x3D;&lt; 𝑽𝑻, 𝑬𝑻 &gt;，树有|𝑽𝑻| − 𝟏条边</p>
<p><strong>森林（Forest）</strong>：一至多棵树组成的无环图</p>
<p><strong>图的表示</strong></p>
<p><strong>邻接链表</strong></p>
<ul>
<li><p>图𝑮 &#x3D;&lt; 𝑽, 𝑬 &gt; ，其邻接链表由|𝑽|条链表的数组构成</p>
</li>
<li><p>每个顶点有一条链表，包含所有与其相邻的顶点</p>
<p>𝑨𝒅𝒋[𝒂] &#x3D; {𝒃, 𝒅} ; 𝑨𝒅𝒋[𝒃] &#x3D; {𝒂, 𝒄, 𝒅, 𝒇} ; 𝑨𝒅𝒋[𝒄] &#x3D; {𝒃, 𝒇}; …</p>
</li>
<li><p>空间大小 𝑶(|𝑽| + |𝑬|)</p>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="图/image-20230401154651336.png"
                      alt="image-20230401154651336" style="zoom:50%;" 
                >

<p><strong>邻接矩阵</strong></p>
<ul>
<li><p>图𝑮 &#x3D;&lt; 𝑽, 𝑬 &gt; 的邻接矩阵由 𝑽 × |𝑽|的二维数组𝑨构成，满足：<br>$A_{ij}&#x3D;\begin{cases}1,&amp;{(i,j)∈E}\0,&amp; {(i,j)∉E}\end{cases}$ </p>
</li>
<li><p>空间大小𝑶( $|V|^2$)， 𝑶(𝟏)判断是否有边</p>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="图/image-20230401155741189.png"
                      alt="image-20230401155741189" style="zoom:50%;" 
                >



<h2 id="图的算法题-🤔"><a href="#图的算法题-🤔" class="headerlink" title="图的算法题 🤔"></a>图的算法题 🤔</h2><table>
<thead>
<tr>
<th>特点</th>
<th>题目</th>
<th>题解</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>🧐基础</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-paths-from--to-target/" >力扣797.所有可能的路径 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td></td>
<td>😏</td>
</tr>
<tr>
<td>⭐拓扑排序<br />深搜dfs+广搜bfs</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/description/" >力扣207.课程表 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/solutions/359392/ke-cheng-biao-by-leetcode-solution/?orderBy=most_votes&languageTags=cpp" >官方题解 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 👍</td>
<td>😔</td>
</tr>
<tr>
<td>⭐二分图判定算法</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-graph-bipartite/?utm_=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china" >力扣785.判断二分图 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td></td>
<td>😏</td>
</tr>
<tr>
<td>⭐并查集</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/surrounded-regions/" >力扣130.被围绕的区域 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/surrounded-regions/solutions/369110/bei-wei-rao-de-qu-yu-by-leetcode-solution/?orderBy=most_votes&languageTags=cpp" >官方题解 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 👍</td>
<td>😔</td>
</tr>
<tr>
<td>⭐并查集</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-provinces/" >力扣547.省份数量 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td></td>
<td>😏</td>
</tr>
<tr>
<td>⭐最小生成树<br /> Kruskal算法、Prim算法</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-to-connect-all-points/" >力扣1584. 连接所有点的最小费用 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-to-connect-all-points/solutions/565990/prim-and-kruskal-by-yexiso-c500/?orderBy=most_votes" >大佬题解 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ✌</td>
<td>😢<br />⏱❗</td>
</tr>
<tr>
<td>⭐Dijkstra 算法<br />⭐SPFA 算法<br />⭐最短路</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-maximum-probability/description/" >力扣1514.概率最大的路径 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-maximum-probability/solutions/371278/gai-lu-zui-da-de-lu-jing-by-leetcode-solution/?orderBy=most_votes" >官方题解：Dijkstra算法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> <br /> <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-maximum-probability/solutions/871165/spfa-qiu-zui-duan-lu-ji-bai-jie-jin-100-p2pcs/?q=100&orderBy=most_relevant&languageTags=cpp" >大佬SPFA算法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>😢</td>
</tr>
<tr>
<td>⭐最短路</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/network-delay-time/" >力扣743.网络延迟时间 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td></td>
<td>😔</td>
</tr>
<tr>
<td>⭐最小体力消耗路径</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-minimum-effort/" >力扣1631.最小体力消耗路径 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-minimum-effort/solutions/459765/zui-xiao-ti-li-xiao-hao-lu-jing-by-zerotrac2/?orderBy=most_votes" >大佬题解 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ✌👍<br />(二分,并查,最短路)</td>
<td>🤯</td>
</tr>
<tr>
<td>⭐Floyd算法</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/345/" >343.排序 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="图算法经典问题📓"><a href="#图算法经典问题📓" class="headerlink" title="图算法经典问题📓"></a>图算法经典问题📓</h2><h3 id="dfs深度优先搜索"><a href="#dfs深度优先搜索" class="headerlink" title="dfs深度优先搜索"></a>dfs深度优先搜索</h3><p>具体算法描述：</p>
<p>选择一个起始点 u 作为 当前节点，执行如下操作：</p>
<ol>
<li>访问 当前节点，并且标记当前节点已被访问，然后跳转到 b</li>
<li>如果存在一个和 当前节点 相邻且尚未被访问的节点 v，则将 v 设为当前节点，继续执行a</li>
<li>如果不存在这样的 v，则进行回溯，回溯的过程就是回退 当前节点</li>
</ol>
<p>上述所说的 当前节点 需要用一个栈来维护，每次访问到的节点入栈，回溯的时候出栈。除了栈，另一种实现深度优先搜索的方式是 <strong>递归</strong>，代码更加简单，相对好理解。</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>定义：给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排序，如果满足：<code>对于图G中的任意一条有向边(u, v)，u在排列中都出现在 v 的前面</code>。那么称该排列是图 G 的<code>拓扑排序</code> 。</p>
<p>结论：</p>
<ul>
<li>如果图G中存在环 (即图G不是<code>有向无环图</code>) ，那么图G 不存在拓扑排序。这是因为假设图中存在环 $x_1,x_2,…,x_n,x_1$，那么 $x_1$在排列中必须出现在 $x_n$的前面，但$x_n$同时也必须出现在$x_1$前面，因此不存在一个满足要求的排列，也就不存在拓扑排序</li>
<li>如果图G是有向无环图，那么它的拓扑排序可能不止一种。举一个最极端的例子，如果图G只包含n个节点却没有任何边，那么任意一种编号的排列都可以作为拓扑排序。</li>
</ul>
<p>🤖拓扑排序的框架：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> inDegree[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topologicalSort</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123; </span><br><span class="line">            q.<span class="built_in">push</span>(i);<span class="comment">//先将入度为 0 的点全部入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : adj[u]) &#123;</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        inDegree[v]++; <span class="comment">//u 指向 v，则 v 的入度加 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topologicalSort</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><p>二分图：二分图的顶点集可分割为 <strong>两个互不相交的子集</strong>，图中 每条边 依附的两个顶点 都分属于这两个子集，且两个子集内的顶点不相邻。</p>
<p>问题转换：图的 [双色问题]</p>
<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>匈牙利算法，即图论中寻找最大匹配的算法，主要用于解决一些二分图匹配有关的问题。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>匹配</strong>：匹配是边的集合，在集合中，任意两条边不能有共同的顶点。</p>
<p><strong>最大匹配</strong>：最大匹配的边数称为最大匹配。</p>
<p><strong>完美匹配</strong>：如果一个匹配中，每个顶点都和图中某条边关联，则称此为完美匹配。两个集合能 一 一 映射。</p>
<p><strong>最优匹配</strong>（带权最大匹配）：在带有权值边的二分图中，求一个匹配使得匹配边上的权值和最大。KM算法是一种解决二分图最大权匹配问题的算法，也称为匈牙利算法的优化版。</p>
<p><strong>最小覆盖</strong>：最小覆盖分为 <strong>最小顶点覆盖</strong> 和 <strong>最小路径覆盖</strong> ：</p>
<ul>
<li>最小顶点覆盖是指 最少的顶点数 使得 二分图G的每条边都至少与其中的一个点关联，二分图的<strong>最小顶点覆盖数 等于 二分图的最大匹配数</strong>。</li>
<li>最小路径覆盖 也成为 最小边覆盖，是指用尽量少的不相交的简单路径覆盖二分图中所有的顶点。<strong>二分图的最小路径覆盖数 &#x3D; 顶点数 - 二分图的最大匹配数</strong>。</li>
</ul>
<p><strong>最大独立集</strong>：寻找一个点集，使得其中任意两点在图中无对应边。对于一般图来说，最大独立集是一个 NP完全问题，对于二分图来说：<strong>最大独立集 &#x3D; 定点数 - 二分图的最大匹配数</strong>。</p>
<p><strong>交替路</strong>：如果一条路径的第一条边是匹配边，那么第二条边就必须是非匹配边，第三条边又必须是匹配边，以此类推。这样的路径被称为交替路。</p>
<p><strong>增广路</strong>（增广轨 或 交错轨）：指一条从未匹配的左侧顶点出发，经过一系列交替的匹配边和非匹配边，最终到达未匹配的右侧顶点的路径。具体来说，增广路的第一条边必须是非匹配边，接下来的每一条边都必须交替地是匹配边和非匹配边，最后一条边必须是非匹配边。<br>匈牙利算法的思路就是：通过不断寻找增广路，可以不断增加匹配的大小，从而找到最大匹配。</p>
<h4 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h4><p>匈牙利算法主要用于解决 <strong>二分图的最大匹配数</strong> 和 <strong>最小点覆盖数</strong>。</p>
<p><strong>二分图的最大匹配数问题</strong>：在二分图中 <strong>最多</strong> 能找到多少条 <strong>没有公共端点的边</strong>。</p>
<p>具体实现过程：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> M, N;   		  <span class="comment">//M，N分别表示 左、右 集合的元素数量</span></span><br><span class="line"><span class="type">int</span> Map[MAXN][MAXN];  <span class="comment">//邻接矩阵存图</span></span><br><span class="line"><span class="type">int</span> p[MAXN];          <span class="comment">//记录当前右侧元素所对应的左侧元素</span></span><br><span class="line"><span class="type">bool</span> vis[MAXN];       <span class="comment">//记录右侧元素是否已被访问过</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=N; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[i][j] &amp;&amp; !vis[j]) <span class="comment">//有边且未访问过</span></span><br><span class="line">        &#123;</span><br><span class="line">            vis[j] = <span class="literal">true</span>; <span class="comment">//标记状态为访问过</span></span><br><span class="line">            <span class="keyword">if</span>(p[j] == <span class="number">0</span> || <span class="built_in">mathch</span>(p[j])) </span><br><span class="line">            &#123;<span class="comment">//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配</span></span><br><span class="line">                p[j] = i; <span class="comment">//当前左侧元素 成为当前右侧元素的新匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//返回匹配成功</span></span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//循环结束，仍未找到匹配，返回匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hungarian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis)); <span class="comment">//重置 vis 数组</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">mathch</span>(i))</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>最小点覆盖问题</strong>：找到最少数量的点，使得二分图所有的边都至少有一个端点在这些点之中。</p>
<p>我们只需要一个结论：<strong>一个二分图的最大匹配数 &#x3D; 这个图中的最小覆盖数</strong> （König定理）。</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>主要用于解决一些 <strong>元素分组</strong> 的问题，它管理一系列 不相交的集合，并支持两种操作：</p>
<ul>
<li>合并（Union）：把两个不相交的集合 合并 为一个集合</li>
<li>查询（Find）：查询两个元素是否在同一个集合中</li>
</ul>
<p>并查集的重要思想在于：用集合中的一个元素代表集合。</p>
<p><strong>初始化</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>假设有 编号为1,2,…,n 的 n个元素，我们用一个数组 fa[] 来存储每个元素的父节点（因为每个元素有且只有一个父节点，所以这是可行的）。一开始，我们将它们的父节点设为自己。</p>
<p><strong>查询</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>一层一层访问父节点，直至根节点（根节点的标志就是父节点本身）。要判断两个元素是否属于同一个集合，只要看它们的根节点是否相同即可。</p>
<p><strong>合并</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(i)] = <span class="built_in">find</span>(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>合并操作：先找到两个集合的代表元素，然后将前者的父节点设置为后者即可。当然也可以将后者的父节点设为前者。</p>
<p><strong>合并·路径压缩</strong></p>
<p>路径压缩：把沿途每个节点的父节点都设为根节点，提高并查集查找效率</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x]?x:(fa[x] = <span class="built_in">find</span>(fa[x]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>按秩合并</strong></p>
<p>由于路径压缩只在查询时进行，也只压缩一条路径，所以并查集最终的结构仍然可能是比较复杂的。</p>
<p>当复杂的树与简单的树合并时，应该将简单的树往复杂的树上合并。</p>
<p>用一个数组 rand[] 记录每个根节点对应树的深度（如果不是根节点，其rank相当于以它作为根节点的子树的深度）。一开始把所有元素的rank（秩）设为1。合并时比较两个根节点，把 rank较小者往较大者上合并。</p>
<p>路径压缩和按秩合并一起使用，时间复杂度为O(n)，但很可能破坏 rank 的准确性</p>
<p><strong>初始化（按秩合并）</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>合并（按秩合并）</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="built_in">find</span>(i), y = <span class="built_in">find</span>(j); <span class="comment">//先找到两个根节点</span></span><br><span class="line">    <span class="keyword">if</span>(rank[x] &lt;= rank[y])</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[y] = x;</span><br><span class="line">    <span class="keyword">if</span>(rank[x] == rank[y] &amp;&amp; x!=y)</span><br><span class="line">        rank[y]++; <span class="comment">//如果深度相同且根节点不同，则新的根节点的深度+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>给定一张边带权的无向图 G &#x3D; （V, E)， n &#x3D; |V|, m &#x3D; |E|。由 V 中全部 n 个顶点和 E 中 n-1条边构成的无向连通子图称为 G 的一棵生成树。边的权值之和最小的生成树被称为无向图 G 的最小生成树。</p>
<p>定理：任意一棵最小生成树一定包含无向图中权值最小的边</p>
<p>树：无环连通图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/v2-4f10048ca88fda26f03cf38074b3a8bb_b.jpg"
                      alt="img"
                ></p>
<p>两种算法（思路）</p>
<p><strong>Kruskal 算法</strong></p>
<p>将所有路径排序，然后选取 n-1 条路径，具体选法</p>
<ol>
<li>先选择最小边，此时集合中有两个节点</li>
<li>选取下一条的原则：FIRST 最小 SECOND 是在集合中的节点与剩余节点之间，不能形成回路</li>
<li>重复 n-1 次</li>
</ol>
<p>算法流程：</p>
<ol>
<li>建立并查集，每个点各自构成一个集合</li>
<li>把所有边按照权值从小到达排序，依次扫描每条边（x,y,z）</li>
<li>若 x, y 属于同一集合（连通），则忽略这条边，继续扫描下一条</li>
<li>否则，合并 x, y所在的集合，并把 z 累加到答案中</li>
<li>所有边扫描完成后，第4步中处理过的边就构成最小生成树</li>
</ol>
<p>时间复杂度 $O(m \log m)$</p>
<p>算法模板：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, len;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (Edge&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> len &lt; other.len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> fa[<span class="number">10000</span>], n, m, ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; edge[i].x &gt;&gt; edge[i].y &gt;&gt; edge[i].len;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//按照权变排序</span></span><br><span class="line">    <span class="built_in">sort</span>(edge+<span class="number">1</span>, edge+m+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//并查集初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++) fa[i] = i;</span><br><span class="line">    <span class="comment">//求最小生成树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(edge[i].x);</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">find</span>(edge[i].y);</span><br><span class="line">        <span class="keyword">if</span>(x == y) <span class="keyword">continue</span>;</span><br><span class="line">        fa[x] = y;</span><br><span class="line">        ans += edge[i].z;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>Prim 算法</strong></p>
<ol>
<li>随机选择一个点P</li>
<li>遍历与P连通的点，找到最小路径连接的另一个点，这个点必须是还没有访问过，将该点加入集合，记录添加的边。</li>
<li>把与当前集合可以访问的所有边和点，选一个最短路径连接的点在纳入集合，如此重复，直到没有新的点可以加入</li>
<li>此时所有边构成的树为最小生成树</li>
</ol>
<p>算法示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">1000</span>][<span class="number">1000</span>], dist[<span class="number">1000</span>], n, m, ans;</span><br><span class="line"><span class="type">bool</span> in[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in">sizeof</span>(in));</span><br><span class="line">    </span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            <span class="keyword">if</span>(!in[j] &amp;&amp; (x == <span class="number">0</span> || dist[j]&lt;dist[x])) x = j;</span><br><span class="line">		in[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">1</span>; y&lt;=n; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!in[y])</span><br><span class="line">                dist[y] = <span class="built_in">min</span>(dist[y], a[x][y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//构建邻接矩阵</span></span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++) a[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, len;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; len;</span><br><span class="line">        a[x][y] = a[y][x] = <span class="built_in">min</span>(a[x][y], z);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//求最小生成树</span></span><br><span class="line">    <span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i&lt;=n; i++) ans+=dist[i];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><p>其主要思想是贪心，具体地说：</p>
<ul>
<li><p>将所有节点分成两类：已确定从起点到当前点的最短路长度的节点，以及未确定从起点到当前点的最短路长度的节点（下面简称「未确定节点」和「已确定节点」）。</p>
</li>
<li><p>每次从「未确定节点」中<strong>取一个与起点距离最短的点</strong>，将它归类为「已确定节点」，并用它「<strong>更新</strong>」从起点到其他所有「未确定节点」的距离。<strong>直到所有点都被归类为「已确定节点」</strong>。</p>
</li>
<li><p>用节点 A「更新」节点 B 的意思是，用 起点到节点 A 的最短路长度 加上 从节点 A 到节点 B 的边的长度，去比较 起点到节点 B 的最短路长度，如果前者小于后者，就用前者更新后者。这种操作也被叫做「松弛」。</p>
</li>
</ul>
<p>Dijkstra 算法基本策略：使用邻接列表来表示图，查找从起始顶点到所有其他顶点的最短路径，优先级队列用于在每次迭代中有效地选择距离最小的顶点。</p>
<p>🤖代码框架：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dijkstra</span><span class="params">(vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt;&amp; graph, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = graph.<span class="built_in">size</span>();<span class="comment">//顶点的数量</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(n, INT_MAX)</span></span>;<span class="comment">//存储点到起点的距离</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; ,greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">    <span class="comment">// min-heap priority queue</span></span><br><span class="line">    </span><br><span class="line">    dist[start] = <span class="number">0</span>;<span class="comment">//起点自身到起点的距离为0</span></span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0.</span>start&#125;);<span class="comment">//将起点放入优先队列中</span></span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u = pq.<span class="built_in">top</span>().second;<span class="comment">//得到最短距离对应的点</span></span><br><span class="line">        <span class="type">int</span> d = pq.<span class="built_in">top</span>().first;<span class="comment">//得到对应距离</span></span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//如果当前距离大于距离数组中存储的值，则跳过它</span></span><br><span class="line">        <span class="keyword">if</span>(d &gt; dist[u]) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; edge: graph[u])&#123;</span><br><span class="line">            <span class="type">int</span> v = edge.first; <span class="comment">//附近的点</span></span><br><span class="line">            <span class="type">int</span> w = edge.second;<span class="comment">//边u-v的权</span></span><br><span class="line">            <span class="comment">//如果更短距离找到，则更新</span></span><br><span class="line">            <span class="keyword">if</span>(dist[u]+w &lt; dist[v])&#123;</span><br><span class="line">                dist[v] = dist[u]+w;<span class="comment">//更新</span></span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dist[v], v&#125;); <span class="comment">//将 v 放入优先队列中</span></span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>例图：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/v2-a4a9a98ff20adfd0d027013610ebc5e4_r.jpg"
                      alt="img" style="zoom:50%;" 
                >

<h3 id="SPFA-算法"><a href="#SPFA-算法" class="headerlink" title="SPFA 算法"></a>SPFA 算法</h3><p>SUMMARY</p>
<ul>
<li>初始化除源顶点为0之外的所有顶点的无限距离数组。</li>
<li>创建一个空队列，并将源顶点加入其中。</li>
<li>如果队列不为空，执行如下操作:<br>a. 删除队列最前面的顶点。<br>b. 对于该顶点的每个邻居，计算到它的距离(即到当前顶点的距离+它们之间边的权重)。c. 如果该距离小于邻居的当前距离，则更新距离数组，并将该邻居加入队列(如果它尚未在队列中)。</li>
<li>重复第3步，直到队列为空或所有顶点都被访问过。</li>
<li>distance数组现在包含了从源顶点到图中所有其他顶点的最短距离。</li>
</ul>
<p>🤖以下是SPFA算法的框架，使用C++编写：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; adj[MAXN];</span><br><span class="line"><span class="type">int</span> dist[MAXN];</span><br><span class="line"><span class="type">bool</span> inQueue[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dist, INF, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(inQueue, <span class="literal">false</span>, <span class="built_in">sizeof</span>(inQueue));</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    inQueue[start] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        inQueue[u] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[v.first] &gt; dist[u] + v.second) &#123;</span><br><span class="line">                dist[v.first] = dist[u] + v.second;</span><br><span class="line">                <span class="keyword">if</span> (!inQueue[v.first]) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v.first);</span><br><span class="line">                    inQueue[v.first] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个实现中，<code>adj</code>是一个邻接表，表示图中的边，其中每个元素是一个形如<code>(v, w)</code>的对，表示从当前节点到节点<code>v</code>有一条权重为<code>w</code>的边。<code>dist</code>是一个数组，存储从起点到图中每个节点的最短距离。<code>inQueue</code>是一个布尔数组，用于记录一个节点当前是否在队列中。</p>
<p><code>SPFA</code>函数以起点作为输入，使用队列进行最短路径搜索。它将所有节点的距离初始化为无穷大，除了起点，起点的距离为0。然后将起点加入队列，并将其<code>inQueue</code>标志设置为true。</p>
<p>然后，函数进入一个循环，直到队列为空为止。在每次迭代中，它从队列中取出一个节点<code>u</code>，将其<code>inQueue</code>标志设置为false。然后检查<code>u</code>的所有邻居，并在找到更短的路径时更新它们的距离。如果邻居的距离被更新，则函数检查它是否已经在队列中。如果不在，则将其加入队列，并将其<code>inQueue</code>标志设置为true。</p>
<p>最后，<code>main</code>函数读取输入，调用<code>SPFA</code>函数，并输出图中所有节点的最短距离。如果一个节点从起点不可达，则输出其距离为“INF”。</p>
<p><strong>SPFA算法和Dijkstra算法的差别</strong></p>
<p>SPFA算法和Dijkstra算法都是用于在加权图中寻找最短路径的算法。但是，它们之间有一些不同之处：</p>
<ol>
<li>时间复杂度：Dijkstra算法使用优先队列，其时间复杂度为O(ElogV)，其中E是边数，V是顶点数。另一方面，SPFA算法的最坏时间复杂度为O(VE)，比Dijkstra算法慢。但是，在实践中，SPFA算法在 <strong>稀疏图</strong> 上的表现通常比Dijkstra算法好。</li>
<li>负权重：Dijkstra算法不能处理图中的负权重，因为它假设所有边的权重都是非负的。另一方面，SPFA算法可以处理负权重，但如果图中包含负环，则可能无法终止。</li>
<li>内存使用：Dijkstra算法需要使用优先队列来存储顶点，这可能会对大型图形成内存压力。SPFA算法使用简单的队列，需要更少的内存。</li>
<li>优化：Dijkstra算法可以使用斐波那契堆或桶队列等技术进行优化，以提高其性能。SPFA算法没有太多可用的优化技术，因为它已经是一个简单的算法。</li>
</ol>
<p>总之，Dijkstra算法在大多数图形上比SPFA算法更快，更节省内存，但不能处理负权重。SPFA算法可以处理负权重，但在某些图形上可能比Dijkstra算法慢，内存效率低。</p>
<h3 id="A-算法"><a href="#A-算法" class="headerlink" title="A* 算法"></a>A* 算法</h3><p>A*算法的主要框架如下：</p>
<ol>
<li>初始化起始节点，其代价为0。</li>
<li>创建一个开放列表，并将起始节点添加到其中。</li>
<li>创建一个关闭列表。</li>
<li>当开放列表不为空时： a. 从开放列表中选择具有最低f值（f &#x3D; g + h，其中g是从起始节点到当前节点的代价，h是当前节点到目标节点的估算代价）的节点。 b. 如果选择的节点是目标节点，则已找到最短路径。返回路径。 c. 否则，将所选节点从开放列表中删除并将其添加到关闭列表中。 d. 对于所选节点的每个邻居： i. 如果邻居已经在关闭列表中，则跳过。 ii. 计算邻居的g值，作为从起始节点到邻居节点经过所选节点的代价。 iii. 如果邻居不在开放列表中，则将其添加到开放列表中，并将其h值计算为从邻居到目标节点的估算代价。 iv. 如果邻居已经在开放列表中，并且它的新g值低于旧的g值，则更新其g值，并更新其父节点为所选节点。</li>
<li>如果开放列表为空且未找到目标节点，则从起始节点到目标节点没有路径。返回失败。</li>
</ol>
<h3 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h3><p>Floyd算法 是解决任意两点间的最短路径的一种算法 是一种插点算法 可以正确处理有向图或带负权非回路的最短路径算法 同时也被用于计算有向图的传递闭包 Floyd时间复杂度为$O(N^3)$，空间复杂度为$O(N^2)$。Floyd 算法是基于 <strong>动态规划</strong> 的多源最短路算法。</p>
<p>最优子结构：图结构中一个显而易见的定理：<strong>最短路径的子路径仍然是最短路径</strong>。</p>
<p>一般的动态规划，设定 <code>dist[k][i][j]</code> 为经过前 k 的节点，从i 到 j 所得到的最短路径，<code>dist[k][i][j]</code> 可以从 <code>dist[k-1][i][k]+dist[k-1][k][j]</code> 转移过来，可以看出，k的状态完全由 k-1 转移过来，只要 将 k 的循环放在最外层就能保证无后效行。最后得到 <code>dist[k][j][i] = min(dist[k-1][i][k]+dist[k-1][k][j], dist[k][j][i])</code> 。</p>
<p>观察可知，可以用 <strong>滚动数组</strong> 进行优化，降低空间复杂度。分析可知 <code>dist[i][j]</code> 依赖于 <code>f[i][k]+dist[k][j]</code>，在更新<code>dist[m][n]</code>时，用到<code>dist[m][k]+dist[k][n]</code>。</p>
<p>最终的方程：<code>dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j])</code> </p>
<p>🤖算法框架：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the distance matrix</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dist[i][j] = graph[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the distance matrix</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] != INT_MAX &amp;&amp; dist[k][j] != INT_MAX &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如何找到具体的路径呢？在 Floyd 算法中，只需要在更新 <code>dist[i][j]</code>的时候，更新中间节点就可以了。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dist[i][k] != INT_MAX &amp;&amp; dist[k][j] != INT_MAX &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class="line">    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">    path[i][j] = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>打印路径</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">getPath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; path, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(path[i][j] == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>+i+<span class="string">&quot; &quot;</span>+j;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> k = path[i][j];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getPath</span>(path, i, k)+<span class="string">&quot; &quot;</span>+<span class="built_in">getPath</span>(path, k, j)+<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注</strong>：Floyd 算法只能在<strong>不存在负权环</strong>的情况下（可以有负权值）使用，因为其并不能判断负权环，如果有负权环，最短路将无意义。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.acwing.com/media/article/image/2022/03/07/64858_2a411f1d9e-floyd%E6%80%BB%E6%89%8E.png"
                      alt="floyd.png" style="zoom:33%;" 
                >

<h3 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a><a href="https://carolinebaby.github.io/2023/04/10/tarjan%E7%AE%97%E6%B3%95/">Tarjan算法</a></h3><h3 id="差分约束算法"><a href="#差分约束算法" class="headerlink" title="差分约束算法"></a>差分约束算法</h3><p>差分约束系统是下面这种形式的多元一次不等式组（$y_1$, $y_2$, …, $y_n$ 为已知量）<br>$$<br>\begin{cases}<br>x_{c_1} - x_{c_1’} \leqslant y_1\<br>x_{c_2} - x_{c_2’} \leqslant y_2\<br>…\<br>x_{c_m} - x_{c_m’} \leqslant y_m<br>\end{cases}<br>$$</p>
<p>（每个不等式称为一个约束条件，都是两个未知量之差小于或等于某个常数）很多题目都会给出一系列不等关系，我们都可以尝试把它们转化为差分约束系统来解决。</p>
<p><strong>问题转化</strong></p>
<p>我们设 $x_1 - x_2 \leqslant c$ ，移项得  $x_1\leqslant x_2 + c $ ，观察这个不等式 与 <strong>最短路问题</strong> 中的 三角不等式 $dist[u] \leqslant dist[u]+w_{v,u}$ 的相似之处。利用这一点，我们可以把它转化为一个 图论 问题。也就是说，对于每一个 $x_{c_i} - x_{c_i’} \leqslant y_i$，我们都从 $c_i’$ 到 $c_i$ 建一条边，边权为 $y_i$。</p>
<p>这样建出的 <strong>有向图</strong>，它的每个顶点都对应差分约束系统中的一个未知量，<strong>源点到每个顶点的最短路对应这些未知量的值</strong>，而每条 边 对应一个 约束条件。</p>
<p>$\begin{cases} x_1 - x_2 \leqslant 3\ x_2 - x_3 \leqslant -2\ x_1 - x_3 \leqslant 1 \end{cases}$ <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="图/差分约束.png"
                      alt="差分约束" style="zoom: 16%;" 
                ></p>
<p>那么既然是最短路，源点在哪？实际上取哪个点为源点无关紧要，但是有时候得到的图不连通，这样求出的结构很容易出现 INF。为了避免这种情况，我们人为增加一个 <strong>超级源点</strong>。</p>
<p>例如在上面的图中人为增加一个 0 号点（或 n+1 号点），从它向所有顶点连一条边权为 0 的边：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/v2-77e41054d2ea49e8f61ce8d98fa3c20d_b.jpg"
                      alt="img" style="zoom: 50%;" 
                >

<p>现在我们以 0 号点为源点求各点的最短路即可。注意这相当于添加了以下约束条件：</p>
<p>$\begin{cases} x_1 - x_0 \leqslant 0\ x_2 - x_0 \leqslant 0\ x_3 - x_0 \leqslant 0 \end{cases}$</p>
<p>由于 $x_0$ 对应的是 $dist[0]$，而 $dist[0] &#x3D; 0$，可知所有未知量均小于等于 0（反映在图形上所有点的最短路 均小于等于 0）。实际上我们往往要求的是非负解。因为这只是一组解，我们可以在一组解上加上或减去同一个数，得到的解同样符合原系统。此时，对 $x_j-x_i ≤k$ 连一条边权为 k 的有向边 $&lt;i, j&gt;$，此时用 $x_j$ 表示超级源点到 $j$ 的最短路，用 $x_i$ 表示超级源点到 $i$ 的最短路，由于 边 $&lt;i,j&gt;$ 存在，从而 $x_j ≤ x_i+k$ ，即为原不等式的变形。</p>
<p>在有解的情况下，最短路的答案 $d_i$ 就是原不等式的解。</p>
<p><strong>连边方法</strong></p>
<p>差分约束问题可以转化为 最短路 或 最长路问题，所以两种转化也就成了两种不同的连边方法。</p>
<ul>
<li><p>连边后求最短路</p>
<p>将 $x_j-x_i ≤ k$ 变形为 $x_j≤x_i+k$ ，即从 $i$ 到 $j$ 连一条边权为 ｋ的边。加入超级源点后求最短路，得到 $x_i≤0$ 的所有x最大解。</p>
</li>
<li><p>连边后求最长路</p>
<p>将$x_j-x_i≤k$ 变形为 $x_i≥x_j-k$，即从 $j$ 到 $i$ 连一条边权为 -k 的边，加入超级源点后求最长路，得到 $x_i≥0$ 的所有x最大解。</p>
</li>
</ul>
<p>如果图存在负环，如果一直沿着负环走，最短路径将会越来越小，最后到达 $−∞$，则不等式组无解。</p>
<p>此时，可以使用 SPFA，只需要在使用 SPFA 的同时用一个数组来记录每个顶点入队次数，如果一个顶点入队次数大于 n，说明该图存在负环。</p>
<p><strong>解决方案</strong></p>
<p>一、<code>SPFA</code></p>
<ol>
<li><strong>一开始将所有点放入队列</strong>中而不是只放一个起点，这样每个点都被作为起点讨论过。</li>
<li><strong>建一个虚拟源点 0，从这个虚拟源点向其他所有点都连一条长度为 0 的边，以虚拟源点为起点放入队列</strong>，这样的效果与前一种完全相同。</li>
</ol>
<p>二、<code>Bellman-Ford</code></p>
<p><strong>无需操作</strong>，算出来的答案本来就是正确的。</p>
<p>因为每次松弛是<strong>对所有边进行操作</strong>，不会出现只计算一个连通块的情况。</p>
<p><strong>代码</strong></p>
<ul>
<li><p>最短路 + SPFA</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; graph;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dis;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">inque</span><span class="params">(n+<span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt;  <span class="title">vis</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">	dis[<span class="number">0</span>] = <span class="number">0</span>, vis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		inque[cur] = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;graph[cur].<span class="built_in">size</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> nx = graph[cur][i].first;</span><br><span class="line">			<span class="type">int</span> len = graph[cur][i].second;</span><br><span class="line">			<span class="keyword">if</span>(dis[nx] &gt; dis[cur] + len)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[nx] = dis[cur]+len;</span><br><span class="line">				<span class="keyword">if</span>(!inque[nx])</span><br><span class="line">				&#123;</span><br><span class="line">					q.<span class="built_in">push</span>(nx);</span><br><span class="line">					inque[nx] = <span class="literal">true</span>;</span><br><span class="line">					vis[nx]++;</span><br><span class="line">					<span class="keyword">if</span>(vis[nx] &gt; n+<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	graph.<span class="built_in">resize</span>(n+<span class="number">1</span>), dis.<span class="built_in">resize</span>(n+<span class="number">1</span>), dis.<span class="built_in">assign</span>(n+<span class="number">1</span>, INT_MAX);</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b, c;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		graph[b].<span class="built_in">emplace_back</span>(a, c); <span class="comment">//注意，不要把 a 和 b 的位置放反了</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		graph[<span class="number">0</span>].<span class="built_in">emplace_back</span>(i, <span class="number">0</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">spfa</span>()) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">			cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>最长路 + SPFA</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在上面的代码基础上只需修改部分地方：</span></span><br><span class="line">dis[nx] &lt; dis[cur] + len</span><br><span class="line">dis.<span class="built_in">assign</span>(n+<span class="number">1</span>, -INT_MAX);</span><br><span class="line">graph[a].<span class="built_in">emplace_back</span>(b, c);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>最短路 + Bellman-Ford</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, l;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; e;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dis;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Bellman_Ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;n; i++) <span class="comment">//进行 n-1 次松弛操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">			dis[e[j].y] = <span class="built_in">min</span>(dis[e[j].y], dis[e[j].x]+e[j].l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">        <span class="keyword">if</span>(dis[e[i].x] + e[i].l &lt; dis[e[i].y]) <span class="comment">//如果还松弛</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	e.<span class="built_in">resize</span>(m+<span class="number">1</span>), dis.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; e[i].y &gt;&gt; e[i].x &gt;&gt; e[i].l;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Bellman_Ford</span>())</span><br><span class="line">   		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++) cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="同余最短路"><a href="#同余最短路" class="headerlink" title="同余最短路"></a>同余最短路</h3><p>当出现形如「给定 n 个整数，求这 n 个整数能拼凑出多少的其他整数（n 个整数可以重复取）」，以及「给定 n 个整数，求这 n 个整数不能拼凑出的最小（最大）的整数」，或者「至少要拼几次才能拼出模 K 余 p 的数」的问题时可以使用同余最短路的方法。</p>
<p>同余最短路利用同余来构造一些状态，可以达到优化空间复杂度的目的。</p>
<p>利用同余构造的状态可以看作单源最短路中的点。同余最短路的状态转移是$f(i+y) &#x3D; f(i) + y$，类似单源最短路中 $f(v) &#x3D; f(u) +edge(u,v)$。</p>
<h2 id="算法题解🔑"><a href="#算法题解🔑" class="headerlink" title="算法题解🔑"></a>算法题解🔑</h2><h3 id="深度优先搜索基础dfs-basic"><a href="#深度优先搜索基础dfs-basic" class="headerlink" title="深度优先搜索基础dfs basic"></a>深度优先搜索基础dfs basic</h3><p><code>Description</code></p>
<p>输入一个有向图，从顶点1开始，按照标号从小到大做dfs，对边进行分类。</p>
<p>我们在做dfs的时候，当访问到一个节点时，会出现四种情况：</p>
<p>1.此节点未被访问过，则此次的访问关系边（发起点——&gt;接受点）称为树边（tree edge）；</p>
<p>2.此节点被访问过但此节点的子孙还没访问完，换句话说，此次的发起点的源头可以追溯到接收点，则此次访问关系边称为后向边（back edge）；</p>
<p>3.此节点被访问过且此节点的子孙已经访问完，而且发起点是搜索初始边，则称为前向边（down edge）；</p>
<p>4.此节点被访问过且此节点的子孙已经访问完，而且发起点不是搜索初始边，则称为横叉边（cross edge）。</p>
<p><code>Input</code></p>
<p>输入的第一行包含两个整数n和m，n是图的顶点数，m是边数。1&lt;&#x3D;n&lt;&#x3D;100，0&lt;&#x3D;m&lt;&#x3D;10000。</p>
<p>接下来的m行，每行是一个数对u v，表示存在有向边(u,v)。顶点编号从1开始。</p>
<p>接下来的1行，包含一个整数k，表示会查询k条边的类型。</p>
<p>接下来的k行，每行是一个数对u v，表示查询边u v的类型。</p>
<p><code>Output</code></p>
<p>对每条查询的边，单独一行输出边的类型，参见输出样例。</p>
<p><code>Sample InputCopy</code> </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4 6</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">4 2</span><br><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">3 1</span><br><span class="line">1 3</span><br><span class="line">4 2</span><br></pre></td></tr></table></figure></div>

<p><code>Sample OutputCopy</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">edge (1,2) is Tree Edge</span><br><span class="line">edge (3,1) is Back Edge</span><br><span class="line">edge (1,3) is Down Edge</span><br><span class="line">edge (4,2) is Cross Edge</span><br></pre></td></tr></table></figure></div>

<p>答案：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> matrix[<span class="number">101</span>][<span class="number">101</span>]; </span><br><span class="line"><span class="type">bool</span> isvisited[<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> edgeKind[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> vers, edges;</span><br><span class="line">string kind[<span class="number">4</span>] = &#123;<span class="string">&quot;Tree Edge&quot;</span>, <span class="string">&quot;Back Edge&quot;</span>, <span class="string">&quot;Cross Edge&quot;</span>, <span class="string">&quot;Down Edge&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isAllVisited</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=vers; i++)</span><br><span class="line">		<span class="keyword">if</span>(matrix[v][i]&amp;&amp;(!isvisited[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=vers; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(matrix[v][i])&#123;</span><br><span class="line">			<span class="keyword">if</span>(!isvisited[i])&#123;</span><br><span class="line">				isvisited[i] = <span class="number">1</span>;</span><br><span class="line">				edgeKind[v][i] = <span class="number">0</span>;</span><br><span class="line">				<span class="built_in">DFS</span>(i);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">isAllVisited</span>(i)) edgeKind[v][i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(v != <span class="number">1</span>) edgeKind[v][i] = <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">else</span> edgeKind[v][i] = <span class="number">3</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; vers &gt;&gt; edges;</span><br><span class="line">	<span class="built_in">memset</span>(matrix, <span class="literal">false</span>, <span class="number">101</span>*<span class="number">101</span>*<span class="built_in">sizeof</span>(<span class="type">bool</span>));</span><br><span class="line">	<span class="built_in">memset</span>(isvisited, <span class="literal">false</span>, <span class="number">101</span> * <span class="built_in">sizeof</span>(<span class="type">bool</span>));</span><br><span class="line">	<span class="built_in">memset</span>(edgeKind, <span class="number">-1</span>, (vers + <span class="number">1</span>) * (vers + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;edges; i++)&#123;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		matrix[a][b] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	isvisited[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">DFS</span>(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> test;</span><br><span class="line">	cin &gt;&gt; test;</span><br><span class="line">	<span class="keyword">while</span>(test--)&#123;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;edge (&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;) is &quot;</span> &lt;&lt; kind[edgeKind[a][b]] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h3 id="最小生成树-1"><a href="#最小生成树-1" class="headerlink" title="最小生成树"></a>最小生成树</h3><p><a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-to-connect-all-points/description/?orderBy=most_votes&languageTags=cpp" >力扣1584.连接所有点的最小费用 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>给你一个<code>points</code> 数组，表示 2D 平面上的一些点，其中 <code>points[i] = [xi, yi]</code> 。</p>
<p>连接点 <code>[xi, yi]</code> 和点 <code>[xj, yj]</code> 的费用为它们之间的 <strong>曼哈顿距离</strong> ：<code>|xi - xj| + |yi - yj|</code> ，其中 <code>|val|</code> 表示 <code>val</code> 的绝对值。</p>
<p>请你返回将所有点连接的最小总费用。只有任意两点之间 <strong>有且仅有</strong> 一条简单路径时，才认为所有点都已连接。</p>
<p><strong>示例 1：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://assets.leetcode.com/uploads/2020/08/26/d.png"
                      alt="img"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]</span><br><span class="line">输出：20</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。</span><br><span class="line">注意到任意两个点之间只有唯一一条路径互相到达。</span><br></pre></td></tr></table></figure></div>

<p><strong>示例 2：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[3,12],[-2,5],[-4,1]]</span><br><span class="line">输出：18</span><br></pre></td></tr></table></figure></div>

<p><strong>示例 3：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[0,0],[1,1],[1,0],[-1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure></div>

<p><strong>示例 4：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[-1000000,-1000000],[1000000,1000000]]</span><br><span class="line">输出：4000000</span><br></pre></td></tr></table></figure></div>

<p><strong>示例 5：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[0,0]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= points.length &lt;= 1000</code></li>
<li><code>-106 &lt;= xi, yi &lt;= 106</code></li>
<li>所有点 <code>(xi, yi)</code> 两两不同。</li>
</ul>
<p>方法一：Prim 算法</p>
<ol>
<li>随机选择一个起点，将其加入集合$V_{new}$（$V_{new}$保存已经加入到最小生成树的节点）中。同时，更新此时的数组 lowcost （保存V中每个节点距离集合$V_{new}$中所有节点的最短距离）和数组 v（保存为加入最小生成树的结点，v[i]&#x3D;0未加入，v[i]&#x3D;1 加入）</li>
<li>遍历 lowcost，寻找 lowcost 中的最小值，假设下标为 j，则 j 为 集合V 中离集合$V_{new}$最近的点，将与下标 j 对应的节点加入 $V_{new}$中，并更新数组 lowcost 和 数组 v</li>
<li>找到 lowcost 中的最小值 j 后，此时数组 lowcost 中的所有节点都需要更新，因此此时集合$V_{new}$中的节点增加了节点 j，集合V中的节点离$V_{new}$的最近距离可能缩短。</li>
<li>根据新加入集合$V_{new}$中的节点 j，更新集合V中剩余所有节点的lowcost。</li>
<li>重复步骤2，直到访问所有的节点。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.leetcode-cn.com/1611023745-EuGMdh-image.png"
                      alt="image.png"
                ></p>
<p>绝妙的解题代码：</p>
<p>主要的思想是：Prim算法</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostConnectPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(size &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(size)</span></span>;</span><br><span class="line">        <span class="comment">//存储剩余点到集合的距离，每次添加时都会不断更新</span></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i&lt;size; i++)&#123;</span><br><span class="line">            dist.<span class="built_in">emplace</span>(i, INT_MAX);</span><br><span class="line">            <span class="comment">//first存储下标，second存储与集合的最近距离（需要实时更新）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> minnode;<span class="comment">//记录每次循环的最小长度对应的剩余点</span></span><br><span class="line">        <span class="type">int</span> minlen;<span class="comment">//记录每次循环的最小长度</span></span><br><span class="line">        <span class="type">int</span> lensum = <span class="number">0</span>;<span class="comment">//总和</span></span><br><span class="line">        dist[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//把第一个点作为起始点，先将其距离设为0，在第一次循环将其纳入点集中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">        <span class="comment">//遍历size次，就可以将所有的点纳入点集，形成最小生成树</span></span><br><span class="line">            minlen = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p: dist)&#123;<span class="comment">//遍历剩下的点</span></span><br><span class="line">                <span class="keyword">if</span>(p.second &lt; minlen)&#123;<span class="comment">//更新最小点和最小距离</span></span><br><span class="line">                    minlen = p.second;</span><br><span class="line">                    minnode = p.first;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            lensum+=minlen;<span class="comment">//更新最短距离</span></span><br><span class="line">            dist.<span class="built_in">erase</span>(minnode);<span class="comment">//删除最小距离点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p:dist)&#123;<span class="comment">//更新剩余点到集合的最短路径</span></span><br><span class="line">                p.second = <span class="built_in">min</span>(p.second, (<span class="built_in">abs</span>(points[p.first][<span class="number">0</span>]-points[minnode][<span class="number">0</span>])+<span class="built_in">abs</span>(points[p.first][<span class="number">1</span>]-points[minnode][<span class="number">1</span>])));<span class="comment">//在与新纳入点距离和与之前集合的最小距离中求最小</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lensum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>



<p><strong>力扣1135.最低成本连通所有城市（稀疏图）</strong></p>
<p>想象一下你是个城市基建规划者，地图上有 N 座城市，它们按以 1 到 N 的次序编号。</p>
<p>给你一些可连接的选项 connections，其中每个选项 <code>connections[i] = [city1, city2, cost]</code> 表示将城市 city1 和城市 city2 连接所要的成本。（连接是双向的，也就是说城市 city1 和城市 city2 相连也同样意味着城市 city2 和城市 city1 相连）。</p>
<p>返回使得每对城市间都存在将它们连接在一起的连通路径（可能长度为 1 的）最小成本。<br>该最小成本应该是所用全部连接代价的综合。如果根据已知条件无法完成该项任务，则请你返回 -1。</p>
<p>示例 1：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：N = <span class="number">3</span>, connections = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：</span><br><span class="line">选出任意 <span class="number">2</span> 条边都可以连接所有城市，我们从中选取成本最小的 <span class="number">2</span> 条。</span><br></pre></td></tr></table></figure></div>

<p>示例 2：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：N = <span class="number">4</span>, connections = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释： </span><br><span class="line">即使连通所有的边，也无法连接所有城市。</span><br></pre></td></tr></table></figure></div>



<p>Kruskal 算法：排序+并查集，更适合稀疏表</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;<span class="comment">//父集</span></span><br><span class="line">    <span class="type">int</span> part = <span class="number">0</span>;<span class="comment">//存储集合数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="comment">//并查集--查找</span></span><br><span class="line">        <span class="keyword">if</span> (parent[a] == a)</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(parent[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uni</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="comment">//并查集--合并</span></span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a);</span><br><span class="line">        <span class="type">int</span> pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (pa == pb)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        parent[pa] = pb;<span class="comment">//父母不相同，合并</span></span><br><span class="line">        part --;<span class="comment">//集合数减一</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumCost</span><span class="params">(<span class="type">int</span> N, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;</span><br><span class="line">        part = N;<span class="comment">//集合数初始化为结点数，先把每个结点看成一个集合</span></span><br><span class="line">        parent = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) parent[i] = i;<span class="comment">//初始化父集</span></span><br><span class="line">        <span class="built_in">sort</span>(connections.<span class="built_in">begin</span>(), connections.<span class="built_in">end</span>(),[](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b) &#123; </span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>];</span><br><span class="line">        &#125;);<span class="comment">//按 边的长度 从小到达排列</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;<span class="comment">//最小长度</span></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;&amp; conn : connections) &#123;<span class="comment">//遍历集合</span></span><br><span class="line">            <span class="type">int</span> a = conn[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> b = conn[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> cost = conn[<span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(a);<span class="comment">//a 的爸爸</span></span><br><span class="line">            <span class="type">int</span> pb = <span class="built_in">find</span>(b);<span class="comment">//b 的爸爸</span></span><br><span class="line">            <span class="keyword">if</span> (pa != pb) &#123;<span class="comment">//a,b不在同一集合里面，就进行合并</span></span><br><span class="line">                <span class="built_in">uni</span>(a, b);</span><br><span class="line">                res += cost;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (part == <span class="number">1</span>)<span class="comment">//集合数为1</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>



<h3 id="Dijkstra-算法-1"><a href="#Dijkstra-算法-1" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><p>  <a class="link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-maximum-probability/description/" >力扣1514.概率最大的路径 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>给你一个由 <code>n</code> 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 <code>edges[i] = [a, b]</code> 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 <code>succProb[i]</code> 。</p>
<p>指定两个节点分别作为起点 <code>start</code> 和终点 <code>end</code> ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。</p>
<p>如果不存在从 <code>start</code> 到 <code>end</code> 的路径，请 <strong>返回 0</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex1.png"
                      alt="img"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25</span><br></pre></td></tr></table></figure></div>

<p><strong>示例 2：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex2.png"
                      alt="img"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2</span><br><span class="line">输出：0.30000</span><br></pre></td></tr></table></figure></div>

<p><strong>示例 3：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex3.png"
                      alt="img"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2</span><br><span class="line">输出：0.00000</span><br><span class="line">解释：节点 0 和 节点 2 之间不存在路径</span><br></pre></td></tr></table></figure></div>

<p>解答：</p>
<p>Dijkstra 算法：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">maxProbability</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="type">double</span>&gt;&amp; succProb, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存储每个顶点的邻结点及其对应的距离</span></span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt;&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;edges.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            graph[edges[i][<span class="number">0</span>]].<span class="built_in">emplace_back</span>(edges[i][<span class="number">1</span>], succProb[i]);</span><br><span class="line">            graph[edges[i][<span class="number">1</span>]].<span class="built_in">emplace_back</span>(edges[i][<span class="number">0</span>], succProb[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dijkstra算法</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">double</span>&gt;&gt; pq; </span><br><span class="line">        <span class="comment">//优先队列，存储结点及其到达起点的最大概率</span></span><br><span class="line">        <span class="comment">//自动由大到小排列，选取队列首元素进行分析 </span></span><br><span class="line">        <span class="comment">//pq.first 点的下标， pq.second 点到起点的最大概率</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">prob</span><span class="params">(n,<span class="number">0</span>)</span></span>; <span class="comment">//记录每个顶点到起点的最大概率</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//队列初始化</span></span><br><span class="line">        prob[start] = <span class="number">1</span>;<span class="comment">//起点自身到自身的最大概率是1</span></span><br><span class="line">        pq.<span class="built_in">emplace</span>(start, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每一轮从概率最大的一个点出发，寻找与之相邻的边</span></span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> [v, pr] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(pr &lt; prob[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//遍历与点相邻的点</span></span><br><span class="line">            <span class="comment">//node -- 邻点  nodepr -- 该点到达邻点的概率</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [node, nodepr] : graph[v])&#123;</span><br><span class="line">                <span class="keyword">if</span>(prob[node] &lt; prob[v]*nodepr)&#123;</span><br><span class="line">                    prob[node] = prob[v]*nodepr; <span class="comment">// 更新到达node的概率使之称为最大</span></span><br><span class="line">                    pq.<span class="built_in">emplace</span>(node, prob[node]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prob[end]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">maxProbability</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="type">double</span>&gt;&amp; succProb, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dist</span><span class="params">(n, <span class="number">0</span>)</span></span>;<span class="comment">//记录顶点到点的最大概率</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">inque</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">//记录是否在队列中</span></span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt;&gt;&gt; <span class="built_in">graph</span>(n); <span class="comment">//图</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e: edges)&#123;</span><br><span class="line">            graph[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">1</span>], succProb[i]);</span><br><span class="line">            graph[e[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">0</span>], succProb[i++]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//SPFA 算法</span></span><br><span class="line">        <span class="comment">// 每次将队列中的点取出，来判断是否能进行松弛操作，并判断松弛后的点是否在队列中来决定是否加入队列</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(start);</span><br><span class="line">        dist[start] = <span class="number">1</span>; </span><br><span class="line">        inque[start] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> curnode = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            inque[curnode] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [node, nodepr]: graph[curnode])&#123;</span><br><span class="line">                <span class="comment">//与t相邻的点, nodepr--此邻点到curnode的概率</span></span><br><span class="line">                <span class="keyword">if</span>(dist[node] &lt; dist[curnode]* nodepr)&#123;</span><br><span class="line">                    dist[node] = dist[curnode]*nodepr;</span><br><span class="line">                    <span class="keyword">if</span>(!inque[node])&#123;<span class="comment">//判断是否在队列中</span></span><br><span class="line">                        inque[node] = <span class="literal">true</span>;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>



<p>SPFA算法的应用：</p>
<p>（此题不能使用Dijkstra）</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1073" >洛谷P1073最优贸易 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>简述：一个人在一国旅行，有n个城市，m 条路，每条路连接两个城市，一部分单向道，另一部分双向道。水晶球在n个城市价格不一样，此人想只进行一次贸易来赚差价，如果不能赚钱，则不进行贸易。此人从 1城市 出发到 n城市，可以重复经过同一个城市。</p>
<p>输入：第一行有正整数 n 和 m，分别表示城市数目和道路数目。<br>第二行 n 个整数，表示n个城市水晶球的价格<br>接下来 m 行，每行三个整数 x,y,z。z 表示城市x到城市y之间的单向道路，z&#x3D;2表示这条道路为城市x和城市y之间的双向道路。</p>
<p>输出：一 个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 0。</p>
<p>样例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 5 </span><br><span class="line">4 3 5 6 1 </span><br><span class="line">1 2 1 </span><br><span class="line">1 4 1 </span><br><span class="line">2 3 2 </span><br><span class="line">3 5 1 </span><br><span class="line">4 5 2 </span><br><span class="line">输出：</span><br><span class="line">5</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num, road;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; price;</span><br><span class="line"><span class="comment">//SPFA 算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; travel, <span class="type">int</span> start, <span class="type">int</span> flag, vector&lt;<span class="type">int</span>&gt;&amp; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">inque</span><span class="params">(num, <span class="literal">false</span>)</span></span>;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	</span><br><span class="line">	q.<span class="built_in">push</span>(start);</span><br><span class="line">	inque[start] = <span class="literal">true</span>;</span><br><span class="line">	d[start] = price[start];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		inque[t] = <span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:travel[t])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((<span class="built_in">min</span>(d[t], price[i])&lt;d[i] &amp;&amp; flag) || (<span class="built_in">max</span>(d[t], price[i])&gt;d[i] &amp;&amp; !flag))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(flag) d[i] = <span class="built_in">min</span>(d[t], price[i]);</span><br><span class="line">				<span class="keyword">else</span> d[i] = <span class="built_in">max</span>(d[t], price[i]);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(!inque[i])</span><br><span class="line">				&#123;</span><br><span class="line">					inque[i] = <span class="literal">true</span>;</span><br><span class="line">					q.<span class="built_in">emplace</span>(i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; num &gt;&gt; road;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dmin</span><span class="params">(num, INT_MAX)</span>, <span class="title">dmax</span><span class="params">(num, <span class="number">0</span>)</span></span>;</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ttravel</span>(num),<span class="built_in">retravel</span>(num);</span><br><span class="line">	price.<span class="built_in">resize</span>(num);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">		cin &gt;&gt; price[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;road; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b, z;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; z;</span><br><span class="line">		a--, b--;</span><br><span class="line">		ttravel[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">		retravel[b].<span class="built_in">push_back</span>(a);<span class="comment">//反向构图 </span></span><br><span class="line">		<span class="keyword">if</span>(z == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ttravel[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">			retravel[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">spfa</span>(ttravel, <span class="number">0</span>, <span class="number">1</span>, dmin);</span><br><span class="line">	<span class="built_in">spfa</span>(retravel, num<span class="number">-1</span>, <span class="number">0</span>, dmax);</span><br><span class="line">	<span class="comment">//求最大值，应该反着求，因为最大值求值需要用到上一步的值进行比较 </span></span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">		res = <span class="built_in">max</span>(res, dmax[i]-dmin[i]);</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; res&lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此题目不适合 dijkstra 算法，因为 dijkstra 算法具有累加性，而且测试样例中可能会有环，会导致 dijkstra 反复更新。</p>
<h3 id="二分法-双端队列"><a href="#二分法-双端队列" class="headerlink" title="二分法+双端队列"></a>二分法+双端队列</h3><p>在郊区有 N 座通信基站，P 条 双向 电缆，第 i 条电缆连接基站 Ai 和 Bi。特别地，1 号基站是通信公司的总站，N 号基站位于一座农场中。现在，农场主希望对通信线路进行升级，其中升级第 i 条电缆需要花费 Li。电话公司正在举行优惠活动。农产主可以指定一条从 1 号基站到 N 号基站的路径，并指定路径上不超过 K 条电缆，由电话公司免费提供升级服务。农场主只需要支付在该路径上剩余的电缆中，升级价格最贵的那条电缆的花费即可。求至少用多少钱可以完成升级。</p>
<p>输入格式</p>
<p>第 1 行：三个整数 N，P，K。</p>
<p>第 2..P+1行：第 i+1 行包含三个整数 Ai,Bi,Li。</p>
<p>输出格式</p>
<p>包含一个整数表示最少花费。</p>
<p>若 1 号基站与 N 号基站之间不存在路径，则输出 −1。</p>
<p><strong>题目总结</strong>：求路径的第ｋ＋１大的费用的最小值</p>
<p><strong>思路</strong>：二分法＋双端队列</p>
<p>每次取出对头的元素，如果有就更新</p>
<ul>
<li>边权是 1 ，从堆尾插入</li>
<li>边权是 0 ，从队首插入</li>
</ul>
<p>特别地，可能会有一个元素多次入队，只需关注第一次入队即可。</p>
<p>广度优先搜索，假设把每一个点的每次拓展算作一步（即所有边权值为1），那么可以一直搜索，得到层数。这个层数就是这个点到root的最短路。</p>
<p>相当于把权作为路径长度，s 作为衡量长度的标准，找到最小的 s 使得最短路长度大于或等于k。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, p, k;</span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; graph;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">	dq.<span class="built_in">emplace_back</span>(<span class="number">0</span>); <span class="comment">//从 0 开始</span></span><br><span class="line">	dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(!dq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> t = dq.<span class="built_in">front</span>();</span><br><span class="line">		dq.<span class="built_in">pop_front</span>();</span><br><span class="line">		<span class="keyword">if</span>(visited[t] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">		visited[t] = <span class="literal">true</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> p: graph[t])&#123;</span><br><span class="line">			<span class="type">int</span> len = p.first, nx = p.second;</span><br><span class="line">			<span class="type">bool</span> isBigger = (len &gt; s); <span class="comment">//表示当前的权值是否大于我们猜想的数 </span></span><br><span class="line">			<span class="keyword">if</span>(dist[nx]&gt;dist[t] + isBigger)&#123;</span><br><span class="line">				dist[nx] = dist[t]+isBigger;</span><br><span class="line">				<span class="keyword">if</span>(isBigger) dq.<span class="built_in">emplace_back</span>(nx); <span class="comment">//权值为1的后入队 </span></span><br><span class="line">				<span class="keyword">else</span> dq.<span class="built_in">emplace_front</span>(nx); <span class="comment">//让权值小的优先 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dist[n<span class="number">-1</span>] &lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; p &gt;&gt; k;</span><br><span class="line">	graph.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;p; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b, l;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; l;</span><br><span class="line">		a--, b--;</span><br><span class="line">		graph[a].<span class="built_in">emplace_back</span>(l, b);</span><br><span class="line">		graph[b].<span class="built_in">emplace_back</span>(l, a);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">-1</span>;X:</span><br><span class="line">	<span class="keyword">while</span>(left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">		&#123;</span><br><span class="line">			res = mid;</span><br><span class="line">			right = mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h3><p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/345/" >ACWing343.排序 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<h4 id="Floyd-算法经典应用-——-传递闭包"><a href="#Floyd-算法经典应用-——-传递闭包" class="headerlink" title="Floyd 算法经典应用 —— 传递闭包"></a>Floyd 算法经典应用 —— 传递闭包</h4><blockquote>
<p>传递闭包是指在一个有向图中，如果存在一条从节点 A 到节点 B 的路径，那么节点 A 和节点 B 之间就存在传递关系。传递闭包算法就是用来计算一个有向图的传递闭包的算法。</p>
<p>具体来说，传递闭包算法会对图中的每个节点进行遍历，对于每个节点，它会找到所有可以到达的节点，并将这些节点与该节点建立传递关系。这样，经过一次遍历后，就可以得到图的传递闭包。</p>
<p>传递闭包算法的应用非常广泛，例如在数据库中，可以使用传递闭包算法来计算关系型数据库中的外键约束，以及在编译器中，可以使用传递闭包算法来计算程序中的依赖关系。</p>
</blockquote>
<p>给定 n 个变量和 m 个不等式。其中 n 小于等于 26，变量分别用前 n 的大写英文字母表示。</p>
<p>不等式之间具有传递性，即若 A&gt;B且  B&gt;C，则 A&gt;C。</p>
<p>请从前往后遍历每对关系，每次遍历时判断：</p>
<ul>
<li>如果能够确定全部关系且无矛盾，则结束循环，输出确定的次序；</li>
<li>如果发生矛盾，则结束循环，输出有矛盾；</li>
<li>如果循环结束时没有发生上述两种情况，则输出无定解。</li>
</ul>
<p><strong>输入格式</strong></p>
<p>输入包含多组测试数据。</p>
<p>每组测试数据，第一行包含两个整数 n 和 m。</p>
<p>接下来 m 行，每行包含一个不等式，不等式全部为小于关系。</p>
<p>当输入一行 <code>0 0</code> 时，表示输入终止。</p>
<p><strong>输出格式</strong></p>
<p>每组数据输出一个占一行的结果。</p>
<p>结果可能为下列三种之一：</p>
<ol>
<li>如果可以确定两两之间的关系，则输出 <code>&quot;Sorted sequence determined after t relations: yyy...y.&quot;</code>,其中<code>&#39;t&#39;</code>指迭代次数，<code>&#39;yyy...y&#39;</code>是指升序排列的所有变量。</li>
<li>如果有矛盾，则输出： <code>&quot;Inconsistency found after t relations.&quot;</code>，其中<code>&#39;t&#39;</code>指迭代次数。</li>
<li>如果没有矛盾，且不能确定两两之间的关系，则输出 <code>&quot;Sorted sequence cannot be determined.&quot;</code>。</li>
</ol>
<p><strong>数据范围</strong></p>
<p>2≤n≤26，变量只可能为大写字母 A∼Z。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 26</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">graph</span>(N, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(N, <span class="number">0</span>));</span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dist</span>(N, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(N, <span class="number">0</span>));</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(N, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> <span class="comment">//Floyd算法 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dist = graph; <span class="comment">//复刻</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">			&#123;	<span class="type">int</span> t = (dist[i][k]&amp;dist[k][j])|dist[i][j];</span><br><span class="line">				dist[i][j] = t;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">()</span> <span class="comment">//检查type类型 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		<span class="keyword">if</span>(dist[i][i]) <span class="keyword">return</span> <span class="number">2</span>;<span class="comment">//说明有循环 </span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">			<span class="keyword">if</span>(!dist[i][j] &amp;&amp; !dist[j][i]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//说明某两个字母关系不确定 </span></span><br><span class="line">			</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//成功确定类型 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">get_min</span><span class="params">()</span> <span class="comment">//每次取出最小值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(!visited[j] &amp;&amp; dist[j][i])</span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag) <span class="comment">//说明 没有任何一个字母小于 i 对应的字母 </span></span><br><span class="line">			&#123;</span><br><span class="line">				visited[i] = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>+i; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m, n||m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//初始化 </span></span><br><span class="line">		graph.<span class="built_in">assign</span>(N, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(N, <span class="number">0</span>));</span><br><span class="line">		<span class="type">int</span> type = <span class="number">0</span>, t;</span><br><span class="line">		<span class="comment">//获取输入 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=m ; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			string s;</span><br><span class="line">			cin &gt;&gt; s; </span><br><span class="line">			<span class="type">int</span> a = s[<span class="number">0</span>]-<span class="string">&#x27;A&#x27;</span>, b = s[<span class="number">2</span>]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(!type) <span class="comment">//0--未确定类型 </span></span><br><span class="line">			&#123; <span class="comment">//继续判断 </span></span><br><span class="line">				graph[a][b] = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">floyd</span>();</span><br><span class="line">				type = <span class="built_in">check</span>(); <span class="comment">//判断 type 类型 </span></span><br><span class="line">				<span class="keyword">if</span>(type) t = i; <span class="comment">//如果不为零，则判断出结果，存储循环次数 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//输出 </span></span><br><span class="line">		<span class="keyword">if</span>(!type) cout &lt;&lt; <span class="string">&quot;Sorted sequence cannot be determined.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;Inconsistency found after &quot;</span>&lt;&lt; t &lt;&lt;<span class="string">&quot; relations.&quot;</span> &lt;&lt; endl; </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Sorted sequence determined after &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; relations: &quot;</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++) cout &lt;&lt; <span class="built_in">get_min</span>();</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="Floyd-算法经典应用二"><a href="#Floyd-算法经典应用二" class="headerlink" title="Floyd 算法经典应用二"></a>Floyd 算法经典应用二</h4><p>给定一张无向图，求图中一个至少包含 33 个点的环，环上的节点不重复，并且环上的边的长度之和最小。该问题称为 <strong>无向图的最小环问题</strong>。你需要输出最小环的方案</p>
<p>输入：第一行包含两个整数 N 和 M，表示无向图有 N 个点，M 条边。接下来 M行，每行包含三个整数 u，v，l，表示点 u 和点 v 之间有一条边，边长为 l。</p>
<p>输出格式：输出占一行，包含最小环的所有节点（按顺序输出），如果不存在则输出 <code>No solution</code>。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> second dot</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first len</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n, m, cnt;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; track; <span class="comment">//记录中间点</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">//记录最短路径</span></span><br><span class="line"><span class="comment">//递归处理节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> k = track[i][j];</span><br><span class="line">	<span class="keyword">if</span>(k == <span class="number">-1</span>) <span class="keyword">return</span>; <span class="comment">//没有中间点</span></span><br><span class="line">	<span class="built_in">dfs</span>(i,k);<span class="comment">//先处理前面的节点处理</span></span><br><span class="line">	path.<span class="built_in">emplace_back</span>(k);<span class="comment">//处理中间节点</span></span><br><span class="line">	<span class="built_in">dfs</span>(k,j);<span class="comment">//处理后面的节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getpath</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	path.<span class="built_in">clear</span>();</span><br><span class="line">	path.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">	<span class="built_in">dfs</span>(i, j);</span><br><span class="line">	path.<span class="built_in">emplace_back</span>(j);</span><br><span class="line">	path.<span class="built_in">emplace_back</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++) graph[i][i] = <span class="number">0</span>;</span><br><span class="line">	track.<span class="built_in">resize</span>(n), track.<span class="built_in">assign</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">	<span class="comment">//获取输入</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b, c;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		a--, b--;</span><br><span class="line">		graph[b][a] = graph[a][b] = <span class="built_in">min</span>(graph[a][b], c);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(graph); <span class="comment">//记录最短路径</span></span><br><span class="line">	<span class="comment">//开始处理</span></span><br><span class="line">	<span class="type">int</span> res = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;k; i++)<span class="comment">//i&lt;k, j&lt;k, 保证 dist[i][j] 不经过 k</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>; j&lt;k; j++)<span class="comment">//j=i+1剪枝</span></span><br><span class="line">			&#123;<span class="comment">//graph[j][k]和graph[k][i]都为两点之间的直接距离</span></span><br><span class="line">              <span class="comment">//dist[i][j] 存的是上一轮迭代得到的结果</span></span><br><span class="line">				<span class="keyword">if</span>( (<span class="type">long</span> <span class="type">long</span>)dist[i][j]+graph[j][k]+graph[k][i]&lt;res)</span><br><span class="line">				&#123;<span class="comment">//更新最短路径</span></span><br><span class="line">					res = dist[i][j]+graph[j][k]+graph[k][i];</span><br><span class="line">					<span class="built_in">getpath</span>(i,j,k);<span class="comment">//重新获取最短路径</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//Floyd，更新所有 i j 经过k的最短路径</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; <span class="built_in">j</span>&lt;n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>( dist[i][j]&gt;(<span class="type">long</span> <span class="type">long</span>)dist[i][k]+dist[k][j])</span><br><span class="line">				&#123;</span><br><span class="line">					dist[i][j] = dist[i][k]+dist[k][j];</span><br><span class="line">					track[i][j] = k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(res == INT_MAX) cout &lt;&lt; <span class="string">&quot;No solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> x:path)</span><br><span class="line">			cout &lt;&lt; x+<span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="类Floyd算法-qmi-快速幂"><a href="#类Floyd算法-qmi-快速幂" class="headerlink" title="类Floyd算法+qmi(快速幂)"></a>类Floyd算法+qmi(快速幂)</h4><p><a class="link"   target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/347/" >ACWing345.牛站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p><strong>题目：</strong> 给定一张由 T 条边构成的 <strong>无向图</strong>，点的编号为 1∼1000 之间的整数。求从起点 S 到终点 E 恰好 <strong>经过 N 条边（可以重复经过）的最短路</strong>。</p>
<p><strong>输入格式：</strong></p>
<p>第 1 行：包含四个整数 N，T，S，E。</p>
<p>第 2…T+1 行：每行包含三个整数，描述一条边的边长以及构成边的两个点的编号。</p>
<p>输出格式：输出一个整数，表示最短路的长度</p>
<p><strong>解题思路</strong></p>
<p>在快速幂的框架下做logN次类floyd算法，时间复杂度 $O(logN∗n^3)$</p>
<blockquote>
<p>快速幂是一种用于快速计算幂运算的算法。它的基本思想是将指数不断折半，将底数不断平方，从而快速地计算出幂运算的结果。</p>
<p>具体来说，假设要计算 a 的 n 次幂，可以将 n 表示为二进制形式，例如 n &#x3D; 101101（二进制），则有：</p>
<p>$a^n &#x3D; a^{2^5} * a^{2^4} * a^{2^2} * a^{2^1} * a^{2^0}$</p>
<p>其中，$2^5$、$2^4$、$2^2$、$2^1$、$2^0$ 分别对应二进制数 101101 中的 1 的位置。因此，只需要计算 a 的平方、a 的四次方、a 的八次方、a 的十六次方和 a 的三十二次方，然后将它们乘起来即可得到 a 的 n 次幂。</p>
<p>快速幂算法的时间复杂度为 O(log n)，比朴素的幂运算算法的时间复杂度 O(n) 要快得多。因此，在需要进行大量幂运算的场合，快速幂算法是一种非常有效的算法。</p>
</blockquote>
<p>普通的Floyd算法：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                d[i][j]=<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br></pre></td></tr></table></figure></div>

<p>Floyd可以得到所有点对间的最短距离是因为每次都是一条边一条边的的更新</p>
<p>类Floyd算法</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(N, INT_MAX)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            temp[i][j] = <span class="built_in">min</span>(temp[i][j], a[i][k]+b[k][j]);</span><br></pre></td></tr></table></figure></div>

<p>这种算法具有边的特性，因为它不会拿之前完成计算的数据进行更新，而是用单独的边之间的和进行自我更新。这保证更新时，边数的限制。</p>
<p>第一次拿1条边更新2条边的结果，第二次拿2条边的结果更新四条边的结果，以成倍的速度更新。</p>
<blockquote>
<p>Floyd算法可以用于求解图中任意两点之间的最短路径。它的基本思想是采用动态规划的思想，利用中间节点来逐步优化路径。在Floyd算法的过程中，需要对路径进行多次更新，每次更新时需要遍历整张图。这样的时间复杂度为$O(n^3)$，其中n是节点数。为了优化这个算法，可以使用矩阵乘法快速幂的思想。具体来说，可以将Floyd算法中的多次更新看做是对一个矩阵的多次幂运算。</p>
<p>假设存在一个矩阵A，表示图中节点之间的距离，初始时A的值就是图的邻接矩阵。则经过k次更新后，A的值表示的就是任意两点之间经过不超过k个节点的最短路径。也就是说，A的k次幂就是经过k个中间节点的最短路径。因此，可以通过对A进行矩阵乘法快速幂的运算，来快速得到任意两点之间的最短路径。具体步骤如下：</p>
<ol>
<li>将图的邻接矩阵存储为一个n x n的矩阵A。</li>
<li>对A进行k次幂运算，得到矩阵Ak，表示经过k个中间节点的最短路径。</li>
<li>对于任意两个节点i和j，Ak[i][j]表示i到j的经过k个中间节点的最短路径。</li>
<li>取所有Ak[i][j]中的最小值，即为节点i到节点j的最短路径。</li>
</ol>
<p>使用矩阵乘法快速幂优化Floyd算法的时间复杂度为$O(n^3logk)$，其中n是节点数，k是经过的中间节点数。相对于原始的Floyd算法，优化后的算法可以大大减少计算量，从而提高运行效率。</p>
</blockquote>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 210</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vv vector<span class="string">&lt;vector&lt;int&gt;</span>&gt;</span></span><br><span class="line"><span class="function">vv <span class="title">modle</span><span class="params">(N, vector&lt;<span class="type">int</span>&gt;(N, INT_MAX))</span></span>;</span><br><span class="line"><span class="function">vv <span class="title">graph</span><span class="params">(modle)</span></span>; <span class="comment">//graph[i][j] 存储 i-j 边长的大小</span></span><br><span class="line"><span class="function">vv <span class="title">res</span><span class="params">(modle)</span></span>;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; id;</span><br><span class="line"><span class="type">int</span> m, t, s, e, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(vv&amp; c, vv a, vv b)</span> <span class="comment">//类Floyd算法，矩阵乘法 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">static</span> vv <span class="title">temp</span><span class="params">(modle)</span></span>;</span><br><span class="line">	temp.<span class="built_in">assign</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N, INT_MAX));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i][k]!=INT_MAX)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(b[k][j]!=INT_MAX)</span><br><span class="line">					temp[i][j] = <span class="built_in">min</span>(temp[i][j], a[i][k]+b[k][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qmi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++) res[i][i] = <span class="number">0</span>; <span class="comment">//经过n条边</span></span><br><span class="line">	<span class="keyword">while</span>(m)<span class="comment">//更新过程</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(m&amp;<span class="number">1</span>) <span class="built_in">mul</span>(res, res, graph); <span class="comment">// res=res*graph; 根据k决定是否使用当前 g 的结果去更新 res</span></span><br><span class="line">		<span class="built_in">mul</span>(graph, graph, graph);<span class="comment">// g = g*g; graph 的更新</span></span><br><span class="line">		m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; t &gt;&gt; s &gt;&gt; e;</span><br><span class="line">    <span class="comment">//点数较多，但使用的点较少，可使用 map 离散化数据</span></span><br><span class="line">	<span class="keyword">if</span>(!id.<span class="built_in">count</span>(s)) id[s] = n++;</span><br><span class="line">	<span class="keyword">if</span>(!id.<span class="built_in">count</span>(e)) id[e] = n++;</span><br><span class="line">	s = id[s], e = id[e];</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b, c;</span><br><span class="line">		cin &gt;&gt; c &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="keyword">if</span>(!id.<span class="built_in">count</span>(a)) id[a] = n++;</span><br><span class="line">		<span class="keyword">if</span>(!id.<span class="built_in">count</span>(b)) id[b] = n++;</span><br><span class="line">		a = id[a], b = id[b];</span><br><span class="line">		graph[a][b] = graph[b][a] = <span class="built_in">min</span>(graph[a][b], c);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">qmi</span>(); <span class="comment">//快速幂+Floyd算法</span></span><br><span class="line">	cout &lt;&lt; res[s][e] &lt;&lt; endl; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h3 id="匈牙利算法-1"><a href="#匈牙利算法-1" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p><a class="link"   target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1129" >P1129 [ZJOI2007] 矩阵游戏 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p><strong>题目大意</strong>：矩阵游戏在一个 $n×n$ 黑白方阵进行（颜色有黑白两种），每次可以对矩阵进行两种操作：①行交换操作：交换矩阵的任意两行（即交换对应格子的颜色）②列交换：交换矩阵任意两列</p>
<p><strong>游戏目的</strong>：通过若干次操作，使得方阵的主对角线（左上角到右下角的连线）上的格子均为黑色。</p>
<p>输入：第一行一个整数 T，表示数据的组数，对于每组数据，输入格式如下：</p>
<p>第一行为一个整数，代表方阵的大小 n，接下来 n 行，每行 n 个非 0 即 1 的整数，代表该方阵。其中，0代表白色，1 代表黑色。</p>
<p><strong>输出</strong>：对于每组数据，若关卡有解则输出 <code>Yes</code>，否则输出 <code>No</code>。</p>
<p><strong>分析</strong>：我们把矩阵转化为 二分图（左侧集合代表各行，右侧集合代表各列，某位置为 1 代表该行和该列之间有边）。进行一系列 交换操作，使得 X1 连上 Y1，X2连上Y2，…</p>
<p>大家可以想象，所谓的交换，是不是可以等价为 <strong>重命名</strong>？我们可以在保持当前二分图结构的情况下，把右侧点的编号进行改变，者与交换的效果是等价的。所以让 X1，X2…与 Y1，Y2…一一对应，其实只需要原图最大匹配数为 4就行了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/v2-558540e634e5537df60a0f61bfa1829d_b.jpg"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>代码</strong>：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> Map[<span class="number">205</span>][<span class="number">205</span>], p[<span class="number">205</span>], vis[<span class="number">205</span>], N, T;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=N; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[i][j] &amp;&amp; !vis[j])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(p[j] == <span class="number">0</span> &amp;&amp; <span class="built_in">match</span>(p[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                p[j] = i;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hungarian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">match</span>(i)) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="built_in">sizeof</span>(p));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=N; j++)</span><br><span class="line">                cin &gt;&gt; Map[i][j];</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">Hungarian</span>();</span><br><span class="line">        <span class="keyword">if</span>(res == N) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><a class="link"   target="_blank" rel="noopener" href="https://vijos.org/p/1204" >(vijos1204)CoVH之柯南开锁 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p><strong>题目大意</strong>：有一个矩阵锁，由 M*N 个格子组成，其中某些格子凸起（灰色），每一次操作可以把一行格子给按下去。求把所有凸起格子按下去所需的最少次数。</p>
<p><strong>输入</strong>：第一行 两个不超过 100 的整数 N，M表示矩阵的 长和宽<br>以下 N 行，每行 M 个数，非 0 即 1，1表示凸起方格</p>
<p><strong>输出</strong>：一个整数，所需的最小次数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.vijos.org/fs/1557c96115c93850f07546ed228ba7797f616190"
                      alt="图片"
                ></p>
<p>把样例转化为 二分图的形式为：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/v2-c7cd484003b71bf480546ac21fd19669_b.jpg"
                      alt="img" style="zoom:33%;" 
                >

<p>按下一行其实就是删掉与某一个点相连的所有边，现在要求最少的操作次数，就相当于求 最小点覆盖数。直接用匈牙利算法即可。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> matrix[<span class="number">102</span>][<span class="number">102</span>];</span><br><span class="line"><span class="type">int</span> p[<span class="number">102</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">102</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="comment">//匈牙利算法模板，和上一道题目类似</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(matrix[x][i] &amp;&amp; !vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			vis[i] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(p[i] == <span class="number">0</span> || <span class="built_in">match</span>(p[i]))</span><br><span class="line">			&#123;</span><br><span class="line">				p[i] = x;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hungarian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">match</span>(i))</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">char</span> c;</span><br><span class="line">			cin &gt;&gt; c;</span><br><span class="line">			matrix[i][j] = c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">Hungarian</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>（TYVJ P1035）棋盘覆盖</p>
<p><strong>题目</strong>：给出一张 n*n（n&lt;&#x3D;100） 的国际象棋棋盘，其中被删除了一些点，问可以使用多少 1*2 的多米诺骨牌进行掩盖。</p>
<p><strong>输入格式</strong>：第一行为 n，m（表示有 m 个删除的格子）<br>第二行到 m+1 行为 x,y，分别表示删除格子所在的位置，x 为 第 x 行，y 为第 y 列。</p>
<p><strong>输出格式</strong>：一个数，即最大覆盖个数</p>
<p>把棋盘染色，每个多米诺骨牌恰好覆盖一个白格和一个黑格。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/v2-94394273ebce1f9cfd2ee50dfd1f22e1_b.jpg"
                      alt="img" style="zoom: 50%;" 
                >

<p>删除一些格子：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/v2-952b78faeed7a68af4349357e34efe8f_b.jpg"
                      alt="img" style="zoom:50%;" 
                >

<p>现在求多米诺骨牌最大覆盖数。</p>
<p>染色之后，黑格与白格可以构成一个二分图，每个白格都只与黑格相连，每个黑格也只与白格相连。在给所有黑格和白格编号后，我们把每个未删除的格子都与它上下左右紧邻的未删除的格子相连。很显然，这张二分图的最大匹配数，就是我们能放下最多多米诺骨牌数。注意，因为数据范围比较大，要用邻接表存图。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; del; <span class="comment">//存储点是否被删除 </span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; graph; <span class="comment">//存图，第一个下标即点对应idx的值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; link;<span class="comment">//存储与该点相连的点</span></span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; vis;<span class="comment">//存储点是否访问过</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//常用的坐标数组，方便书写代码</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">idx</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*n + y; <span class="comment">//转换坐标，转换二维坐标为一维坐标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匈牙利算法模板</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i: graph[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			vis[i] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(link[i] == <span class="number">-1</span> || <span class="built_in">match</span>(p[i]))</span><br><span class="line">			&#123;</span><br><span class="line">				link[i] = x;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hungarian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n*n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		vis.<span class="built_in">assign</span>(n*n, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">match</span>(i)) cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	del.<span class="built_in">resize</span>(n*n), del.<span class="built_in">assign</span>(n*n, <span class="literal">false</span>);</span><br><span class="line">	graph.<span class="built_in">resize</span>(n*n), vis.<span class="built_in">resize</span>(n*n), link.<span class="built_in">resize</span>(n*n), link.<span class="built_in">assign</span>(n*n, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> dx, dy;</span><br><span class="line">		cin &gt;&gt; dx &gt;&gt; dy;</span><br><span class="line">		dx--, dy--; <span class="comment">//记得减一，因为输入的坐标从 1 开始</span></span><br><span class="line">		del[<span class="built_in">idx</span>(dx, dy)] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++ )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!del[<span class="built_in">idx</span>(i,j)])<span class="comment">//如果点能用</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k&lt;<span class="number">4</span>; k++)<span class="comment">//存储相连的点</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> nx = i+dirs[k][<span class="number">0</span>];</span><br><span class="line">				<span class="type">int</span> ny = j+dirs[k][<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span>(nx&gt;=<span class="number">0</span> &amp;&amp; nx&lt;n &amp;&amp; ny&gt;=<span class="number">0</span> &amp;&amp; ny&lt;n &amp;&amp; !del[<span class="built_in">idx</span>(nx,ny)])</span><br><span class="line">				&#123;</span><br><span class="line">					graph[<span class="built_in">idx</span>(i,j)].<span class="built_in">emplace_back</span>(<span class="built_in">idx</span>(nx,ny));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="built_in">hungarian</span>()/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="同余最短路-1"><a href="#同余最短路-1" class="headerlink" title="同余最短路"></a>同余最短路</h3><p><a class="link"   target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3403" >P3403 跳楼机 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>题目大意</strong>：给定 $x，y，z，h$，对于 $k \in [1,h]$，有多少个 $k$ 能够满足 $ax+by+cz&#x3D;k$。（$0\leq a,b,c，1\le x,y,z\le 10^5，h\le 2^{63}-1$）</p>
<p><strong>分析</strong>：首先可以将 $h$ 减去 $1$，同时起始楼层设为 0。设 $d_i$ 为能够到达的最低的mod x &#x3D; i 的楼层。</p>
<p>则有 $i\stackrel{y}{\longrightarrow} (i+y)\mod x$ 和 $i\stackrel{z}{\longrightarrow} (i+z)\mod x$ 。</p>
<p>像这样建图后，$d_i$ 就相当于 $0\longrightarrow i$ 的最短路，SPFA 即可。</p>
<p>最后统计时， 对于 $d_i ≤ h$ ，答案即为：$\sum_{i&#x3D;0}^{x-1}\left(\frac{h-d_i}{x} + 1\right)$<br>加 1 是由于 $d_i$ 所在楼层也算一次。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>,<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;&gt;&gt; graph;</span><br><span class="line">vector&lt;<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt; dis;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> h, x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">inque</span><span class="params">(x, <span class="literal">false</span>)</span></span>;</span><br><span class="line">	q.<span class="built_in">emplace</span>(<span class="number">1</span>);</span><br><span class="line">	dis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		inque[cur] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> t: graph[cur])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> nx = t.second;</span><br><span class="line">			<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> len = t.first;</span><br><span class="line">			<span class="keyword">if</span>(dis[nx] &gt; dis[cur]+len)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[nx] = dis[cur]+len;</span><br><span class="line">				<span class="keyword">if</span>(!inque[nx])</span><br><span class="line">				&#123;</span><br><span class="line">					q.<span class="built_in">emplace</span>(nx);</span><br><span class="line">					inque[nx] = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;h, &amp;x, &amp;y, &amp;z);</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>||y==<span class="number">1</span>||z==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt; h &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	graph.<span class="built_in">resize</span>(x+<span class="number">1</span>), dis.<span class="built_in">resize</span>(x+<span class="number">1</span>),dis.<span class="built_in">assign</span>(x+<span class="number">1</span>, LONG_LONG_MAX/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;x; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		graph[i].<span class="built_in">emplace_back</span>(y, (i+y)%x);</span><br><span class="line">		graph[i].<span class="built_in">emplace_back</span>(z, (i+z)%x);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">spfa</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;x; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dis[i]&lt;=h)</span><br><span class="line">			ans += (h-dis[i])/x + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>（<a class="link"   href="https://link.zhihu.com/?target=https://atcoder.jp/contests/arc084/tasks/arc084_b" >ARC84B Small Multiple <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）</p>
<p>题目大意：给一个k，对于所有k的倍数，求这些数中十进制下各位和的最小值。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要在上面的代码基础上改动的地方：</span></span><br><span class="line"><span class="comment">//初始化graph数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;k; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i != (i+<span class="number">1</span>)%k) graph[i].<span class="built_in">emplace_back</span>(<span class="number">1</span>, (i+<span class="number">1</span>)%k);</span><br><span class="line">    <span class="keyword">if</span>(i != (<span class="number">10</span>*i)%k) graph[i].<span class="built_in">emplace_back</span>(<span class="number">0</span>, (<span class="number">10</span>*i)%k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果输出</span></span><br><span class="line">cout &lt;&lt; <span class="number">1</span>+dis[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// spfa 的改动的地方:初始化</span></span><br><span class="line">dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">emplace</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></div>


        </div>

        
            <div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> 图论学习</li>
        <li><strong>Author:</strong> 卡布叻_米菲</li>
        <li><strong>Created at
                :</strong> 2023-04-08 09:54:55</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2023-05-13 16:33:36
            </li>
        
        <li>
            <strong>Link:</strong> https://carolinebaby.github.io/2023/04/08/图/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/">#算法学习</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                    <div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="prev"
                        rel="prev"
                        href="/2023/04/10/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">算法中的数学</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="next"
                        rel="next"
                        href="/2023/03/29/%E6%A0%91/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">树</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
            <div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
                <div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://caroline-world-42jy0ja18-carolinebaby.vercel.app',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          requiredMeta: ['nick', 'mail'],
          emoji: [],
          recaptchaV3Key: "wasd",
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

            </div>
        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">图论学习</div>
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%A6%82%E5%BF%B5%F0%9F%A7%90"><span class="nav-text">图的定义和概念🧐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98-%F0%9F%A4%94"><span class="nav-text">图的算法题 🤔</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%F0%9F%93%93"><span class="nav-text">图算法经典问题📓</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dfs%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">dfs深度优先搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-text">二分图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="nav-text">匈牙利算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">最小生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra-%E7%AE%97%E6%B3%95"><span class="nav-text">Dijkstra 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPFA-%E7%AE%97%E6%B3%95"><span class="nav-text">SPFA 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-%E7%AE%97%E6%B3%95"><span class="nav-text">A* 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#floyd%E7%AE%97%E6%B3%95"><span class="nav-text">floyd算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tarjan%E7%AE%97%E6%B3%95"><span class="nav-text">Tarjan算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%AE%97%E6%B3%95"><span class="nav-text">差分约束算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E4%BD%99%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-text">同余最短路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%F0%9F%94%91"><span class="nav-text">算法题解🔑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%9F%BA%E7%A1%80dfs-basic"><span class="nav-text">深度优先搜索基础dfs basic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-1"><span class="nav-text">最小生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra-%E7%AE%97%E6%B3%95-1"><span class="nav-text">Dijkstra 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPFA%E7%AE%97%E6%B3%95"><span class="nav-text">SPFA算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-text">二分法+双端队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Floyd-%E7%AE%97%E6%B3%95"><span class="nav-text">Floyd 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-1"><span class="nav-text">匈牙利算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E4%BD%99%E6%9C%80%E7%9F%AD%E8%B7%AF-1"><span class="nav-text">同余最短路</span></a></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">卡布叻_米菲</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        16 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.1</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>





    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>









<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>
