<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="C++">
    
    <meta name="author" content="卡布叻_米菲">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://carolinebaby.github.io/2023/03/01/c++基础知识/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="这个笔记是我上课跟着老师讲解，并按照ppt上的内容进行整理和整合。实时更新ing~">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 基础知识学习">
<meta property="og:url" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="Caroline&#39;s World">
<meta property="og:description" content="这个笔记是我上课跟着老师讲解，并按照ppt上的内容进行整理和整合。实时更新ing~">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230223160434402.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230223160619812.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230323142945866.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230302152610758.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230309143844748.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230330150856153.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%83%BD%E9%87%8D%E8%BD%BD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230504102514795.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230504101943996.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230504102105604.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230504102614055.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230504115449591.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230518155822471.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230518160058527.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615150811607.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615151036096.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615151216828.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615151337749.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615151449580.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615152153340.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615152240917.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615152339676.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615152414454.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615152546198.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615152726812.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615152959585.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615153058006.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615153510895.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615153803274.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615153832106.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615154012292.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615154900417.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615154828914.png">
<meta property="og:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615155036568.png">
<meta property="article:published_time" content="2023-03-01T09:30:39.000Z">
<meta property="article:modified_time" content="2024-02-08T05:09:05.715Z">
<meta property="article:author" content="Caroline">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://carolinebaby.github.io/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230223160434402.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
    <meta name="theme-color" content="#0072BC">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <!--- Page Info-->
    
    <title>
        
            C++ 基础知识学习 -
        
        卡布叻_米菲的世界
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
        <style>
    :root {
        --preloader-background-color: #fff;
        --preloader-text-color: #000;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --preloader-background-color: #202124;
            --preloader-text-color: #fff;
        }
    }

    @media (prefers-color-scheme: light) {
        :root {
            --preloader-background-color: #fff;
            --preloader-text-color: #000;
        }
    }

    @media (max-width: 600px) {
        .ml13 {
            font-size: 2.6rem !important; /* Adjust this value as needed */
        }
    }

    .preloader {
        display: flex;
        flex-direction: column;
        gap: 1rem; /* Tailwind 'gap-4' is 1rem */
        align-items: center;
        justify-content: center;
        position: fixed;
        padding: 12px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh; /* 'h-screen' is 100% of the viewport height */
        background-color: var(--preloader-background-color);
        z-index: 1100; /* 'z-[1100]' sets the z-index */
        transition: opacity 0.2s ease-in-out;
    }

    .ml13 {
        font-size: 3.2rem;
        /* text-transform: uppercase; */
        color: var(--preloader-text-color);
        letter-spacing: -1px;
        font-weight: 500;
        font-family: 'Chillax-Variable', sans-serif;
        text-align: center;
    }

    .ml13 .word {
        display: inline-flex;
        flex-wrap: wrap;
        white-space: nowrap;
    }

    .ml13 .letter {
        display: inline-block;
        line-height: 1em;
    }
</style>

<div class="preloader">
    
<script src="/js/libs/anime.min.js"></script>

    <h1 class="ml13">
        卡布叻_米菲的世界
    </h1>
    <script>
        var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });


        anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [100,0],
                translateZ: 0,
                opacity: [0,1],
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i
            }).add({
            targets: '.ml13 .letter',
            translateY: [0,-100],
            opacity: [1,0],
            easing: "easeInExpo",
            duration: 1200,
            delay: (el, i) => 100 + 30 * i
        });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            hidePreloaderAfterTimeout(1000); // Hide after 1000 milliseconds once the window has loaded
        });

        // Backup failsafe: Hide preloader after a maximum of 5000 milliseconds, regardless of the window load event
        hidePreloaderAfterTimeout(5000);

        function hidePreloaderAfterTimeout(delay) {
            setTimeout(function () {
                var preloader = document.querySelector('.preloader');
                preloader.style.opacity = '0';
                setTimeout(function () {
                    preloader.style.display = 'none';
                }, 200);
            }, delay);
        }
    </script>
</div>
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    <!--- Font Part-->
    
    
    
    


    <script id="hexo-configurations">
    window.config = {"hostname":"carolinebaby.github.io","root":"/","language":"en"};
    window.theme = {"articles":{"style":{"font_size":"18px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left","headings_top_spacing":{"h1":"5rem","h2":"4rem","h3":"2.8rem","h4":"2.5rem","h5":"2.2rem","h6":"2rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#0072BC","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"https://cdn.dynamicwallpaper.club/wallpapers/0lt9t1k10ae/thumbs/1600/2.jpg","dark":"https://cdn.dynamicwallpaper.club/wallpapers/0lt9t1k10ae/thumbs/1600/5.jpg"},"title":"Welcome to Caroline's world!","subtitle":{"text":["这里是 卡布叻_米菲 的世界！"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"style":"default","links":{"github":"https://github.com/Carolinebaby","instagram":null,"zhihu":null,"twitter":null,"email":"1474396199@qq.com"},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.6.1","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"About":{"icon":"fa-regular fa-user","submenus":{"Me":"/about","Blog":"https://carolinebaby.github.io/","Github":"https://github.com/Carolinebaby"}}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":"Hi~Welcome~","show_on_mobile":true,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"},"shuoshuo":{"path":"/shuoshuo","icon":"fa-regular fa-comment-dots"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2023/4/8 08:29:29"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.1.1"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
<!--        <span class="swup-progress-icon">-->
<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
<!--        </span>-->
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container px-6 md:px-12">

    <div class="navbar-content ">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/charlie3.jpg">
                </a>
            
            <a class="logo-title" href="/">
                
                卡布叻_米菲的世界
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-user fa-fw"></i>
                                    ABOUT
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a href="/about">
                                                    ME
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a href="https://carolinebaby.github.io/">
                                                    BLOG
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://github.com/Carolinebaby">
                                                    GITHUB
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-About"
                        >
                            <span>
                                ABOUT
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-About">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="/about">ME</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="https://carolinebaby.github.io/">BLOG</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://github.com/Carolinebaby">GITHUB</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/tags"
                        >
                            <span>Tags</span>
                            <i class="fa-regular fa-tags fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/shuoshuo"
                        >
                            <span>Shuoshuo</span>
                            <i class="fa-regular fa-comment-dots fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">4</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">3</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">16</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container flex relative justify-between box-border w-full h-full">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                <div class="w-full flex items-center pt-6 justify-start">
                    <h1 class="article-title-regular text-second-text-color text-4xl md:text-6xl font-bold px-2 sm:px-6 md:px-8 py-3">C++ 基础知识学习</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/images/QQ%E5%A4%B4%E5%83%8F.jpg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">卡布叻_米菲</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-03-01 17:30:39</span>
        <span class="mobile">2023-03-01 17:30:39</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-02-08 13:09:05</span>
            <span class="mobile">2024-02-08 13:09:05</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/C-%E5%AD%A6%E4%B9%A0/">C++学习</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/C/">C++</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <p>这个笔记是我上课跟着老师讲解，并按照ppt上的内容进行整理和整合。实时更新ing~</p>
<span id="more"></span>
<h1 id="c">C++</h1>
<p>常识：C++之父：Bjarne Stroustrup</p>
<p>C++作为一门面向对象的语言，具有面向对象编程的众多特点：1、封装、继承和多态
2、作为抽象数据类型的类 3、易于调试和维护</p>
<p><strong>封装</strong></p>
<p>封装，即
隐藏对象的属性和实现细节，仅对外公开接口，控制程序对类属性的读取和修改。</p>
<ul>
<li>对于类的内部，成员函数可以自由修改成员变量，进行更精确的控制；</li>
<li>对于类的外部，良好的封装能够减少耦合，同时隐藏实现细节。</li>
</ul>
<p><strong>抽象</strong></p>
<ul>
<li>数据抽象：只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。</li>
<li>过程抽象：是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。</li>
</ul>
<p><strong>继承</strong></p>
<p>即子类继承父类的特征和行为，使得子类具有父类的成员变量和方法。</p>
<p><strong>多态</strong></p>
<p>即同一个行为具有多个不同表现形式或形态的能力。表现形式有覆盖和重载。</p>
<h3 id="类型">类型</h3>
<p>对象、引用、函数（包括函数模板特化）和表达式具有称为类型的性质，它限制了对这些实体所容许的操作，并给原本寻常的位序列提供了语义含义。</p>
<h4 id="类型的分类">类型的分类</h4>
<p>C++类型系统由以下类型组成：</p>
<ol type="1">
<li><strong>基础类型</strong></li>
</ol>
<ul>
<li><p><code>void</code> 类型</p></li>
<li><p><code>std::nullptr_t</code> 类型</p></li>
<li><p><strong>算数类型</strong></p>
<ul>
<li><p><strong><code>bool</code> 类型</strong></p>
<p>sizeof(bool) 的值由实现定义，而且不一定是 1</p></li>
<li><p><strong>字符</strong>类型：</p>
<ul>
<li>窄字符类型：
<ul>
<li>通常字符类型（char、signed char、unsigned char）</li>
<li>char8_t 类型(C++20 起)</li>
</ul></li>
<li>宽字符类型（char16_t、char32_t、 (C++11 起)wchar_t）</li>
</ul></li>
<li><p><strong>有符号整数</strong>类型：short int、int、long int、long
long int (C++11 起)</p></li>
<li><p><strong>无符号整数</strong>类型：unsigned short int、unsigned
int、unsigned long int、unsigned long long int (C++11 起)</p></li>
<li><p><strong>浮点</strong>类型：float、double、long double</p></li>
</ul></li>
</ul>
<ol start="2" type="1">
<li><strong>复合类型</strong></li>
</ol>
<ul>
<li>引用类型：左值引用类型、右值引用类型</li>
<li>指针类型：指向对象的指针类型、指向函数的指针类型</li>
<li>指向成员的指针类型：指向数据成员的指针类型、指向成员函数的指针类型</li>
<li>数组类型</li>
<li>函数类型</li>
<li>枚举类型</li>
<li>类类型：非联合体类型、联合体类型</li>
</ul>
<p>补充：标量类型是（可有 cv 限定的）算术、指针、成员指针、枚举和
std::nullptr_t (C++11 起) 类型</p>
<h3 id="主函数">主函数</h3>
<p>程序应当含有一个名字是 <code>main</code>
的全局函数（主函数），它被指定为程序的启动点。它应当有下列形式之一：</p>
<ul>
<li><code>int main() { 函数体 }</code></li>
<li><code>int main(int argc, char* argv[]) { 函数体 }</code></li>
</ul>
<p>在程序启动时，主函数在 <u>初始化具有静态存储期的非局部对象</u>
之后被调用。它是程序在有宿主 (hosted)
环境（即有操作系统）中所指定的入口点。自立程序（启动加载器，操作系统内核，等等）的入口点由实现定义。</p>
<p>主函数具有几项特殊性质：</p>
<ol type="1">
<li>不能在程序的任何地方使用它
<ul>
<li>尤其不能递归调用它</li>
<li>不能取它的地址</li>
</ul></li>
<li>不能预定义，不能重载：实际上，名字 main
在全局命名空间中对函数保留（虽然可以用作类、命名空间、枚举和非全局命名空间中的任何实体的名字，<u>但不能在任何命名空间中将名字是“main”的实体声明为具有
C 语言链接</u>）。</li>
<li>不能定义为被弃置（=delete;），或 (C++11
起)声明为具有任何语言链接、constexpr (C++11 起)、consteval (C++20
起)、inline 或 static。</li>
<li>主函数的函数体不需要包含 return
语句：当控制达到主函数体的末尾而未遇到返回语句时，它的效果是执行 return
0;。</li>
<li>执行返回（或当到达主函数体的末尾时的隐式返回）与先正常离开函数（这将销毁具有自动存储期的对象），然后用和
return 相同的实参来调用 std::exit等价。（std::exit
随即销毁静态对象并终止程序）</li>
<li>主函数的返回类型不能被推导（不允许 auto main() {...}）。</li>
</ol>
<h1 id="io流">IO流</h1>
<p><strong>对象</strong></p>
<ul>
<li>对象是现实世界或抽象世界中 事物的一种计算机表示。</li>
<li>例如：猫tom</li>
<li>面向对象语言中
<ul>
<li>声明 Cat tom</li>
<li>用 tom.color 访问颜色</li>
<li>用 tom.catch() 让tom执行抓老鼠的行为</li>
</ul></li>
</ul>
<p>定义于头文件<code>&lt;iostream&gt;</code>有<strong>三个对象</strong></p>
<ul>
<li><strong>cout</strong> 是标准输出流对象，它可使用文件 stdout
输出</li>
<li><strong>cin</strong> 是标准输入流对象，它可使用文件 stdin 输入</li>
<li><strong>cerr</strong> 是标准错误流对象，它可使用文件 stderr
输出</li>
</ul>
<p><strong>运算符重载</strong></p>
<ul>
<li>C++ 绝大多数运算符都可以重载，即：
<ul>
<li>根据操作数不同，自定义运算符的操作</li>
</ul></li>
<li>例如： <code>&gt;&gt;</code> 和 <code>&lt;&lt;</code>
是位移运算符，它左右操作数必须是整数</li>
<li>C++ 形象地将位移运算符用于流对象输入输出操作，例如：
<ul>
<li><code>cout &lt;&lt; "hello"</code> 的含义是将 hello 字符放入stdout
输出管道；</li>
<li><code>cin &gt;&gt; aInt</code> 的含义是将 stdin
管道输入按"%d"格式转换后放入变量</li>
</ul></li>
<li><code>&lt;&lt;</code> 重载为 输出运算
<ul>
<li>左操作数必须是 输入流对象，右操作数是任意类型</li>
<li>编译器会根据右操作数类型选择合适的 fprintf
格式化语句的版本。如右操作数是 double，输出格式是 "%lf"</li>
<li>表达式返回左操作数的引用，是左值</li>
</ul></li>
<li><code>&gt;&gt;</code> 重载为 输入运算
<ul>
<li>左操作数 必须是 输入流对象，右操作数必须是 左值，任意类型。</li>
<li>编译器自动根据类型使用合适 fscanf</li>
<li>表达式返回左操作数的引用，是左值</li>
</ul></li>
</ul>
<p><strong>输入与输出运算符示例</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* iostream-basic.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> someInt;</span><br><span class="line">    <span class="type">float</span> someFloat;</span><br><span class="line">    <span class="type">char</span> someChar;</span><br><span class="line">    <span class="comment">// fscanf(stdin,"%d%f%c", some...); </span></span><br><span class="line">    cin &gt;&gt; someInt &gt;&gt; someFloat &gt;&gt; someChar;</span><br><span class="line">    <span class="comment">// fprintf(stdout,"the answer is: %f\n", some...); </span></span><br><span class="line">    cout &lt;&lt; <span class="string">"the answer is: "</span> &lt;&lt; someInt * someFloat &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; someChar &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>运算符重载 <strong>不会改变</strong>
<strong>运算符的结合性和优先级</strong>。例如： 位移运算符是左结合，则
<code>cin &gt;&gt; someInt</code> 先计算并<strong>返回 左值
cin</strong>，再继续输出 someFloat，以此类推。</p>
<p>C 语言是 C++
基础。要熟悉表达式的五个要素：<strong>类型、值类别、结合性、优先级、类型兼容与隐式转换</strong></p>
<p><strong>输入/输出操纵符</strong>(Manipulators)</p>
<ul>
<li>操纵符是让 输入/输出对象 控制格式化、或执行 文件操作 的特殊对象</li>
<li>标头 <code>&lt;iostream&gt;</code> 定义了一些无参的操纵符，包括：
<ul>
<li>endl，输出'' 并冲洗输出流。例如：cout &lt;&lt; endl;</li>
<li>dec, hex, oct, 更改用于整数输入/输出的基数(进制)</li>
<li>left, right， 设置填充字符的布置，即左对齐或右对齐</li>
<li>fixed, scientific，更改用于浮点 I/O 的格式化</li>
<li>showpoint, noshowpoint, 控制浮点表示是否始终包含小数点</li>
<li>showpos, noshowpos，控制是否将 + 号与非负数一同使用</li>
</ul></li>
<li>表头<code>&lt;iomanip&gt;</code> 定义了一些 有参的 操纵符函数，包括
<ul>
<li><code>setw(n)</code> ，更改下个输入/输出域的宽度，宽度为 n</li>
<li><code>setprecision(n)</code> ，更改浮点精度</li>
</ul></li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">double</span> myFloat = <span class="number">123.4567</span>;</span><br><span class="line">    <span class="type">int</span> myInt = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; left &lt;&lt; <span class="string">"Float"</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; right &lt;&lt; myFloat &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; left &lt;&lt; <span class="string">"Int"</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; right &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>补充：</p>
<p><code>&lt;iomanip&gt;</code> 中常用的函数</p>
<table>
<thead>
<tr class="header">
<th>控 制 符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dec</td>
<td>设置整数为十进制</td>
</tr>
<tr class="even">
<td>hex</td>
<td>设置整数为十六进制</td>
</tr>
<tr class="odd">
<td>oct</td>
<td>设置整数为八进制</td>
</tr>
<tr class="even">
<td>setbase(n)</td>
<td>设置整数为n进制(n=8,10,16)</td>
</tr>
<tr class="odd">
<td>setfill(n)</td>
<td>设置字符填充，c可以是字符常或字符变量</td>
</tr>
<tr class="even">
<td>setprecision(n)</td>
<td>设置浮点数的有效数字为n位</td>
</tr>
<tr class="odd">
<td>setw(n)</td>
<td>设置字段宽度为n位</td>
</tr>
<tr class="even">
<td>setiosflags(ios::fixed)</td>
<td>设置浮点数以固定的小数位数显示</td>
</tr>
<tr class="odd">
<td>setiosflags(ios::scientific)</td>
<td>设置浮点数以科学计数法表示</td>
</tr>
<tr class="even">
<td>setiosflags(ios::left)</td>
<td>输出左对齐</td>
</tr>
<tr class="odd">
<td>setiosflags(ios::right)</td>
<td>输出右对齐</td>
</tr>
<tr class="even">
<td>setiosflags(ios::skipws)</td>
<td>忽略前导空格</td>
</tr>
<tr class="odd">
<td>setiosflags(ios::showpos)</td>
<td>输出正数时显示"+"号</td>
</tr>
<tr class="even">
<td>setiosflags(ios::showpoint)</td>
<td>强制显示小数点</td>
</tr>
<tr class="odd">
<td>resetiosflags</td>
<td>清除指定的 ios_base 标志</td>
</tr>
</tbody>
</table>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">double</span> PI = <span class="number">3.141592654</span>;</span><br><span class="line">    cout &lt;&lt; PI &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; PI &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; PI &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setfill</span>(<span class="string">'*'</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">20</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; PI &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setfill</span>(<span class="string">'v'</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">20</span>) &lt;&lt; left &lt;&lt; PI &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; scientific &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; PI &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; scientific &lt;&lt; uppercase &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; PI &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; num &lt;&lt; endl; <span class="comment">// 输出十六进制数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">resetiosflags</span>(ios::hex); <span class="comment">// 清除十六进制标志</span></span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl; <span class="comment">// 输出十进制数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h1 id="命名空间">命名空间</h1>
<p>C语言中，每个应用中全局标识符仅能定义一次</p>
<p>C++<strong>命名空间</strong>提供了一种在大项目中避免名字冲突的方法</p>
<ul>
<li><p>在命名空间块内声明的符号被放入一个具名的作用域中，避免这些符号被误认为其他作用域中的同名符号。</p></li>
<li><p>多个命名空间块的名字可以相同。这些块中的所有声明在该具名作用域声明。</p></li>
<li><p>例如：标准库中符号（类型、变量、常量、函数等）都在
<strong>std</strong> 命名空间块中声明。cout 是在 std
命名空间块中声明，则</p>
<ul>
<li>std::cout 则是该变量的有限定名</li>
<li><code>::</code> 是作用域解析运算符</li>
</ul></li>
<li><p>声明具名命名空间</p>
<p><code>namespace 命名空间名{声明序列}</code></p></li>
<li><p>使用其他命名空间的名字</p>
<ul>
<li><p>以 "无限定名"方式使用：直接从 using
指令之后到指令出现的作用域结尾为止，以对任何无限定名字，来自指定命名空间的成员名或指定成员均可见。</p>
<p><code>using namespace 命名空间名</code></p>
<p><code>using  命名空间名::成员名</code></p></li>
<li><p>以"有限定名"
方式使用：随着IDE进步，直接指定使用命名空间中成员更常用。
<code>命名空间名::成员们</code></p></li>
</ul></li>
</ul>
<p><strong>不同命名空间</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> first_space{</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>{</span><br><span class="line">      cout &lt;&lt; <span class="string">"Inside first_space"</span> &lt;&lt; endl;</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 第二个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> second_space{</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>{</span><br><span class="line">      cout &lt;&lt; <span class="string">"Inside second_space"</span> &lt;&lt; endl;</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用第一个命名空间中的函数</span></span><br><span class="line">   first_space::<span class="built_in">func</span>();  <span class="comment">//输出 Inside first_space</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用第二个命名空间中的函数</span></span><br><span class="line">   second_space::<span class="built_in">func</span>(); <span class="comment">//输出 Inside second_space</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p><strong>命名冲突示例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* cout = <span class="string">"hello world c++"</span> &lt;&lt; endl;</span><br><span class="line">    std::cout &lt;&lt; cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<ul>
<li>using namespace std; 表示可使用 std 命名空间内成员名称的指令</li>
<li>但 局部变量 cout 隐藏 std 空间中的定义</li>
<li>std::cout
是标准输出流对象有限定名称，避免了字符串变量cout的命名冲突</li>
<li>注意：C++比C严格，const指针值必须赋给const指针变量。</li>
</ul>
<p><strong>命名空间嵌套示例</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ns-embed.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> sysu {</span><br><span class="line">    <span class="keyword">namespace</span> students {</span><br><span class="line">        <span class="type">int</span> collegeCount;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">printColleges</span><span class="params">()</span></span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> sysu::students::<span class="built_in">printColleges</span>() {</span><br><span class="line">    cout &lt;&lt; <span class="string">"Colleges "</span> &lt;&lt; collegeCount &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> sysu::students;</span><br><span class="line">    collegeCount = <span class="number">23</span>;</span><br><span class="line">    <span class="built_in">printColleges</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<ul>
<li>声明命名空间及其成员</li>
<li>定义空间中成员函数</li>
</ul>
<p>注意: 两个using作用域不同</p>
<p>课堂题：创建函数 : <code>void Handle();</code></p>
<p>在函数中实现如下功能:</p>
<ul>
<li>命名空间<code>mfc</code>中的变量<code>inflag</code>进行操作:
<code>inflag++</code>;</li>
<li>命名空间<code>owl</code>中的变量<code>inflag</code>进行操作:
<code>inflag*2</code>;</li>
<li>全局变量<code>inflag</code>由<code>inflag mod 2</code>
的结果赋值。</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">----------NameSpace.hpp-------------</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Namespace</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Namespace</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> inflag ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mfc {</span><br><span class="line">  <span class="keyword">extern</span> <span class="type">int</span> inflag;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> owl {</span><br><span class="line">  <span class="keyword">extern</span> <span class="type">int</span> inflag;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Handle</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">------------Hanle.cpp----------------</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"NameSpace.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Handle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ::inflag %= <span class="number">2</span>; <span class="comment">//全局变量直接在前面加 ::</span></span><br><span class="line">    (mfc::inflag)++;</span><br><span class="line">    (owl::inflag) *= <span class="number">2</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h1 id="引用">引用</h1>
<p><strong>应用的概念：</strong></p>
<ul>
<li>声明具名的变量引用，即已有对象或函数的别名</li>
<li>应用的特定：使用时类似变量，常作为参数时传引用</li>
</ul>
<p>引入原因：指针强大、灵活，但是程序容易出BUG，难调试</p>
<p>引入可以减少指针使用，甚至替代指针。</p>
<p>应用应该在声明的同时初始化。</p>
<p>引用的值不能为null</p>
<p><strong>左值声明与示例</strong></p>
<p>左值引用的声明：<code>type &amp;别名[= 左值表达式]</code></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">int</span>* p = &amp;a; <span class="comment">// p 是 指针，&amp;a 是a的地址</span></span><br><span class="line">    <span class="type">int</span> &amp;x = a;  <span class="comment">// x 是 引用，它实际上与 a 是同一个变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"x = "</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*p = "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    x = <span class="number">2000</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p><strong>引用不是对象</strong>，它们不必占用存储</p>
<p>因为引用 不是对象，故：</p>
<ul>
<li>不存在引用的数组</li>
<li>不存在指向引用的指针</li>
<li>不存在引用的引用</li>
</ul>
<p>两种引用形式</p>
<ul>
<li><strong>左值引用声明符</strong>：声明 S&amp; D; 是将 <code>D</code>
声明为 <em>声明说明符序列</em> <code>S</code>
所确定的类型的<em>左值引用</em>。</li>
<li><strong>右值引用声明符</strong>：声明 S&amp;&amp; D; 是将
<code>D</code> 声明为 <em>声明说明符序列</em> <code>S</code>
所确定的类型的<em>右值引用</em>。</li>
</ul>
<p><a class="link" target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/reference">引用的详解 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序RefSwap</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">"max = "</span> &lt;&lt; a&lt;&lt; <span class="string">" "</span>&lt;&lt; <span class="string">"min = "</span> &lt;&lt; b;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>提示：c 编译实现采用将a,b的地址作为值传递给函数
swap，但官方并没有定义引用是值为地址的变量，就是变量的别名。这样以保证与其他高级语言的引用概念一致。</p>
<p><strong>指针与引用</strong></p>
<ul>
<li>相同：可以使一个函数向调用者返回多个数值</li>
<li>不同：原理不同
<ul>
<li>引用传递中，形参、实参实质为同一变量，或者说是为某个变量起多了一个名字。</li>
<li>使用指针作为函数参数，则是被调用函数获得某变量的地址，从而使用这个地址访问这个变量。</li>
</ul></li>
<li>从返回值的角度，引用形参比指针方便</li>
</ul>
<p><strong>返回值非引用示例</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">( <span class="type">double</span> x )</span>     </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line"></span><br><span class="line">    y = <span class="built_in">sin</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">double</span> a = <span class="number">3.14</span>/<span class="number">6</span>;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line"></span><br><span class="line">    y = <span class="built_in">f</span>( a );</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"y = "</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></table></figure></div>
<p><img lazyload src="/images/loading.svg" data-src="C++基础知识/image-20230223160434402.png" alt="image-20230223160434402" style="zoom:50%;"></p>
<p><strong>使用引用的返回值示例</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span>&amp; <span class="title">f</span><span class="params">( <span class="type">double</span> x )</span> <span class="comment">//程序ref2</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> y;</span><br><span class="line"></span><br><span class="line">    y = <span class="built_in">sin</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">double</span> a = <span class="number">3.14</span>/<span class="number">6</span>;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line"></span><br><span class="line">    y = <span class="built_in">f</span>( a );</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"y = "</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></table></figure></div>
<p><img lazyload src="/images/loading.svg" data-src="C++基础知识/image-20230223160619812.png" alt="image-20230223160619812" style="zoom:50%;"></p>
<p>注：引用型返回值，不能返回 auto变量</p>
<p><strong>左值引用：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::string s1 = <span class="string">"Test"</span>;</span><br><span class="line"><span class="comment">//  std::string&amp;&amp; r1 = s1;           // 错误：不能绑定到左值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string&amp; r2 = s1 + s1; <span class="comment">// OK：到 const 的左值引用延长生存期</span></span><br><span class="line"><span class="comment">//  r2 += "Test";                    // 错误：不能通过到 const 的引用修改</span></span><br><span class="line"></span><br><span class="line">    std::string&amp;&amp; r3 = s1 + s1;      <span class="comment">// OK：右值引用延长生存期</span></span><br><span class="line">    r3 += <span class="string">"Test"</span>;                    <span class="comment">// OK：能通过到非 const 的引用修改</span></span><br><span class="line">    std::cout &lt;&lt; r3 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h2 id="转发引用">转发引用</h2>
<p>转发引用（Forwarding
Reference）是C++11中引入的一种特殊的引用类型，也称为“完美转发”（Perfect
Forwarding）。它使用双引号（&amp;&amp;）表示，可以将一个参数以原样传递给另一个函数，而不会丢失其值类别（左值或右值）。</p>
<p>转发引用是一种特殊的引用，它保持函数参数的值类别，使得 std::forward
能用来转发参数。转化引用是下列之一：</p>
<ol type="1">
<li><p>函数模板的函数形参，其被声明为同一函数模板的类型模板形参的无cv限定的右值引用
转发引用通常用于模板函数中，以便在不知道参数类型的情况下，将参数转发给其他函数。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(T&amp;&amp; x)</span> <span class="comment">//x 是转发引用</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g</span>(std::forward&lt;T&gt;(x));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">f</span>(i);<span class="comment">//实参是左值，调用 f&lt;int&amp;&gt;, std::forward&lt;int&amp;&gt;(x) 是左值</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>);<span class="comment">//实参是右值，调用 f&lt;int&gt;(int&amp;&amp;), std::forward&lt;int&gt;(x) 是右值</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>需要注意的是，转发引用只能用于函数模板中，而不能用于普通函数或成员函数。</p>
<ol start="2" type="1">
<li>auto&amp;&amp;，但当其从花括号包围的初始化器列表推导时除外：</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; vec = <span class="built_in">foo</span>();       <span class="comment">// foo() 可以是左值或右值，vec 是转发引用</span></span><br><span class="line"><span class="keyword">auto</span> i = std::<span class="built_in">begin</span>(vec); <span class="comment">// 也可以</span></span><br><span class="line">(*i)++;                   <span class="comment">// 也可以</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">g</span>(std::forward&lt;<span class="keyword">decltype</span>(vec)&gt;(vec)); <span class="comment">// 转发，保持值类别</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; x: <span class="built_in">f</span>())</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// x 是转发引用；这是使用范围 for 循环最安全的方式</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; z = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}; <span class="comment">// *不是*转发引用（初始化器列表的特殊情形）</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="悬垂引用">悬垂引用</h2>
<p>尽管引用一旦初始化就始终指代一个有效的对象或函数，但有可能创建一个程序，其中被指代对象的<a class="link" target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/lifetime">生存期 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>结束而引用仍保持可访问（<em>悬垂（dangling）</em>）。访问这种引用是<strong>未定义行为</strong>。
一个常见例子是返回自动变量的引用的函数：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::string s = <span class="string">"Example"</span>;</span><br><span class="line">    <span class="keyword">return</span> s; <span class="comment">// 退出 s 的作用域：调用其析构函数并解分配其存储</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">std::string&amp; r = <span class="built_in">f</span>(); <span class="comment">// 悬垂引用</span></span><br><span class="line">std::cout &lt;&lt; r;       <span class="comment">// 未定义行为：从悬垂引用读取</span></span><br><span class="line">std::string s = <span class="built_in">f</span>();  <span class="comment">// 未定义行为：从悬垂引用复制初始化</span></span><br></pre></td></tr></table></figure></div>
<p>注意，右值引用和到 const 的左值引用能延长临时对象的生存期。</p>
<p>如果被指代对象被销毁（例如通过显式的析构函数调用），但存储尚未被解分配，则到生存期外的对象的引用仍能以有限的方式使用，且当在同一存储中重新创建对象时也可以变为有效</p>
<h2 id="传值与传引用">传值与传引用</h2>
<p>C++的函数参数的传递方式，可以是</p>
<ul>
<li>传值方式。传值的本质是：形参是实参的一份拷贝</li>
<li>传引用的方式。传引用的本质是：形参和实参是同一个对象</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun_1</span><span class="params">(<span class="type">int</span> a)</span></span>; <span class="comment">//int类型，传值（复制产生新变量）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun_2</span><span class="params">(<span class="type">int</span>&amp; a)</span></span>; <span class="comment">//int类型，传引用（形参和实参是同一个东西）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun_3</span><span class="params">(<span class="type">int</span>* arr)</span></span>; <span class="comment">//指针类型，传值（复制产生新变量）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun_4</span><span class="params">(<span class="type">int</span>*&amp; arr)</span></span>; <span class="comment">//指针类型，传引用（形参和实参是同一个东西）</span></span><br></pre></td></tr></table></figure></div>
<p><strong>常 (const 限定) 引用</strong></p>
<p>普通引用：<code>int &amp;a = b</code></p>
<ul>
<li>可以理解为：<code>int* const a = &amp;b</code></li>
<li>即引用是一个指针常量（又称常指针，即一个常量，其类型是指针）</li>
<li>每当编译器遇到引用变量a，就会自动执行<code>*</code>操作</li>
</ul>
<p>常引用：<code>const int&amp; a = b</code></p>
<ul>
<li>就相当于：<code>const int* const a = &amp;b</code></li>
<li>不仅仅是 a 这个地址不可修改，而且其指向的内存空间也不可修改</li>
<li>即：指向常数据的常指针</li>
</ul>
<p>常引用实例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* FIRST 引用普通变量 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">const_ref_without_casting</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;a = b;</span><br><span class="line">    <span class="comment">// a = 12; //error: assignment of read-only reference</span></span><br><span class="line">    b = <span class="number">11</span>; <span class="comment">//这可以改！</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,b=%d\n"</span>, a, b);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* SECOND 引用字面量-实际引用临时变量 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">const_ref_with_constant</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;c = <span class="number">15</span>;</span><br><span class="line">    <span class="comment">//编译器会给常量15开辟一片内存，并将引用名作为这片内存的别名</span></span><br><span class="line">    <span class="comment">// int &amp;d=15; //error: invalid initialization of non-const reference of type 'int&amp;' from an rvalue of type 'int'</span></span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span> *)&amp;c; <span class="comment">//const转非const必须显式</span></span><br><span class="line">    *p = <span class="number">10</span>; <span class="comment">//修改了为15开辟的内存内容</span></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl; </span><br><span class="line">}</span><br><span class="line"><span class="comment">/* THIRD 引用表达式-实际引用临时变量 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">const_ref_with_casting</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;a = b; <span class="comment">// equal to: int temp = b; const int &amp;a = temp</span></span><br><span class="line">    b = <span class="number">11</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,b=%f\n"</span>, a, b);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* FOURTH 常引用参数-不能改变实参 */</span></span><br><span class="line"><span class="comment">// const 限定引用参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">const_ref_in_para</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>{</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* FIFTH 引用参数-可以改变实参 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">no_const_ref_in_para</span><span class="params">(string&amp; s)</span> </span>{</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* SIXTH */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">const_ref_without_casting</span>();</span><br><span class="line">    <span class="built_in">const_ref_with_constant</span>();</span><br><span class="line">    <span class="built_in">const_ref_with_casting</span>();</span><br><span class="line">    <span class="built_in">const_ref_in_para</span>(“I love c++”); <span class="comment">//类型匹配</span></span><br><span class="line">    <span class="comment">//no_const_ref_in_para(“I love c++”); //error：类型不匹配</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h2 id="常变量右值引用">常变量、右值引用</h2>
<p><strong>const 常量（常变量）的特性</strong></p>
<ul>
<li>特性1：是变量。从而可以通过指向该常变量的指针改变常变量的值。</li>
<li>特性2：是常量。直接使用这个常变量的名字，仍然是原来的常量值。</li>
</ul>
<p><strong>右值和右值引用（&amp;&amp;）</strong></p>
<ul>
<li>在C++11中可以取地址的、有名字的就是左值</li>
<li>反之，不能取地址的、没有名字的就是
右值。（简单理解：右值是左值表达式）</li>
<li>右值引用就是 对右值的引用，即对存储右值的临时变量的引用。</li>
<li><strong>右值引用和左值引用 都是 左值</strong></li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">Using <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">Int <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>; <span class="comment">//编译：像普通变量那样，分配空间</span></span><br><span class="line">    <span class="comment">// double *r_pi = π //语法错误？</span></span><br><span class="line">    <span class="type">double</span> *p_pi = (<span class="type">double</span> *)π<span class="comment">//常变量特性1：变量特性，可取地址</span></span><br><span class="line">    *p_pi = <span class="number">4.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(“%lf,%lf\n”,*p_pi,pi); <span class="comment">//常变量特性2：常量特性（编译优化：确保原来的常量值）</span></span><br><span class="line">    <span class="comment">// double &amp;r_pi = pi; //语法错误？</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> &amp;r_pi = pi; <span class="comment">//引用const常量pi，无法修改</span></span><br><span class="line">    <span class="comment">// r_pi = 4.0; //语法错误？</span></span><br><span class="line">    <span class="type">double</span> &amp;&amp;rr_pi = (<span class="type">double</span>)pi; <span class="comment">//右值引用，可修改</span></span><br><span class="line">    rr_pi = <span class="number">5.0</span>;</span><br><span class="line">    <span class="comment">//请解释输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf,%lf,%lf,%lf\n"</span>,*p_pi,r_pi,rr_pi,pi); </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">(<span class="type">int</span> _a)</span> <span class="type">const</span> </span>{ <span class="comment">//常方法</span></span><br><span class="line">        std::cout&lt;&lt;<span class="string">"Test()const"</span>&lt;&lt;std::endl;</span><br><span class="line">        a = _a; <span class="comment">//error 常方法不能修改普通成员变量的值</span></span><br><span class="line">        <span class="type">int</span> d = _a; <span class="comment">//可以访问a，但不能修改a的值</span></span><br><span class="line">        <span class="type">int</span> e = c; <span class="comment">// const函数访问const成员变量</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test2</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">int</span> mf = c; <span class="comment">//普通函数访问const成员变量</span></span><br><span class="line">        std::cout&lt;&lt; <span class="string">"Test2(int,int)"</span> &lt;&lt;std::endl; <span class="comment">//输出该函数</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> _a,<span class="type">int</span> _b,<span class="type">int</span> _c):<span class="built_in">a</span>(_a),<span class="built_in">b</span>(_b),<span class="built_in">c</span>(_c){ </span><br><span class="line">        <span class="comment">//构造函数(常成员可由初始化表进行初始化）</span></span><br><span class="line">        std::cout&lt;&lt; <span class="string">"Test(int)"</span> &lt;&lt;std::endl; <span class="comment">//输出该函数</span></span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c; <span class="comment">//常数据成员。初始方式1：默认初始化；初始方式2：构造函数的初始化表</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">Test <span class="title">tmp</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span></span>; <span class="comment">//调用构造函数生成对象tmp</span></span><br><span class="line">    tmp.<span class="built_in">Test1</span>(<span class="number">10</span>); <span class="comment">//const函数访问常数据成员变量</span></span><br><span class="line">    tmp.<span class="built_in">Test2</span>(); <span class="comment">//普通函数访问常数据成员变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>常数据成员：</p>
<ol type="1">
<li>初始方式1：默认初始化；初始化方式2：构造函数的初始化表</li>
<li>可以成员函数访问（但不允许修改期中的值）</li>
</ol>
<p>常对象：常对象只能调用该类中的常成员函数（ji）</p>
<ol type="1">
<li>可以访问对象中的任何数据成员，但不能修改</li>
<li>可以调用常方法，不能调用不是常方法的其他成员函数</li>
</ol>
<h1 id="数据存储">数据存储</h1>
<ol type="1">
<li><p><strong>代码段 / 文本段（code segment / text
segment）</strong></p>
<ul>
<li>作用：存放指令，运行代码的一块内存空间，存储
函数实现，库实现，字符串等资源，不可改。</li>
<li>该区域的大小在程序运行前就已经确定</li>
<li>内存空间一般属于只读，某些架构的代码也允许可写</li>
<li>在代码段中，也可能包含一些只读的常数变量，例如
<strong>字符串常量</strong> 等</li>
</ul></li>
<li><p>全局区/静态数据存储区域</p>
<ol type="1">
<li><p><strong>数据段（data segment）</strong></p>
<ul>
<li><p>可读可写</p></li>
<li><p>存储初始化的全局变量和初始化的static变量</p></li>
<li><p>数据段中数据的生存期是随程序持续性（随进程持续性）</p>
<p>进程持续性：进程创建就存在，进程结束就消失</p></li>
</ul></li>
<li><p><strong>bss段（bss segment） bss : block start by
symbol</strong></p>
<ul>
<li>可读可写</li>
<li>存储未初始化的全局变量和未初始化的 static 变量</li>
<li>bss段中数据的生存期随进程持续性</li>
<li>bss段中的数据一般默认为 0</li>
</ul></li>
</ol></li>
<li><p><strong>rodata段</strong></p>
<ul>
<li>只读数据</li>
<li>比如 printf
语句中的格式字符串和开关语句的跳转表。也就是常量区。例如：作用域中的
const int ival = 10，ival 存放在rodata 段；再如，函数局部作用域中的
printf("Hello world %d", c); 语句中的格式字符串"Hello world %d"也存放在
rodata段</li>
</ul></li>
<li><p><strong>栈（stack）</strong></p>
<ul>
<li>可读可写</li>
<li>存储的是函数参数或代码段中的局部变量（非 static 变量）</li>
<li>栈的生存期随代码块持续性，代码块运行就分配空间，代码块结束就自动回收空间</li>
</ul></li>
<li><p><strong>堆（heap）</strong></p>
<ul>
<li>可读可写</li>
<li>动态变量（对象）， 由 stdlib.h 管理</li>
</ul></li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="C++基础知识/image-20230323142945866.png" alt="image-20230323142945866" style="zoom: 50%;"></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s1 = <span class="string">"Literal"</span>; <span class="comment">//文字在代码区，仅分配了字符指针</span></span><br><span class="line"><span class="comment">// s1[0] = 'I'; //Segmentation fault</span></span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">"Initial Literal"</span>; <span class="comment">//分配数组空间</span></span><br><span class="line">Point po = Point{<span class="number">2</span>,<span class="number">3</span>}; <span class="comment">//分配结构空间</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>在函数外声明，或者用 static
修饰，则会存储在全局区/静态变量存储区</li>
<li>在函数内声明，则在 栈 中分配空间，并初始化</li>
</ul>
<h2 id="c动态对象变量管理">C动态对象(变量)管理</h2>
<p>堆(Heap)</p>
<ul>
<li>共享的对象(变量)空间</li>
<li>由 stdlib 库管理</li>
</ul>
<p>正确使用堆空间</p>
<ul>
<li>必须 <code>#include&lt;stdlib.h&gt;</code></li>
<li>申请空间，<code>void* malloc(size_t)</code></li>
<li>释放对象，<code>void free(void*)</code>
<ul>
<li>申请的空间 必须释放 ，否则就是内存泄漏</li>
<li>free 后再使用指针或释放，行为不可预测❌</li>
</ul></li>
</ul>
<h2 id="c动态对象变量管理-1">C++动态对象(变量)管理</h2>
<p><strong>C++ 用 malloc 分配对象数组</strong></p>
<p><strong>程序要点</strong></p>
<ul>
<li><code>#include&lt;cstdlib&gt;</code></li>
<li>if 语句判断空间是否分配</li>
<li>注意 malloc 不会调用对象的构造函数，free 不会调用析构函数</li>
<li>初始化对象
<ul>
<li><code>new(void*)</code> 构造函数</li>
</ul></li>
<li>处理构造异常</li>
<li>显式调用析构函数
<ul>
<li><code>ACLASS.~析构函数</code></li>
</ul></li>
<li>最后释放空间</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">//为 4 个 string 的数组分配足够空间</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">auto</span> p = (std::string*)std::<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="built_in">sizeof</span>(std::string))){</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>{</span><br><span class="line">            <span class="keyword">for</span>(; i!= <span class="number">4</span>; i++){</span><br><span class="line">                <span class="keyword">new</span>(p+i) std::<span class="built_in">string</span>(<span class="number">5</span>, <span class="string">'a'</span>+i);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j!=<span class="number">4</span>; j++){</span><br><span class="line">                std::cout &lt;&lt; <span class="string">"p["</span>&lt;&lt; j &lt;&lt;<span class="string">"] == "</span>&lt;&lt; p[j] &lt;&lt; std::endl;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="built_in">catch</span>(...){}</span><br><span class="line">            <span class="keyword">for</span>(; i!=<span class="number">0</span>; i--){</span><br><span class="line">                p[i<span class="number">-1</span>].~<span class="built_in">basic_string</span>();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            std::<span class="built_in">free</span>(p);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>C++新关键字：<strong>new 和 delete 运算符</strong></p>
<p>新关键字优点：</p>
<ul>
<li>new 类型 初始化
<ul>
<li>分配空间</li>
<li>每个对象调用构造函数</li>
<li>有错误抛出异常</li>
</ul></li>
<li>delete[] p
<ul>
<li>为数组每个对象调用析构函数</li>
<li>释放空间</li>
</ul></li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*new-delete-strings*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">//为 n 个 string 的数组分配空间</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line">    string* p = <span class="keyword">new</span> string[n]{</span><br><span class="line">        <span class="built_in">string</span>(<span class="number">5</span>, <span class="string">'a'</span>),</span><br><span class="line">        <span class="built_in">string</span>(<span class="number">5</span>, <span class="string">'b'</span>),</span><br><span class="line">        <span class="built_in">string</span>(<span class="number">5</span>, <span class="string">'c'</span>),</span><br><span class="line">        <span class="built_in">string</span>(<span class="number">5</span>, <span class="string">'d'</span>)</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++){</span><br><span class="line">        cout &lt;&lt; p[i] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h2 id="动态对象变量与对象指针">动态对象(变量)与对象指针</h2>
<p>动态对象的使用</p>
<p>FIRST-创建单个基本数据类型</p>
<ul>
<li>创建：<code>new 类型</code> ，返回该类型的指针，指向新建对象</li>
<li>使用 <code>*p</code> 解析为对象</li>
<li>释放：<code>delete 指针</code></li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Please enter an integer value:"</span>;</span><br><span class="line">    cin &gt;&gt; *p;</span><br><span class="line">    cout &lt;&lt; <span class="string">"The value you enter is:"</span> &lt;&lt; *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>SECOND-创建数组</p>
<ul>
<li>创建：<code>new 类型[]{初始化列表};</code>
<ul>
<li>和定义自动变量类似。没有初始化列表则调用无参构造（默认构造一般式不确定值）；常数初始化列表，后面补零；长度小于初始化列表的长度，抛出异常</li>
<li>返回该类型的指针</li>
</ul></li>
<li>直接使用 p 直接当作数组名使用</li>
<li>释放：<code>delete[] 指针</code></li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> length)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;length; i++){</span><br><span class="line">        p[i]++;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">    <span class="type">int</span> length, i;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Enter the length you want:"</span>;</span><br><span class="line">    cin &gt;&gt; length;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">int</span>[length]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inc</span>(p, length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">        cout &lt;&lt; *(p+i) &lt;&lt;<span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h2 id="new-运算符的使用">new 运算符的使用</h2>
<p><code>指针 = new 类型名;</code> //动态创建一个对象</p>
<p><code>指针 = new 类型名()</code> //动态创建一个对象</p>
<p><code>指针 = new 类型名[数组长度];</code> //用于动态分配数组</p>
<ul>
<li>初始化参数及其括号为可选</li>
<li>类型可为基本类型，也可为 类 类型
<ul>
<li>若为 类 类型， 则初始化参数相当于将
实际参数传递给该类的构造函数</li>
</ul></li>
<li>new 运算返回一个该类型指针(不是 void*)，指向分配到的内存空间</li>
<li><strong>若内存分配失败，抛出异常，不是NULL</strong></li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">int</span>(*[<span class="number">10</span>])();    <span class="comment">// 错误：解析成 (new int) (*[10]) ()</span></span><br><span class="line"><span class="keyword">new</span> (<span class="built_in">int</span> (*[<span class="number">10</span>])()); <span class="comment">// OK：分配 10 个函数指针的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">int</span> + <span class="number">1</span>; <span class="comment">// OK：解析成 (new int) + 1，增加 new int 所返回的指针</span></span><br><span class="line"><span class="keyword">new</span> <span class="type">int</span> * <span class="number">1</span>; <span class="comment">// 错误：解析成 (new int*) (1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span>* p = <span class="keyword">new</span> <span class="type">double</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}; <span class="comment">// 创建 double[3] 类型的数组</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">auto</span>(<span class="string">'c'</span>);            <span class="comment">// 创建单个 char 类型的对象。p 是一个 char*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> q = <span class="keyword">new</span> std::integral <span class="built_in">auto</span>(<span class="number">1</span>);         <span class="comment">// OK: q 是一个 int*</span></span><br><span class="line"><span class="keyword">auto</span> q = <span class="keyword">new</span> std::floating_point <span class="built_in">auto</span>(<span class="literal">true</span>) <span class="comment">// 错误：不满足类型约束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> r = <span class="keyword">new</span> std::<span class="built_in">pair</span>(<span class="number">1</span>, <span class="literal">true</span>); <span class="comment">// OK: r 是一个 std::pair&lt;int, bool&gt;*</span></span><br><span class="line"><span class="keyword">auto</span> r = <span class="keyword">new</span> std::vector;        <span class="comment">// 错误：无法推导元素类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="number">42</span>;</span><br><span class="line"><span class="type">double</span> a[n][<span class="number">5</span>]; <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="type">double</span>[n][<span class="number">5</span>];   <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> <span class="type">double</span>[<span class="number">5</span>][n];   <span class="comment">// 错误：只有第一维可以不是常量</span></span><br><span class="line"><span class="keyword">auto</span> p3 = <span class="built_in">new</span> (<span class="type">double</span>[n][<span class="number">5</span>]); <span class="comment">// 错误：语法 (1) 不能用于动态数组</span></span><br></pre></td></tr></table></figure></div>
<h2 id="delete-操作符的使用">delete 操作符的使用</h2>
<p><code>delete 变量名;</code> //基本用法</p>
<p><code>delete[] 变量名;</code> //用于释放数组</p>
<ul>
<li>如果<strong>动态分配了一个数组</strong>，但是却用 delete p
的方式释放，没有用<code>[]</code>，则
<ul>
<li>编译时没有问题，运行时也一般不会发生错误</li>
<li>但实际上会<strong>导致动态分配的数组没有被完全释放</strong></li>
</ul></li>
<li>delete 释放的是指针所指对象占据的内存</li>
<li>用 delete
释放空间后，指针的值仍然是原来指向的地址，但指针已无效（重复释放将出错）</li>
<li><code>delete 对象指针</code>，会调用对象的析构函数</li>
</ul>
<h2 id="内存泄露">内存泄露</h2>
<p>内存泄漏：指 new
的空间失去了指针或引用永远无法释放。导致资源耗尽！</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//case 1</span></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">7</span>); <span class="comment">// 动态分配的 int 带值 7</span></span><br><span class="line">p = <span class="literal">nullptr</span>; <span class="comment">// 内存泄漏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//case 2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">7</span>);</span><br><span class="line">} <span class="comment">// 内存泄漏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//case 3</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">g</span>();      <span class="comment">// 可能抛出异常</span></span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 如果没有异常则 ok</span></span><br><span class="line">} <span class="comment">// 如果 g() 抛出异常则内存泄漏</span></span><br></pre></td></tr></table></figure></div>
<h1 id="string-类">string 类</h1>
<p>类(class)：是关于同类事物定义的描述。</p>
<p>在面向对象语言中</p>
<ul>
<li>类是对对象的描述，描述对象的属性和行为。</li>
<li>类是模板，它是关于其对象的数据成员和函数成员的描述。</li>
<li>class 是一种数据类型</li>
</ul>
<p>在标准库中有很多类，如以下常用的类</p>
<ul>
<li><code>&lt;string&gt;</code>库中的 <code>std::string</code> 类</li>
<li>输入<code>std::ifstream</code>, <code>std::ofstream</code>类</li>
</ul>
<p>C++提供了以下两种类型的字符串表示形式：</p>
<ul>
<li>C风格字符串 C语言风格字符串是使用null字符'\0'
终止的一维字符数组，需要事先要知道保留多大空间存储字符串，字符串操作strcat要保证目标字符串有足够空间。要用malloc维字符串动态分配空间。</li>
<li>C++的 string 类 类型的对象</li>
</ul>
<h2 id="创建-string-对象">创建 string 对象</h2>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string s1;</span><br><span class="line">    string s2 = <span class="string">"c++"</span>;</span><br><span class="line">    string s3 = s2;</span><br><span class="line">    <span class="function">string <span class="title">s4</span><span class="params">(<span class="number">5</span>, <span class="string">'s'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<ol type="1">
<li>s1 未使用初始化参数，即默认初始化为空字符串。</li>
<li>对象类型 <code>对象=参数1</code>，表示用参数 1 初始化对象。 s2 使用
C字符串初始化，s3 用 s2 初始化（又称拷贝复制）</li>
<li>对象类型 <code>对象(参数列表)</code> 适用于有参数的对象初始化。 s4
初始化为 5 个 s</li>
<li><code>string s2 = "c++"</code>，<strong>不是赋值运算</strong>，它等价于
<code>string s2("C++")</code> 是初始化。</li>
</ol>
<h2 id="string-对象的运算">string 对象的运算</h2>
<p>string 类实现以下 <strong>运算符的重载</strong></p>
<ul>
<li><p>联接运算
operator+，连接两个字符串或者一个字符串和一个字符</p></li>
<li><p>比较运算</p>
<p>operator==, !=, &lt;, &lt;= , &gt; , &gt;= ，&lt;=&gt;,
以字典序比较两个字符串</p></li>
<li><p>下标运算</p>
<p>operator[]， 访问指定字符，返回指定字符引用，即可作为左值</p></li>
<li><p>赋值运算</p>
<p>operator=，
+=，右操作数可以是字符串，字符，C字符串，字符数组</p></li>
</ul>
<p><strong>案例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string s1 = <span class="string">"hello"</span>, s2, s3;</span><br><span class="line">    cin &gt;&gt; s2;</span><br><span class="line">    s3 = s1+s2;</span><br><span class="line">    cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    s1 += {<span class="string">'s'</span>, <span class="string">'y'</span>, <span class="string">'s'</span>, <span class="string">'u'</span>};</span><br><span class="line">    cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>string类实现了许多 string 对象的操作（成员函数）</p>
<ul>
<li><p>基本操作：length，c_str</p>
<p>length() 返回类型为 size_t 的字符串的长度</p>
<p>c_str() 返回类型 const char* 的 C 风格字符串（以null字符结束）</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string s = <span class="string">"sysu-computer"</span>;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* cs = s.<span class="built_in">c_str</span>();</span><br><span class="line">    cout &lt;&lt; cs &lt;&lt; <span class="string">"len is"</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
<li><p>查找：find, rfind
<code>find(string | char* | char s[, int pos = 0])</code>寻找首个等于给定字符序列的子串。搜索始于
pos，返回类型 size_t 的位置。rfind 从右边开始搜索。</p></li>
<li><p>添加，插入，删除：append, insert, erase, clear</p>
<p><code>append(string)</code> 后附 string str</p>
<p><code>append(int count, char ch)</code> 后附 count 个字符 ch</p>
<p><code>insert(int index, int count, char ch)</code> 在 index 位置插入
count 个 ch</p>
<p><code>erase(int index,  int count)</code> 删除从 index 开始的 count
个字符</p>
<p><code>clear()</code> 清空</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string s = <span class="string">"ysu"</span>;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="string">"S"</span>).<span class="built_in">append</span>(<span class="number">1</span>,<span class="string">'-'</span>).<span class="built_in">append</span>(<span class="string">"Computer"</span>);</span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
<li><p>提取子字符串：substr</p>
<p><code>substr(int pos, int count)</code> 返回字串对象</p></li>
<li><p>比较：compare</p>
<p><code>compare(string|char* str)</code> 与 str 比较，返回 1, 0, -1
之一</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string s = <span class="string">"Sysu-Computer"</span>;</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">4</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">compare</span>(<span class="number">5</span>,<span class="number">8</span>,<span class="string">"Computer"</span>) == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"OK!"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
<li><p>替换：replace</p>
<p><code>replace(int pos, int count, string|char*|char s)</code>
替换指定范围的内容</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* str-method-find.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    string s = <span class="string">"sysu-computer"</span>;</span><br><span class="line">    <span class="type">int</span> pos = s.<span class="built_in">find</span>(<span class="string">"computer"</span>);</span><br><span class="line">    s.<span class="built_in">replace</span>(pos,<span class="number">8</span>,<span class="string">"software"</span>);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
<li><p>复制与交换：copy, swap</p>
<p><code>copy(string|char* dest, int pos, int count)</code>
将子串复制到目标对象</p>
<p><code>swap(string other)</code> 与other交换内容</p></li>
<li><p>数值转换（C++11）：stoi, stod</p></li>
</ul>
<p><strong>函数重载</strong></p>
<p>​
在C语言中，一个函数只能定义一个函数名以及相关形参。C++则允许多个函数拥有相同的名字，只要它们的参数列表不同就可以，这就是函数的重载。</p>
<p>借助重载，一个函数名可以有多中用途。</p>
<p><strong>使用C标准库</strong></p>
<p>C++标准库提供了可以在C++中使用的各类基础设施。也包括：</p>
<ul>
<li>C库基础设施的C++标头，即在 std 空间中的 c标准库</li>
<li>C标准库，即不仅可以用 g++编译C风格的cpp程序，也可以使用C库函数</li>
</ul>
<img lazyload src="/images/loading.svg" data-src="/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230302152610758.png" class title="image-20230302152610758">
<p><strong>const 和 constexpr(C++)</strong></p>
<p>C语言中 const 关键字限定变量不可修改。</p>
<p>const有两个语义：</p>
<ul>
<li>限定为 不可修改（只读）变量</li>
<li>限定作为常量或字面量</li>
</ul>
<p>C++11 标准添加关键字
constexpr，声明编译时可以对函数或变量求值。即</p>
<ul>
<li>限定为常量表达式</li>
<li>限定为编译时可优化执行的函数</li>
</ul>
<p>C++ 11标准中，为了解决 const 关键字的双重语义问题，保留了 const
表示“只读”的语义，而将“常量”的语义划分给了新添加的 constexpr
关键字。因此 C++11 标准中，建议将 const 和 constexpr
的功能区分开，即凡是</p>
<ul>
<li>表达“<strong>只读</strong>”语义的场景都使用
<strong>const</strong></li>
<li>表达“<strong>常量</strong>”语义的场景都使用
<strong>constexpr</strong></li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dis_1</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x)</span></span>{</span><br><span class="line">    <span class="comment">//错误，x是只读的变量</span></span><br><span class="line">    array &lt;<span class="type">int</span>,x&gt; myarr{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line">    cout &lt;&lt; myarr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dis_2</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    array &lt;<span class="type">int</span>,x&gt; myarr{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line">    cout &lt;&lt; myarr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   <span class="built_in">dis_1</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="built_in">dis_2</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>dis_1() 函数中的“const int x”只是想强调 x
是一个只读的变量，其本质仍为变量，无法用来初始化 array 容器；而 dis_2()
函数中的“const int x”，表明 x 是一个只读变量的同时，x 还是一个值为 5
的常量，所以可以用来初始化 array 容器。</p>
<h1 id="数据抽象和类">数据抽象和类</h1>
<p>Data
abstraction：只关心该数据“是什么”以及“如何使用”，而不关心它是如何运作的。</p>
<p>Control
abstraction：只关心这个行为能为我们带来什么，而不关心这个行为的具体实现方法。</p>
<h2 id="抽象数据类型">抽象数据类型</h2>
<p>在程序设计中，通过数据抽象而获得的抽象数据，称为抽象数据类型（Abstract
Data Type, ADT）。</p>
<p>一种 ADT 应具有：</p>
<ol type="1">
<li><p>说明部分：要说明该 ADT 是什么及如何使用，从而描述：</p>
<ul>
<li>数据值的特性 和</li>
<li>作用于这些数据之上的操作</li>
</ul>
<p>ADT 的用户仅须明白这些说明，而无须知晓其内部实现。</p></li>
<li><p>实现部分。</p></li>
</ol>
<p>把 DATE 设计为一种数据类型。</p>
<ul>
<li>内部包含年月日等数据以及在这些数据上可进行的操作。</li>
</ul>
<p>好处：</p>
<ul>
<li>用户利用 DATE 就可以定义多个变量。</li>
<li>用户可调用每个变量中公开的操作，但无法直接访问每个变量中隐藏的内部数据。</li>
<li>用户也无需关心变量中各操作的具体实现。</li>
</ul>
<p>效果：于是 DATE
就是一种封装好的数据类型。这就达到信息隐藏和封装的目的。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Type</span><br><span class="line">    DATE</span><br><span class="line">Data</span><br><span class="line">    Each DATE value is date</span><br><span class="line">    <span class="type">int</span> day/month/year  <span class="comment">// ---&gt; int year, month, day;</span></span><br><span class="line">Operation</span><br><span class="line">    Set the date                    <span class="comment">//set()</span></span><br><span class="line">    Get the date                    <span class="comment">//get()</span></span><br><span class="line">    Increment the date by one day   <span class="comment">//increment()</span></span><br><span class="line">    Decrement the date by one day   <span class="comment">//decrement()</span></span><br></pre></td></tr></table></figure></div>
<h2 id="显示默认的函数定义-default">显示默认的函数定义：
<code>=default</code></h2>
<p>令编译器为 某个类 生成 默认的特殊成员函数 或 比较运算符
的显式指令。(C++)</p>
<ul>
<li><p>例：当我们声明有参构造函数时，编译器就不会 创建
默认构造函数。为了使编译器创建该默认构造函数，可以</p>
<ul>
<li>在函数声明后指定 <code>= default</code></li>
<li>若以 <code>= default</code> 声明，则该函数不能写实现</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x){</span><br><span class="line">        cout &lt;&lt; <span class="string">"有参构造"</span>; </span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    A a;     <span class="comment">//call A()</span></span><br><span class="line">    <span class="function">A <span class="title">x</span><span class="params">(<span class="number">1</span>)</span></span>;  <span class="comment">//call A(int x)</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
<li><p><strong>default函数只能用于特殊的成员函数</strong>，特殊成员函数
包括：</p>
<ul>
<li>默认构造函数</li>
<li>析构函数</li>
<li>复制构造函数</li>
<li>等</li>
</ul></li>
</ul>
<h2 id="弃置函数delete">弃置函数：<code>=delete</code></h2>
<p>如果取代函数体而使用特殊语法<code>= delete</code>，则该函数被定义为
弃置的(deleted)。</p>
<p><strong>任何弃置函数的使用都是非法的</strong>（程序无法编译）。这包括</p>
<ul>
<li>调用，包含显示（以函数调用运算符）及隐式（对弃置的重载运算符、特殊成员函数、分配函数等的调用）</li>
<li>定义指向弃置函数的指针或成员指针</li>
<li>甚或是在不求值表达式中使用弃置函数</li>
</ul>
<p>请注意，删除的函数是 <strong>隐式内联</strong>
的，这一点非常重要。删除的函数定义 <strong>必须</strong> 是函数的
<strong>首次声明</strong>。</p>
<p>✔正确用法✔</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(C&amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<p>❌错误用法❌</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// incorrect syntax of declaring a member function as deleted </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> { </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">C</span>(); </span><br><span class="line">}; </span><br><span class="line"><span class="comment">// Error, the deleted definition of function C must be the first declaration of the function. </span></span><br><span class="line">C::<span class="built_in">C</span>() = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure></div>
<h2 id="类">类</h2>
<p>C++在C语言的基础上增加了面向对象编程，C++支持面向对象程序设计。<strong>类是C++的核心特性</strong>，通常被称为用户定义的类型。类用于指定对象的形式，它包含数据的表示方法和用于处理数据的方法。</p>
<ul>
<li>类中数据和方法 称为 类的成员</li>
<li>函数 在一个类中被称为 类的成员</li>
</ul>
<p>定义一个类，其效果是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230309143844748.png" class title="image-20230309143844748">
<p>类的例子</p>
<p>类定义是以关键字 <strong>class</strong>
开头，后跟类的名称。类的主体是包含在一对花括号中类定义后必须跟着一个分号或一个声明列表。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DATE</span>{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getMonth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getDay</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getYear</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Decrement</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> month;</span><br><span class="line">        <span class="type">int</span> day;</span><br><span class="line">        <span class="type">int</span> year;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<p>在{}中列出类的成员。类的成员包括：</p>
<ul>
<li>数据成员：
<ul>
<li>一般来说，数据成员是需要隐藏的；即外部的程序是不能直接访问这些数据的，应该通过函数成员访问这些数据。</li>
<li>所以一般情况下，数据成员通过关键字 private 声明为私有成员 (private
member)</li>
</ul></li>
<li>函数成员：
<ul>
<li>通过关键字 public 声明访问 公有成员（public member）</li>
<li>外部程序可以访问公有成员，但是无法访问私有成员</li>
</ul></li>
<li>对于 类的使用者（即用户代码，简称用户）而言
<ul>
<li>只需要获得 <code>.hpp</code>
，即可调用类对象的公有函数访问其内部的数据成员</li>
<li>使用者无法直接访问私有成员，也无需知晓公有函数的内部实现</li>
</ul></li>
</ul>
<h3 id="结构体与类">结构体与类</h3>
<p><strong>区别:</strong></p>
<ul>
<li>C 语言中的 struct 只能包含变量</li>
<li>C++中的 class 除了包含变量，还可以包含函数</li>
</ul>
<p><strong>效果：</strong> 例如 set() 函数处理成员变量的函数</p>
<ul>
<li>在C语言中，我们将它放在了 struct Date
外面，它和成员变量时分离的</li>
<li>在C++中，我们将它放在了class Date
内部，它和成员变量聚集在一起，看起来像一个整体</li>
</ul>
<p><strong>相似之处：</strong></p>
<ul>
<li>结构体和类都可以看作一种由用户自己定义的复杂数据类型</li>
<li>在C语言中可以通过结构体名来定义变量</li>
<li>在C++中可以通过类名来定义变量</li>
</ul>
<p><strong>不同之处：</strong></p>
<ul>
<li>通过结构体定义出来的变量传统上叫变量</li>
<li>通过类定义出来的变量有了新的名称，叫做 对象(Object)</li>
</ul>
<h3 id="成员函数">成员函数</h3>
<p><strong>声明：</strong></p>
<ul>
<li>类的成员函数是指哪些把定义/原型写在类定义内部的函数，就像类定义的其他变量一样</li>
<li>类成员函数是类的一个成员，它
<ul>
<li>可以操作类的任意对象</li>
<li>可以访问对象中的所有成员</li>
</ul></li>
</ul>
<p><strong>定义：</strong></p>
<p>成员函数可以</p>
<ul>
<li>在类体内部定义</li>
<li>单独使用 <strong>范围解析运算符</strong> <code>::</code>
来定义。</li>
</ul>
<p>在类体中定义的 成员函数 把函数声明为 <strong>内联</strong>
的，即便没有使用 <strong>inline</strong> 标识符</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DATE</span> { </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> newYear, <span class="type">int</span> newMonth, <span class="type">int</span> newDay )</span> </span>{ </span><br><span class="line">    month = newMonth; </span><br><span class="line">    day = newDay; </span><br><span class="line">    year = newYear; </span><br><span class="line">} </span><br><span class="line">…… </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">…… </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************   外部定义   *****************/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DATE</span> { </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> newYear, <span class="type">int</span> newMonth, <span class="type">int</span> newDay )</span></span>; </span><br><span class="line">    …… </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    …… </span><br><span class="line">}; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DATE::Set</span><span class="params">(<span class="type">int</span> newYear, <span class="type">int</span> newMonth, <span class="type">int</span> newDay )</span> </span>{ </span><br><span class="line">    month = newMonth; </span><br><span class="line">    day = newDay; </span><br><span class="line">    year = newYear; </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>成员函数 作用域</p>
<ul>
<li><p>在DATE.cpp文件开头需要加入预处理命令<code>#include "DATE.hpp"</code></p>
<p>这是因为在DATE.cpp中要用到用户自定义的标识符DATE，而它的定义在DATE.hpp中。</p></li>
<li><p>在DATE.hpp中，各函数原型是在{}中的。根据标识符的作用域规则，它们的作用范围仅在类定义中，而不包括DATE.cpp。因此在DATE.cpp中需要利用作用域解释运算符“::”来指明这里的函数是类DATE里的成员函数。</p></li>
<li><p>DATE.cpp中有时还包括DATE内部要使用到的函数，例如DaysInMonth(…)。这种函数并非对外公开供用户使用，因此可以将其声明为类的私有成员。</p></li>
<li><p>若在该函数中没有涉及该类的非静态成员，则无需将它们声明为类的成员。</p></li>
</ul>
<p><strong>访问成员</strong></p>
<p>调用 成员函数 和 成员变量
是在对象上使用点运算符(.)，这样它就能操作与该对象相关的数据</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date.flag = <span class="number">1</span>;</span><br><span class="line">date.<span class="built_in">set</span>(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure></div>
<h3 id="静态成员">静态成员</h3>
<p>静态(static)成员是类的组成部分但不是任何对象的组成部分</p>
<p>定义方式：通过在成员声明前加上保留字static 将成员设为static</p>
<ul>
<li>在数据成员的类型前加保留字 static 声明 静态数据成员</li>
<li>在成员函数的返回类型前加保留字 static 声明静态成员函数</li>
</ul>
<p>static 成员遵循正常的公有/私有访问规则</p>
<p>C++程序中，如果访问控制允许的话，可在类作用域外直接访问静态成员</p>
<p>静态数据成员</p>
<ul>
<li><strong>静态(static)数据成员</strong> 具有
<strong>静态生产期</strong>，是类的所有对象共享的存储空间，是整个类的所有对象的属性，而不是某个对象的属性。</li>
<li>与非静态数据成员不同，静态数据成员不是通过构造函数进行初始化，而是必须<strong>在类定义体的外部再定义一次</strong>，且有且只有一次
<ul>
<li>通常是在 类的实现文件中再 定义一次，而且<strong>此时不能再用 staic
修饰</strong></li>
</ul></li>
</ul>
<p>静态成员函数</p>
<ul>
<li>静态成员函数不属于任何对象</li>
<li><strong>静态成员函数没有 this 指针</strong></li>
<li><strong>静态成员函数 不能直接访问类的非静态成员，只能直接访问
类的静态成员</strong></li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DATE</span> <span class="comment">// DATE2.hpp</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DATE</span>( <span class="type">int</span> =<span class="number">2000</span>, <span class="type">int</span> =<span class="number">1</span>, <span class="type">int</span> = <span class="number">1</span>); </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">getCount</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">( <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMonth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDay</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getYear</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Decrement</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//DATE2.cpp StaticMember</span></span><br><span class="line"><span class="type">int</span> DATE::count = <span class="number">0</span>; <span class="comment">//必须在类定义体的外部再定义一次</span></span><br><span class="line">DATE::<span class="built_in">DATE</span>( <span class="type">int</span> initYear, <span class="type">int</span> initMonth, <span class="type">int</span> initDay )</span><br><span class="line">{</span><br><span class="line">    year = initYear; </span><br><span class="line">    month = initMonth;</span><br><span class="line">    day = initDay;</span><br><span class="line">    count++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DATE::getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"There are "</span> &lt;&lt; count &lt;&lt; <span class="string">" objects now"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    DATE DATE1; </span><br><span class="line">    <span class="function">DATE <span class="title">DATE2</span><span class="params">( <span class="number">1976</span>, <span class="number">12</span>, <span class="number">20</span> )</span></span>; </span><br><span class="line">    DATE::<span class="built_in">getCount</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h2 id="基本知识">基本知识</h2>
<h3 id="c新类型-bool">C++新类型 bool</h3>
<p>C语言：没有bool类型，c 程序员常用预定义定义TRUE、FALSE。C99 定义了
bool 类型，并通过 stdbool.h 实现与 C++兼容</p>
<p>C++语言：</p>
<ul>
<li>定义了三个关键字：bool, true, false</li>
<li>当显式 (<code>(bool)7</code>) 或隐式 (<code>bool b = 7</code>) 转为
bool 类型时
<ul>
<li>0 值转为 false</li>
<li>非 0 值转为 true</li>
</ul></li>
<li>使用 cout 输出</li>
</ul>
<h3 id="void-形参">void 形参</h3>
<p>C语言：</p>
<ul>
<li>func(); 没有声明形参表示函数的形参不确定</li>
<li>没有参数，则<strong>必须显式</strong>声明
<code>func(void);</code></li>
</ul>
<p>C++语言：</p>
<ul>
<li><code>func();</code> 等价于 <code>func(void);</code></li>
<li>使用 “...” 标点符号表示 <strong>可变参数</strong></li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明如下</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">printx</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* fmt, ...)</span></span>;</span><br><span class="line"><span class="comment">//能以一个或多个实参调用</span></span><br><span class="line"><span class="built_in">printx</span>(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">printx</span>(<span class="string">"a = %d b = %d"</span>, a, b);</span><br></pre></td></tr></table></figure></div>
<h3 id="函数重载">函数重载</h3>
<p>在开发中，需要的多个函数功能相似，但参数的数目或类型不同。例如交换整数和浮点数两个函数。</p>
<p>C语言：必须声明两个不同名的函数，否则会标识符重定义。</p>
<p>C++语言：声明同样名称的一组函数，但必须保证形参类型/数量不同：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">double</span>&amp; x, <span class="type">double</span>&amp; y)</span></span>;</span><br></pre></td></tr></table></figure></div>
<p><strong>函数重载与auto</strong></p>
<p>函数重载的优点：程序易于理解</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>&amp; x,<span class="type">int</span>&amp; y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">double</span>&amp; x,<span class="type">double</span>&amp; y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>&amp; x,<span class="type">int</span>&amp; y)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> temp = x; x = y; y = temp;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">double</span>&amp; x,<span class="type">double</span>&amp; y)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> temp = x; x = y; y = temp;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>,j = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(i,j);</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">","</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">2.2</span>, y = <span class="number">3.3</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(x,y);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>两个实现唯一差别是 temp 类型不同</p>
<ul>
<li>使用 auto 类型，则实现代码完全一样</li>
<li>让编译器去推导决定哪个函数</li>
</ul>
<p><strong>函数签名</strong></p>
<p>编译器根据 函数名、参数数目、参数类型 生成唯一的内部函数名</p>
<p>例如：Swap 函数。Swap_int_int 和 Swap_float_float
是不同的函数签名，所以不是一个函数。</p>
<h3 id="c新特性-默认实参">C++新特性-默认实参</h3>
<p>C语言不支持函数默认参数和值</p>
<p>C++语言：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//带默认参数的函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n = <span class="number">1</span>, <span class="type">float</span> b = <span class="number">1.2</span>, <span class="type">char</span> c = <span class="string">'@'</span>)</span></span>;</span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n, <span class="type">float</span> b, <span class="type">char</span> c)</span></span>{</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">", "</span>&lt;&lt; b &lt;&lt; <span class="string">", "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">func</span>();              <span class="comment">//func(1,1.2,'@')</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);            <span class="comment">//func(10,1.2,'@')</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">9.8</span>);       <span class="comment">//func(20,9.8,'@')</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">30</span>, <span class="number">3.5</span>, <span class="string">'#'</span>);  <span class="comment">//func(30,3.5,'#')</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p><strong>默认参数</strong>只能定义在<strong>参数列表的右边</strong></p>
<h3 id="字符串类型-string">字符串类型-string</h3>
<p>C语言字符串：</p>
<ul>
<li><p>C字符串是 char* 类型，是以 '\0' 字符结束的字符数组</p>
<p><code>const char* s = "c plus plus";</code></p></li>
<li><p>在 C++ 中处理 C字符串，请使用
<code>#include&lt;cstring&gt;</code></p></li>
</ul>
<p>C++语言字符串：</p>
<ul>
<li>string 是类</li>
<li>作为区别，使用 cstring 称c字符串</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    string s1;   <span class="comment">//默认构造</span></span><br><span class="line">    string s2 = <span class="string">"c plus plus"</span>;  <span class="comment">//用 cstring 构造</span></span><br><span class="line">    string s3 = s2;   <span class="comment">//用同类对象构造</span></span><br><span class="line">    <span class="function">string <span class="title">s4</span><span class="params">(<span class="number">5</span>, <span class="string">'s'</span>)</span></span>;<span class="comment">//用 int, char 作为参数构造</span></span><br><span class="line">    cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h2 id="访问控制">访问控制</h2>
<h3 id="公有public成员">公有(public)成员</h3>
<p><strong>公有成员</strong> 在客户端可以任意访问。</p>
<p><strong>公有数据成员</strong> 不需要通过公有函数成员访问</p>
<ul>
<li>优点：使用方便</li>
<li>缺点：<strong>可能会破坏封装的逻辑一致性，</strong>如客户端修改线段长度为负数</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* public.hpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> sysu_cplus{</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Line</span>{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">double</span> length;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setLength</span><span class="params">(<span class="type">double</span> len)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">getLength</span><span class="params">( <span class="type">void</span> )</span></span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 成员函数定义</span></span><br><span class="line"><span class="type">double</span> sysu_cplus::Line::<span class="built_in">getLength</span>(<span class="type">void</span>) { </span><br><span class="line"><span class="keyword">return</span> length ; </span><br><span class="line">} </span><br><span class="line"><span class="type">void</span> sysu_cplus::Line::<span class="built_in">setLength</span>( <span class="type">double</span> len ) { </span><br><span class="line">    length = len; </span><br><span class="line">} </span><br><span class="line"><span class="comment">/* 主程序 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"public.hpp"</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sysu_cplus; </span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span> </span>{ </span><br><span class="line">    Line line; </span><br><span class="line">    <span class="comment">// 设置长度</span></span><br><span class="line">    line.<span class="built_in">setLength</span>(<span class="number">6.0</span>); </span><br><span class="line">    cout &lt;&lt; <span class="string">"Length of line : "</span> &lt;&lt; line.<span class="built_in">getLength</span>() &lt;&lt;endl; </span><br><span class="line">    <span class="comment">// 不使用成员函数设置长度</span></span><br><span class="line">    line.length = <span class="number">10.0</span>; </span><br><span class="line">    <span class="comment">// OK: 因为 length 是公有的</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Length of line : "</span> &lt;&lt; line.length &lt;&lt;endl; </span><br><span class="line">    <span class="comment">// Error: 破坏包装的后果 – 语义错误</span></span><br><span class="line">    line.length = <span class="number">-10.0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Length of line : "</span> &lt;&lt; line.<span class="built_in">getLength</span>() &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h3 id="私有private成员">私有(private)成员</h3>
<p>私有成员变量或函数 <strong>在类的外部</strong> 是
<strong>不可访问的</strong>，甚至是不可查看的。只有类和友元函数可以访问私有成员。</p>
<p><strong>默认情况下，class的所有成员都是私有的。</strong></p>
<p>如果没有使用任何访问修饰符，类的成员将被假定为私有成员。</p>
<p>在实际操作中，我们一般会：</p>
<ul>
<li><p>在私有区域定义数据</p></li>
<li><p>在公有区域定义相关的函数，</p>
<p>以便在类的外部仅可以调用成员函数修改对象状态，保持对象内部状态一致。</p></li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* private.hpp */</span></span><br><span class="line"><span class="keyword">namespace</span> sysu_cplus {</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> { </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="type">double</span> length; </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">( <span class="type">double</span> wid )</span></span>; </span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">getWidth</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span>; </span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="type">double</span> width; </span><br><span class="line">    }; </span><br><span class="line">}</span><br><span class="line"><span class="comment">// 在函数定义中，我们如何区别 namespace名 和 类名？</span></span><br><span class="line"><span class="type">double</span> sysu_cplus::Box::<span class="built_in">getWidth</span>(<span class="type">void</span>) <span class="type">const</span>{ </span><br><span class="line">    <span class="keyword">return</span> width ; </span><br><span class="line">} </span><br><span class="line"><span class="type">void</span> sysu_cplus::Box::<span class="built_in">setWidth</span>(<span class="type">double</span> w) { </span><br><span class="line">    width = w; </span><br><span class="line">}</span><br><span class="line"><span class="comment">/************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span> </span>{ </span><br><span class="line">    Box box; </span><br><span class="line">    <span class="comment">// 不使用成员函数设置长度</span></span><br><span class="line">    box.length = <span class="number">10.0</span>; </span><br><span class="line">    <span class="comment">// OK: 因为 length 是公有的</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Length of box : "</span> &lt;&lt; box.length &lt;&lt;endl; </span><br><span class="line">    <span class="comment">// 不使用成员函数设置宽度</span></span><br><span class="line">    <span class="comment">// box.width = 10.0; </span></span><br><span class="line">    <span class="comment">// Error: 因为 width 是私有的</span></span><br><span class="line">    <span class="comment">// 使用成员函数设置宽度</span></span><br><span class="line">    box.<span class="built_in">setWidth</span>(<span class="number">10.0</span>); </span><br><span class="line">    cout &lt;&lt; <span class="string">"Width of box : "</span> &lt;&lt; box.<span class="built_in">getWidth</span>() &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h2 id="构造函数">构造函数</h2>
<h3 id="无参构造函数">无参构造函数</h3>
<p>类的构造函数是类的一种特殊的成员函数，每次创建类的新对象时执行它完成初始化等逻辑。</p>
<p>构造函数的名称与类的名称是完全相同的，并且
<strong>不会返回任何类型</strong>，也 不会返回 void</p>
<p>如果用户没有自定义构造函数，则编译会自动生成一个
<strong>默认构造函数</strong>。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* constractor.hpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">namespace</span> sysu_cplus { </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Line</span> { </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setLength</span><span class="params">( <span class="type">double</span> len )</span></span>; </span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">getLength</span><span class="params">( <span class="type">void</span> )</span></span>; </span><br><span class="line">        <span class="built_in">Line</span>(); <span class="comment">// 这是构造函数</span></span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="type">double</span> length; </span><br><span class="line">    }; </span><br><span class="line">}</span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">sysu_cplus::Line::<span class="built_in">Line</span>(<span class="type">void</span>) { </span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Object is being created"</span> &lt;&lt; std::endl; </span><br><span class="line">} </span><br><span class="line"><span class="type">void</span> sysu_cplus::Line::<span class="built_in">setLength</span>( <span class="type">double</span> len ) { </span><br><span class="line">    length = len; </span><br><span class="line">}</span><br><span class="line"><span class="type">double</span> sysu_cplus::Line::<span class="built_in">getLength</span>( <span class="type">void</span> ) { </span><br><span class="line">    <span class="keyword">return</span> length; </span><br><span class="line">}</span><br><span class="line"><span class="comment">/****************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"constructor.hpp"</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sysu_cplus;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{ </span><br><span class="line">    Line line; </span><br><span class="line">    <span class="comment">// 设置长度</span></span><br><span class="line">    line.<span class="built_in">setLength</span>(<span class="number">6.0</span>); </span><br><span class="line">    cout &lt;&lt; <span class="string">"Length of line : "</span> &lt;&lt; line.<span class="built_in">getLength</span>() &lt;&lt;endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h3 id="有参构造函数">有参构造函数</h3>
<p>构造函数也可以带有参数。这样在创建对象时就可以使用参数构造函数。</p>
<p>注意：用户一旦定义了构造函数，编译器就 <strong>不再自动添加</strong>
默认构造函数。这时调用无参构造会出错。</p>
<p>构造函数也能使用默认实参 <code>CLASS(int a = 0);</code>
。这样可以减少构造函数重载的数量。</p>
<h3 id="拷贝构造函数">拷贝构造函数</h3>
<p>语法：<code>CLASS::CLASS(const CLASS&amp; obj);</code></p>
<ul>
<li><p>有一个形参，其类型为 类类型本身</p></li>
<li><p>该参数传递方式为按引用传递，避免在函数调用过程中生成形参副本</p></li>
<li><p>该形参声明为 const，确保在拷贝构造函数中不修改实参的值</p></li>
<li><p>形参类型为该类类型本身且参数传递方式为按引用传递。</p></li>
<li><p>用一个已存在的该类对象初始化新创建的对象。</p></li>
<li><p>每个类都必须有拷贝构造函数：</p>
<ul>
<li>用户可根据自己的需要显式定义拷贝构造函数。</li>
<li>若用户未提供，则该类使用由系统提供的缺省拷贝构造函数（可用=default），也可用
=delete 弃置该函数。</li>
<li>缺省拷贝构造函数按照初始化顺序，对对象的各基类和非静态成员进行完整的逐成员复制，完成新对象的初始化。</li>
<li>即逐一调用成员的拷贝构造函数，如果成员是基础类型，则复制值（赋值）。</li>
</ul></li>
</ul>
<p>隐式调用 复制构造函数</p>
<p><strong>FIRST</strong> 对象作为函数形参</p>
<p>隐式调用复制构造（1）：将一个对象作为实参，以按值调用方式传递给被调函数的形参对象。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(CLASS temp)</span></span>{...}</span><br><span class="line"><span class="built_in">fun</span>(obja);</span><br><span class="line"><span class="comment">//obja传递给fun函数，创建形参对象temp时，调用C的拷贝构造函数用对象obja初始化对象temp</span></span><br><span class="line"><span class="comment">//temp生存期结束被撤销时，调用析构函数</span></span><br></pre></td></tr></table></figure></div>
<p>用obja来初始化temp。</p>
<ul>
<li>如果有为C类明确定义拷贝构造函数，将调用这个拷贝构造函数</li>
<li>如果没有为C类定义拷贝构造函数，将调用缺省的拷贝构造函数</li>
</ul>
<p><strong>SECOND</strong> 对象作为值从函数返回</p>
<ul>
<li>当函数返回一个对象时，系统将自动创建一个临时对象来保存函数的返回值。创建此临时对象时调用拷贝构造函数</li>
<li>当函数调用表达式结束后，撤销该临时对象时，调用析构函数</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CLASS <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    CLASS t;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line">b = <span class="built_in">fun2</span>();</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>t =&gt; <strong>临时对象</strong> =&gt; b 拷贝构造函数 赋值运算符</p>
</blockquote>
<p>注：但现在的gcc/g++不这么处理，会做一个优化。在C函数里有个t变量，离开func时不撤销这个
t 对象，而是让(自动创建的临时对象)和这个 t
对象关联起来。也就是(自动创建的临时对象)就是这个 t 对象。</p>
<p>复制策略：拷贝构造函数自定义</p>
<ol type="1">
<li>对于不含指针成员的类，使用系统提供（编译器合成）的默认拷贝构造函数即可。</li>
<li>默认（缺省）拷贝构造函数使用
浅复制策略，是简单的值复制，如果类中有指针数据成员，会有重复释放指针所指内存的风险，不能满足
含指针数据成员的类的需要。</li>
<li>含指针成员的类通常应重写以下内容：
<ul>
<li>构造函数（以及拷贝构造函数）中分配内存（深复制策略）</li>
<li>= 操作重写，完成对象 深复制策略</li>
<li>析构函数中 释放内存</li>
</ul></li>
</ol>
<blockquote>
<p>浅拷贝
只复制成员指针的值，而不复制指向的对象实体，导致新旧对象成员指针指向同一块内存</p>
<p>深拷贝
要求成员指针指向的对象也要复制，新对象与原对象的成员指针不会指向同一块内存，修改新对象不会修改原对象</p>
</blockquote>
<h2 id="析构函数">析构函数</h2>
<p>类的析构函数是类的一种特殊的成员函数，它会在对象被释放前执行。</p>
<p>析构函数的名称与类的名称是完全相同的，只是在前面加一个波浪号(<code>~</code>)作为前缀，它</p>
<ul>
<li><strong>不会返回任何值</strong></li>
<li><strong>也不能带有任何参数</strong></li>
</ul>
<p>析构函数有助于在跳出程序前释放资源（比如关闭文件、释放内存等）。</p>
<p>注意：<strong>析构函数不能直接调用</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* constractor.hpp */</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">namespace</span> sysu_cplus { </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> { </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setLength</span><span class="params">( <span class="type">double</span> len )</span></span>; </span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">getLength</span><span class="params">( <span class="type">void</span> )</span></span>; </span><br><span class="line">        <span class="built_in">Line</span>(); <span class="comment">//构造函数</span></span><br><span class="line">        ~<span class="built_in">Line</span>(); <span class="comment">//析构函数</span></span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="type">double</span> length; </span><br><span class="line">    }; </span><br><span class="line">}</span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">sysu_cplus::Line::<span class="built_in">Line</span>(<span class="type">void</span>) { </span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Object is being created"</span> &lt;&lt; std::endl; </span><br><span class="line">} </span><br><span class="line">sysu_cplus::Line::~<span class="built_in">Line</span>(<span class="type">void</span>) { </span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Object is being deleted"</span> &lt;&lt; std::endl; </span><br><span class="line">}</span><br><span class="line">…</span><br></pre></td></tr></table></figure></div>
<p>注：</p>
<ol type="1">
<li>对于大多数创建的对象，对象生命期结束，对象被销毁前会调用析构函数</li>
<li><strong>new 出来的对象在创建时会调用构造函数，如果使用 delete
则会调用析构对象，否则不会自动调用析构函数。</strong></li>
<li>malloc 不会调用 构造函数，free 不会调用 析构函数</li>
</ol>
<h2 id="this-指针">this 指针</h2>
<p>在C++中，每个对象都能通过 <strong>this
指针</strong>来访问自己的地址</p>
<ul>
<li><strong>this 指针</strong>
是<strong>所有动态成员函数的隐含参数</strong>，<strong>友元函数没有 this
指针</strong>，因为友元函数不是类的成员。<strong>静态成员函数没 this
指针</strong>。</li>
<li>因此，在成员函数内部，它可以用来指向调用对象。</li>
</ul>
<p>this 指针</p>
<ul>
<li>-&gt; 是取成员运算符，和 c 语言一致。</li>
<li><strong>static 成员不能使用 this</strong>，应使用
<code>类名::成员</code></li>
<li>当成员函数的参数与成员数据重名时，必须使用 this 访问成员数据。</li>
</ul>
<p>如果设计的类没有构造函数，C++编译器会自动为该类型建立一个缺省构造函数。该构造函数没有任何形参，且函数体为空。</p>
<p>• 应该养成编写构造函数的习惯。</p>
<h2 id="对象成员初始化">对象成员初始化</h2>
<p>类的非静态数据成员可以用下列几种方式之一初始化：</p>
<ol type="1">
<li>通过默认成员函数初始化器，它是成员声明中包含的
花括号或等号初始化器。(C++11)</li>
<li>在构造函数的 <strong>成员初始化器列表</strong> 中。(C++11)</li>
<li>构造函数体内进行赋值操作。(注意：<strong>不能构造成员</strong>，除非你特别熟悉
new 的各种用法)</li>
</ol>
<p>对象初始化分两个阶段：首先按声明顺序初始化成员、然后执行构造函数函数体</p>
<p>为什么需要初始化容器列表和默认成员初始化器？</p>
<ul>
<li>对于复杂对象成员，必须先构造才能在构造函数的函数体中赋值
这会导致构造函数必须构造一个 string 中间变量</li>
<li>对于 引用类型的数据成员 和 const数据成员 需要初始化</li>
<li>对象初始化需要参数</li>
</ul>
<p>为了提升初始化性能，C++引入了 默认初始化器 和 初始化列表</p>
<h3 id="成员初始化器c11">成员初始化器(C++11)</h3>
<p>与其他函数不同，构造函数除了有名字，参数列表和函数体之外，还可以有初始化器列表，初始化器列表以冒号开头，后跟一系列以
逗号 分隔的成员初始化器。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DATE</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DATE</span>( <span class="type">int</span> initYear, <span class="type">int</span> initMonth, <span class="type">int</span> initDay ):<span class="built_in">year</span>(initYear), <span class="built_in">month</span>(initMonth), <span class="built_in">day</span>(initDay){}</span><br><span class="line">    <span class="built_in">DATE</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<p><strong>必须使用成员初始化器必须使用的情况：</strong></p>
<ol type="1">
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化器列表里面</li>
<li>引用成员，引用必须在定义的时候初始化，并且不能重新赋值，所以也要使用初始化器</li>
<li>如果某个成员的类类型没有无参数的构造函数，则要使用初始化器直接调用有参数的构造函数初始化</li>
</ol>
<p>数据成员初始化的顺序：是按照它们在 <strong>类中声明的顺序</strong>
进行初始化的，而不是按照它们在初始化器列表出现的顺序初始化的。</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span> {<span class="comment">//foo1.cpp</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i ;<span class="type">int</span> j ;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="type">int</span> x):<span class="built_in">i</span>(x), <span class="built_in">j</span>(i){} <span class="comment">// ok, 先初始化i，后初始化j</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">/*------------------------------------------------*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span> <span class="comment">//foo2.cpp</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i ;<span class="type">int</span> j ;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="type">int</span> x):<span class="built_in">j</span>(x), <span class="built_in">i</span>(j){} <span class="comment">// false, i值未定义</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<p>这里i的值是未定义的因为虽然j在初始化器列表里面出现在i前面，但是i先于j定义，所以先初始化i，而i由j初始化，此时j尚未初始化，所以导致i的值未定义。</p>
<p>最好是 按照成员声明的顺序进行初始化。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>{</span><br><span class="line">    <span class="type">int</span> n;                    <span class="comment">//非静态数据成员</span></span><br><span class="line">    <span class="type">int</span>&amp; r = n;               <span class="comment">//引用类型的非静态数据成员;</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>] = {<span class="number">1</span>, <span class="number">2</span>};        <span class="comment">//带默认初始化器的非静态数据成员</span></span><br><span class="line">    std::string s{<span class="string">'H'</span>, <span class="string">'C'</span>};</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">NestedS</span> {</span><br><span class="line">        std::string s;</span><br><span class="line">        <span class="built_in">NestedS</span>(std::string s = <span class="string">"hello"</span>):<span class="built_in">s</span>(s){} <span class="comment">//构造函数</span></span><br><span class="line">    }d5;   <span class="comment">//具有嵌套类型的非静态数据成员</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> bit: <span class="number">2</span>;  <span class="comment">//2位位域，const 初始化</span></span><br><span class="line">    <span class="built_in">S</span>(): <span class="built_in">n</span>(<span class="number">7</span>), <span class="built_in">bit</span>(<span class="number">3</span>){}  <span class="comment">// ":n(7),bit(3)" 是初始化器列表; "{}" 是函数体</span></span><br><span class="line">    <span class="built_in">S</span>(<span class="type">int</span> x):<span class="built_in">n</span>(x), <span class="built_in">bit</span>(<span class="number">3</span>){}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h2 id="对象的内存布局">对象的内存布局</h2>
<p>对象不存储指向成员函数的指针，类的成员函数存储在代码段，是所有类对象的共用空间</p>
<p>构造对象时为数据成员提供存储空间。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230330150856153.png" class title="image-20230330150856153">
<p>对象方法的 <strong>静态联编</strong></p>
<p>指在编译阶段，就能直接使用代码f段函数地址调用动态对象的方法。该方法仅需要<strong>向非静态成员函数传送
this 指针</strong>，即可用静态函数调用实现动态调用的效果。</p>
<p>优势：</p>
<ol type="1">
<li>对象布局与C结构内存布局一致，使得内存中对象便于与其他语言程序库兼容</li>
<li>高效率， 高性能</li>
</ol>
<h2 id="运算符重载">运算符重载</h2>
<p>定义：<strong>运算符重载</strong> 是指 重载具有特殊函数名（即以
运算符为函数名）的函数，也具有返回值类型，函数名和参数列表。函数名是由
关键字<strong>operator</strong> 和其后要
<strong>重载的运算符符号</strong> 构成的。</p>
<p>运算符重载的两个方法：</p>
<ul>
<li>类成员函数 运算符重载
<ul>
<li><code>return_type class_name::operator op(operand2){ }</code></li>
<li>重载二元运算符时，成员运算符函数只需显式传递一个参数（即二元运算符的由操作数），而左操作数则式该类对象本身，通过
this 指针隐式传递。</li>
<li>重载一元运算符时，成员运算符函数没有参数，操作数时该类对象本身，通过
this 指针隐式调用。</li>
</ul></li>
<li>友元函数 运算符重载
<ul>
<li><code>return_type operator op(operand1, operand2)</code></li>
</ul></li>
</ul>
<h3 id="可以重载的运算符">可以重载的运算符</h3>
<p><img lazyload src="/images/loading.svg" data-src="C++基础知识/能重载的运算符.png" alt="能重载的运算符" style="zoom:50%;"></p>
<p>大多数 运算符都可以通过成员函数 或 非成员函数进行重载。</p>
<p>但下面的运算符只能通过成员函数重载。</p>
<ul>
<li><code>=</code>：赋值运算符</li>
<li><code>()</code>：函数调用运算符</li>
<li><code>[]</code>：下标运算符</li>
<li><code>-&gt;</code>：通过指针访问类成员的运算符</li>
</ul>
<h3 id="不可以重载的运算符">不可以重载的运算符</h3>
<ul>
<li><code>::</code> （作用域解析）</li>
<li><code>.</code>（成员访问）</li>
<li><code>.*</code>（通过成员指针的成员访问）</li>
<li><code>?:</code> （三元条件）</li>
<li><code>sizeof运算符</code> ，还有除 new, delete
外的关键字运算符，如<code>alignof</code>，<code>typedef</code> 等等</li>
<li><code>#</code> （预处理符号）</li>
</ul>
<p><strong>其他限制</strong></p>
<ul>
<li>不能创建新运算符</li>
<li>运算符 <code>&amp;&amp;</code> 与 <code>||</code>
的重载失去短路求值</li>
<li>重载的运算符 <code>-&gt;</code> 必须要么返回
裸指针，要么（按引用或值）返回 同样重载了的运算符 <code>-&gt;</code>
的对象</li>
<li>不可能更改运算符的优先级、结合方向或操作数的数量</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>运算符作为非成员函数重载的一个常见原因是，左操作数不是该类的对象，而是其他类型的数据，例如
int、double
等。在这种情况下，运算符必须作为非成员函数重载，以便能够接受该类型的数据作为左操作数。另一个原因是，如果运算符需要返回一个引用，那么它必须作为非成员函数重载，因为成员函数不能返回引用类型的值。</li>
<li>作为非静态成员函数重载的运算符，其第一个参数是隐式的，表示该运算符作用于哪个对象。
对于二元运算符，可以有两个参数，其中第一个参数是隐式的，第二个参数是显式的，表示运算符的右操作数。对于一元运算符，只有一个参数，即隐式的对象指针。</li>
<li>运算符重载的使用方式与运算符函数是作为成员函数实现的还是作为非成员函数实现的无关。</li>
<li><code>y+=z</code> 等价于 <code>y.operator+=(z)</code></li>
</ul>
<h3 id="注意事项">注意事项</h3>
<h4 id="自增运算符">自增运算符</h4>
<p>重载自增运算符分为两种情况：</p>
<ul>
<li><p>重载 前缀自增运算符，直接重载</p>
<p><code>return_type class_name::operator++() {}</code></p></li>
<li><p>重载 后缀自增运算符，该函数有一个 int
类型的虚拟形参，它告诉编译器递增运算符以 后缀模式 重载：
<code>return_type class_name::operator ++(int) {}</code></p></li>
</ul>
<p>返回 值 还是 引用？</p>
<ul>
<li>内建运算符的 前置版本 返回 引用，而 后置版本 返回 值。</li>
<li>用户自定义的重载中，能以任何形式为返回类型。</li>
</ul>

<ul>
<li>重载前置 ++x 的方法
<ul>
<li>保持语义：x 的值加1。作为表达式，返回加1之后的值</li>
<li>返回 对象引用 的好处：
<ul>
<li>返回当前对象 能够实现 “返回加 1 之后的值” 这个语义</li>
<li>返回引用 能够减少构造新对象的成本</li>
<li>运算结果 可以作为 左值</li>
</ul></li>
</ul></li>
<li>重载后置 x++ 的方法
<ul>
<li>形式： 由一个形参</li>
<li>保持语义：x 的值加 1。作为表达式，返回加 1 之前的值</li>
<li>不能返回 对象引用的原因
<ul>
<li>由于当前对象保持了加 1 之后的值，因此不能作为返回值</li>
<li>只能返回新建的对象（加 1 之前的值）</li>
</ul></li>
<li>不能重载为 const 方法，因为要加 1。</li>
</ul></li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span>{</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Integer</span>(<span class="type">int</span> x = <span class="number">0</span>): <span class="built_in">x</span>(x){}</span><br><span class="line">    Integer* <span class="keyword">operator</span>++()</span><br><span class="line">    {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"prefix is invoked"</span> &lt;&lt; endl;</span><br><span class="line">        ++x;</span><br><span class="line">        <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Integer <span class="keyword">operator</span> ++(<span class="type">int</span>)</span><br><span class="line">    {</span><br><span class="line">        cerr &lt;&lt; <span class="string">"suffix is invoked"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Integer</span>(x++);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<h3 id="赋值运算符">赋值运算符</h3>
<p>重载 赋值运算符= 的方法</p>
<ul>
<li>保持语义：将运算符=右侧表达式的值赋给左侧变量</li>
<li>参数：
<ul>
<li>表示运算符=右侧表达式的值</li>
<li>使用引用是为了效率</li>
<li>使用 const 是为了安全（符合赋值的常规语义）</li>
</ul></li>
<li>返回值：使用引用返回是为了效率</li>
</ul>

<p>在用户自定义类中，如果有指针类型的数据成员，则最好 自定义拷贝构造函数
和 <strong>重载赋值运算符</strong>，实现深拷贝，避免使用
默认的拷贝构造函数 和
默认的缺省的赋值运算符（均为浅拷贝，可能导致重复释放已经释放过的指针指向的空间）。</p>
<h3 id="移位运算符">移位运算符</h3>
<ul>
<li>第一操作数 不是 *this，只能类外定义</li>
<li>普通函数重载 <code>&lt;&lt;</code>，<code>&gt;&gt;</code>
<ul>
<li>保持语义
<ul>
<li><code>&lt;&lt;</code> 是输出，支持级联输出，如
<code>cout &lt;&lt; "x="&lt;&lt; x &lt;&lt; endl;</code></li>
<li><code>&gt;&gt;</code> 是输入，支持级联输入，如
<code>cin &gt;&gt; x &gt;&gt; y;</code></li>
</ul></li>
<li>参数
<ul>
<li>第 1（左）操作数：流对象</li>
<li>第 2 （右）操作数：自定义类的对象</li>
<li>使用引用是为了效率</li>
</ul></li>
<li>返回值：返回流对象（即第一个操作数）的引用，以支持级联 IO</li>
</ul></li>
</ul>
<p><strong>示例</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Integer</span>{</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">istream&amp; <span class="title">operator</span><span class="params">(istream&amp; is, Integer* Int)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    is &gt;&gt; Int.x;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Integer* Int)</span><br><span class="line">{</span><br><span class="line">    os &lt;&lt; Int.x;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Integer x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h3 id="函数对象">函数对象</h3>
<p>如果一个类定义了 <code>operator()</code>
运算符函数，那么使用该类的对象可以调用这个运算符函数，其调用形式如同
普通函数调用 一般，因此取名叫 <strong>函数对象</strong>。</p>
<p>例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cmp</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a&lt;b;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cmp f;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">2</span>, <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>输出：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure></div>
<p>因为 函数对象
实际上也是一个对象，所以也可以拥有自己的成员变量，从而也可以表示
谓词判断：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterThan</span>{</span><br><span class="line">    <span class="type">int</span> baseline;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GreaterTan</span>(<span class="type">int</span> x): <span class="built_in">baseline</span>(x){}</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> x &gt; baseline;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">GreaterThan <span class="title">G1</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">G2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">G1</span>(<span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">G2</span>(<span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>输出结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure></div>
<p>所以，函数对象相比普通的函数有一个非常重要的用途，即作为
<strong>谓词函数</strong>（Predicate）。谓词函数通常用来对传进来的参数进行判断，并返回
<strong>布尔值</strong>。标准库中有大量定义了多个重载版本的函数，其中有的函数要求用户提供
谓词函数，比如：find_if，remove_if，等等。</p>
<p>例：</p>
<ul>
<li><p>第一种：函数对象</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterThan</span>{</span><br><span class="line">    <span class="type">int</span> baseline;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GreaterThan</span>(<span class="type">int</span> x): <span class="built_in">baseline</span>(x){}</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> x&gt;baseline;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = {<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>};</span><br><span class="line">    <span class="comment">//find_if return a iterator</span></span><br><span class="line">    cout &lt;&lt; *<span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">GreaterThan</span>(<span class="number">10</span>)) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">GreaterThan</span>(<span class="number">20</span>)) &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
<li><p>第二种：普通 bool 函数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GreaterThan10</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x&gt;<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GreaterThan20</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x&gt;<span class="number">20</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = {<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>};</span><br><span class="line">    <span class="comment">//find_if return a iterator</span></span><br><span class="line">    cout &lt;&lt; *<span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), GreaterThan10) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), GreaterThan20) &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="友元函数">友元函数</h2>
<p>类的成员函数也是函数的一种，所以其他类的成员函数也可以是友元函数！</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cmp</span>{</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Integer&amp; a, <span class="type">const</span> Integer&amp; b)</span></span></span><br><span class="line"><span class="function">}</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span>{</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Integer</span>(<span class="type">int</span> x = <span class="number">0</span>): <span class="built_in">x</span>(x){}</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">bool</span> <span class="title">Cmp::operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Integer&amp; a, <span class="type">const</span> Integer&amp; b)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cmp::operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Integer&amp; a, <span class="type">const</span> Integer&amp; b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>但有些时候，其他类的成员函数可能会很多，一个一个的声明为友元函数会比较麻烦。
所以我们就可以直接声明友元类：</p>
<ul>
<li>一个类 A 可以将另一个类 B 声明为自己的友元，那么类 B
的所有成员函数就都可以访问类 A 对象的私有成员</li>
<li>形式：<code>friend class B;</code> （在类 A 的内部）</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cmp</span>{</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Integer&amp; a, <span class="type">const</span> Integer&amp; b)</span></span></span><br><span class="line"><span class="function">}</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span>{</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Integer</span>(<span class="type">int</span> x = <span class="number">0</span>): <span class="built_in">x</span>(x){}</span><br><span class="line">    <span class="keyword">friend</span> Cmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cmp::operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Integer&amp; a, <span class="type">const</span> Integer&amp; b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h2 id="explicit-说明符">explicit 说明符</h2>
<ol type="1">
<li>指定构造函数或转换函数 (C++11 起)或推导指引 (C++17
起)为显式，即它不能用于隐式转换和复制初始化。</li>
<li>explicit
说明符可以与常量表达式一同使用。函数在且只会在该常量表达式求值为 true
时是显式的。(C++20 起) explicit 说明符只能在 类定义之内的构造函数 或
转换函数 (C++11 起)的 声明说明符序列 中出现。</li>
</ol>
<p>声明时不带函数说明符 explicit 的拥有单个无默认值形参的 (C++11
前)构造函数被称作转换构造函数。</p>
<p>构造函数（除了复制或移动）和用户定义转换函数都可以是函数模板；explicit
的含义不变。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>) { }      <span class="comment">// 转换构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>, <span class="type">int</span>) { } <span class="comment">// 转换构造函数（C++11）</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="literal">true</span>; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span>)</span> </span>{ }</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> </span>{ }</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="literal">true</span>; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    A a1 = <span class="number">1</span>;      <span class="comment">// OK：复制初始化选择 A::A(int)</span></span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">2</span>)</span></span>;       <span class="comment">// OK：直接初始化选择 A::A(int)</span></span><br><span class="line">    A a3 {<span class="number">4</span>, <span class="number">5</span>};   <span class="comment">// OK：直接列表初始化选择 A::A(int, int)</span></span><br><span class="line">    A a4 = {<span class="number">4</span>, <span class="number">5</span>}; <span class="comment">// OK：复制列表初始化选择 A::A(int, int)</span></span><br><span class="line">    A a5 = (A)<span class="number">1</span>;   <span class="comment">// OK：显式转型进行 static_cast</span></span><br><span class="line">    <span class="keyword">if</span> (a1) ;      <span class="comment">// OK：A::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> na1 = a1; <span class="comment">// OK：复制初始化选择 A::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> na2 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(a1); <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  B b1 = 1;      // 错误：复制初始化不考虑 B::B(int)</span></span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(<span class="number">2</span>)</span></span>;       <span class="comment">// OK：直接初始化选择 B::B(int)</span></span><br><span class="line">    B b3 {<span class="number">4</span>, <span class="number">5</span>};   <span class="comment">// OK：直接列表初始化选择 B::B(int, int)</span></span><br><span class="line"><span class="comment">//  B b4 = {4, 5}; // 错误：复制列表初始化不考虑 B::B(int,int)</span></span><br><span class="line">    B b5 = (B)<span class="number">1</span>;   <span class="comment">// OK：显式转型进行 static_cast</span></span><br><span class="line">    <span class="keyword">if</span> (b2) ;      <span class="comment">// OK：B::operator bool()</span></span><br><span class="line"><span class="comment">//  bool nb1 = b2; // 错误：复制初始化不考虑 B::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> nb2 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(b2); <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h1 id="继承和派生">继承和派生</h1>
<p><strong>Q</strong>：在什么情况下使用？</p>
<p><strong>A</strong>：在 C++ 中，当定义一个新的类 B 时，如果发现类 B
拥有某个已写好的类 A 的全部特点，此外还有类 A 没有的特点。</p>
<p>此时不必从头重写类B，而是可以</p>
<ul>
<li>把类 A 作为一个 “基类”（也称 “父类”）</li>
<li>把类 B 写为基类 A 的一个 “派生类” （也称子类）</li>
<li>这样，就可以说从类 A “派生”出了类 B，也可以说类 B “继承”了类
A。</li>
</ul>
<p><strong>效果</strong>：派生类是通过对基类进行扩充和修改得到的。基类的所有成员自动成为派生类的成员。</p>
<p><strong>Q</strong>：为什么要提出继承与派生的概念？</p>
<p><strong>A</strong>：</p>
<ul>
<li>提供派生类的概念及其相关语言机制是为了表达 层次关系，即表达
类之间的共性。
<ul>
<li>派生类是通过对基类进行扩充和修改得到的。</li>
<li>基类的所有成员自动成为派生类的成员。</li>
</ul></li>
<li>它是通常所说的 面向对象编程 的基础。
<ul>
<li>如果只有一个类的概念，软件的可重用性、演化和相关的概念表示存在严重的不灵活问题。</li>
<li>继承机制为软件可重用性、IS-A 概念表示和易于修改提供了解决方案。</li>
</ul></li>
<li>继承提供了一种通过修改（演化）一个或多个现有类来构造新类的方法。</li>
</ul>
<p><strong>继承与派生的优势</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="./C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230504102514795.png" alt="image-20230504102514795" style="zoom:40%;"></p>
<h2 id="术语">术语</h2>
<p>4个表示两个类继承关系的术语</p>
<p><img lazyload src="/images/loading.svg" data-src="C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230504101943996.png" alt="image-20230504101943996" style="zoom: 40%;"></p>
<p><img lazyload src="/images/loading.svg" data-src="./C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230504102105604.png" alt="image-20230504102105604" style="zoom:40%;"></p>
<p><strong>C++中继承关系图解</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="./C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230504102614055.png" alt="image-20230504102614055" style="zoom:40%;"></p>
<h2 id="语法">语法</h2>
<p><strong>C++继承关系语法基础</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>{</span><br><span class="line">        isEaten = <span class="literal">true</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"I have eaten"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(){ cout &lt;&lt; <span class="string">"Animal is constructing"</span>&lt;&lt; endl; }</span><br><span class="line">    <span class="type">bool</span> isEaten = <span class="literal">false</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="keyword">public</span> Animal{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(): <span class="built_in">Animal</span>(){cout &lt;&lt; <span class="string">"Dog is constructing"</span>&lt;&lt; endl; }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(isEaten)</span><br><span class="line">            cout &lt;&lt; <span class="string">"I am barking, wang wang wang"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"I am starving, wow"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<p><strong>继承语法</strong></p>
<ul>
<li><p>单重继承的定义形式：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名： 继承访问控制 基类类名{</span><br><span class="line">成员访问控制:</span><br><span class="line">    成员声明列表;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<p>继承访问控制和成员访问控制均由保留public、protected、private来定义，缺省均为private。</p></li>
</ul>
<p><strong>成员访问控制</strong></p>
<ul>
<li>公有继承（public）：
<ul>
<li>在public后声明的成员称为公有成员</li>
<li>公有成员用于描述一个类与外部世界的接口</li>
<li>类的外部（程序的其它部分的代码）可以访问公有成员</li>
</ul></li>
<li>保护继承（protected）：
<ul>
<li>受保护成员具有private与public的双重角色：
<ul>
<li>对派生类的成员函数而言，它为public</li>
<li>而对类的外部而言，它为private</li>
</ul></li>
<li>protected成员只能由本类及其后代类的成员函数访问。</li>
</ul></li>
<li>私有继承（private）：
<ul>
<li>在private后声明的成员称为私有成员</li>
<li>私有成员只能通过本类的成员函数来访问</li>
</ul></li>
</ul>
<p><strong>继承成员的访问控制</strong></p>
<p>影响
<strong>继承成员</strong>（派生类从基类中继承而来的成员）访问控制方式的两个因素：</p>
<ul>
<li>定义派生类时指定的 <strong>继承访问控制</strong></li>
<li>该成员在 <strong>基类</strong> 中所具有的成员访问控制</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="./C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230504115449591.png" alt="image-20230504115449591" style="zoom:40%;"></p>
<ul>
<li>无论采用什么继承方式，基类的私有成员在派生类中都是不可访问的。</li>
<li>“私有”和“不可访问”有区别：私有成员可以由派生类本身访问，不可访问成员即使是派生类本身也不能访问。</li>
<li>大多数情况下均使用 <strong>public 继承</strong></li>
</ul>
<p><strong>访问控制举例</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BASE</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BASE</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_ij</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x_temp;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//公有派生：在Y1类中，i、j是受保护成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y1</span>: <span class="keyword">public</span> BASE</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span>; <span class="comment">//get_ij()是公有成员，x_temp不可访问</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> nmember;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">BASE::<span class="built_in">BASE</span>()</span><br><span class="line">{ i=<span class="number">0</span>; j=<span class="number">0</span>; x_temp=<span class="number">0</span>; }</span><br><span class="line"><span class="type">void</span> BASE:: <span class="built_in">get_ij</span>()</span><br><span class="line">{</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Y1::increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    i++; j++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//程序Access</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    BASE obj1;</span><br><span class="line">    Y1 obj2;</span><br><span class="line">    obj2.<span class="built_in">increment</span>();</span><br><span class="line">    obj2.<span class="built_in">get_ij</span>();</span><br><span class="line">    obj1.<span class="built_in">get_ij</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>保护派生：在Y2类中，i、j是受保护成员。get_ij()变成受保护成员，x_temp不可访问</p>
<p><code>class Y2:protected BASE{ … };</code></p>
<p>私有派生：在Y3类中，i、j、 get_ij()都变成私有成员，x_temp不可访问</p>
<p><code>class Y3:private BASE{ … };</code></p>
<ul>
<li>在大多数情况下，使用public的继承方式；private和protected是很少使用的。
✓ 微软的MFC：全部使用public的继承方式 ✓
AT&amp;T的iostream库：95%以上使用的是public的继承方式</li>
</ul>
<p><strong>派生类对象的存储</strong></p>
<p>派生类的对象不仅存放了在派生类中定义的非静态数据成员，而且也存放了从基类中继承下来的非静态数据成员</p>
<h2 id="构造">构造</h2>
<p><strong>继承时的构造函数</strong></p>
<ul>
<li><p>基类的构造函数
<strong>不被继承</strong>，派生类中需要定义自己的构造函数。</p>
<ul>
<li>派生类的构造函数中只需要对本类中新增成员进行初始化即可。</li>
</ul></li>
<li><p>对继承来的基类成员的初始化：调用基类的构造函数</p>
<p>① 显示在 <strong>初始化器列表</strong>
中调用（注：不能在构造函数内调用！）</p>
<pre><code> 特别是需要使用基类的有参构造函数</code></pre>
<p>② 隐式调用：</p>
<ul>
<li>编译时在派生类构造函数初始化器中自动生成对基类默认构造函数的调用。</li>
<li>如果基类没有默认构造（包括 =delete），则编译错误</li>
</ul></li>
<li><p>（创建派生类对象时）构造函数的<strong>调用次序</strong> ①
首先调用其基类的构造函数（调用顺序按照基类被继承时的声明顺序（从左向右））。</p>
<p>②
然后调用本类对象成员的构造函数（调用顺序按照对象成员在类中的声明顺序）。</p>
<p>③ 最后调用本类的构造函数。</p></li>
</ul>
<p><strong>继承时的析构函数</strong></p>
<ul>
<li><p>撤销派生类对象时析构函数的调用次序与构造函数的调用次序相反</p>
<p>① 首先调用本类的析构函数</p>
<p>② 然后调用本类对象成员的析构函数</p>
<p>③ 最后调用其基类的析构函数</p></li>
</ul>
<p><strong>举例</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Demo.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>( ); <span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">C</span>( ); <span class="comment">//析构函数</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BASE</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BASE</span>( ); <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">BASE</span>( ); <span class="comment">// 析构函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Demo.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> “Demo.h”</span></span><br><span class="line">C::<span class="built_in">C</span>( ) <span class="comment">//构造函数</span></span><br><span class="line">{ </span><br><span class="line">    cout &lt;&lt; <span class="string">"Constructing C object.\n"</span>;</span><br><span class="line">}</span><br><span class="line">C:: ~<span class="built_in">C</span>( ) <span class="comment">//析构函数</span></span><br><span class="line">{ </span><br><span class="line">    cout &lt;&lt; <span class="string">"Destructing C object.\n"</span>;</span><br><span class="line">}</span><br><span class="line">BASE::<span class="built_in">BASE</span>( ) <span class="comment">// 构造函数</span></span><br><span class="line">{ cout &lt;&lt; <span class="string">"Constructing BASE object.\n"</span>; }</span><br><span class="line">BASE:: ~<span class="built_in">BASE</span>( ) <span class="comment">// 析构函数</span></span><br><span class="line">{ cout &lt;&lt; <span class="string">"Destructing BASE object.\n"</span>;}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DERIVED</span>: <span class="keyword">public</span> BASE { <span class="comment">// Derived.h</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DERIVED</span>() <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">DERIVED</span>() <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    C mOBJ;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> “Derived.h” <span class="comment">// Derived.cpp</span></span></span><br><span class="line">DERIVED::<span class="built_in">DERIVED</span>() <span class="comment">// 构造函数</span></span><br><span class="line">{ cout &lt;&lt; <span class="string">"Constructing derived object.\n"</span>; }</span><br><span class="line">DERIVED:: ~<span class="built_in">DERIVED</span>() <span class="comment">// 析构函数</span></span><br><span class="line">{ cout &lt;&lt; <span class="string">"Destructing derived object.\n"</span>; }</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> “Derived.h”</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    DERIVED obj; <span class="comment">// 声明一个派生类的对象</span></span><br><span class="line">    <span class="comment">// 什么也不做，仅完成对象obj的构造与析构</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h2 id="类中不可继承的成员">类中不可继承的成员</h2>
<p>类中哪些成员不可继承？</p>
<ul>
<li>私有成员（注：只是不可访问）</li>
<li>构造函数和析构函数</li>
</ul>
<p>例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>: <span class="function"><span class="keyword">public</span> <span class="title">std::string</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* s): std::<span class="built_in">string</span>(s){}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">"继承 string(const char*)"</span>)</span></span>;</span><br><span class="line">    str1 = <span class="string">"继承 string::operator=(...)"</span>;</span><br><span class="line">    std::cout &lt;&lt; str1 &lt;&lt; std::endl;</span><br><span class="line">    MyString str2 = <span class="string">"hello"</span>;</span><br><span class="line">    std::cout &lt;&lt; str2+str1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h2 id="向基类构造函数传递实参">向基类构造函数传递实参</h2>
<ul>
<li><p>若
<strong>基类构造函数带参数</strong>，则定义派生类构造函数时，<strong>仅能</strong>
通过 <strong>初始化列表显式调用</strong>
基类构造函数，并向基类构造函数传递实参。</p></li>
<li><p>带初始化列表的派生类构造函数的一般形式如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">派生类名（形参表）：基类名（实参表）</span><br><span class="line">{</span><br><span class="line">    派生类新成员初始化赋值语句;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>示例</strong></p>
<p>Time 类</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//time.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> hours, <span class="type">int</span> minutes, <span class="type">int</span> seconds)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Write</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> initHrs, <span class="type">int</span> initMins, <span class="type">int</span> initSecs); <span class="comment">// constructor</span></span><br><span class="line">    <span class="built_in">Time</span>();  <span class="comment">// default constructor</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//exttime.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"time.h"</span></span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ZoneType</span>{EST, CST, MST, PST, EDT, CDT, MDT, PDT };</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExtTime</span>: <span class="keyword">public</span> Time</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ExtTime</span>(<span class="type">int</span> initHrs, <span class="type">int</span> initMins, <span class="type">int</span> initSecs, ZoneType initZone);</span><br><span class="line">    <span class="built_in">ExtTime</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> hours, <span class="type">int</span> minutes, <span class="type">int</span> seconds, ZoneType timeZone)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Write</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ZoneType zone;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//exttime.cpp</span></span><br><span class="line"></span><br><span class="line">ExtTime::<span class="built_in">ExtTime</span>(<span class="type">int</span> initHrs, <span class="type">int</span> initMins, <span class="type">int</span> initSecs, ZoneType initZone): <span class="built_in">Time</span>(initHrs, initMins, initSecs)</span><br><span class="line">{</span><br><span class="line">    zone = initZone;</span><br><span class="line">}</span><br><span class="line">ExtTime::<span class="built_in">ExtTime</span>()</span><br><span class="line">{</span><br><span class="line">    zone = EST;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtTime::Set</span><span class="params">( <span class="type">int</span> hours, <span class="type">int</span> minutes, <span class="type">int</span> seconds,ZoneType timeZone )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Time::<span class="built_in">Set</span>(hours, minutes, seconds);</span><br><span class="line">    zone = timeZone;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtTime::Write</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">static</span> string zoneString[<span class="number">8</span>] =</span><br><span class="line">    { <span class="string">"EST"</span>, <span class="string">"CST"</span>, <span class="string">"MST"</span>, <span class="string">"PST"</span>, <span class="string">"EDT"</span>, <span class="string">"CDT"</span>, <span class="string">"MDT"</span>, <span class="string">"PDT“ };</span></span><br><span class="line"><span class="string">    Time::Write();</span></span><br><span class="line"><span class="string">    cout &lt;&lt; ' ' &lt;&lt; zoneString[zone];</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></table></figure></div>
<p><strong>实现带初始化列表的派生类构造函数的注意事项</strong>：</p>
<ol type="1">
<li>将参数传递给基类构造函数。</li>
<li>基类构造函数在派生类构造函数之前调用。</li>
<li>这里更建议将 zone（initZone）加入初始化器列表中，更加有C++风格</li>
</ol>
<h2 id="派生与成员函数">派生与成员函数</h2>
<ul>
<li><p>重载（overload）</p>
<ul>
<li>具有相同作用域（即同一个类定义中）</li>
<li>函数名字相同</li>
<li>参数类型（包括 const 指针或引用），顺序 或 数目不同</li>
</ul></li>
<li><p>覆盖（override）</p>
<ul>
<li>修改基类函数定义</li>
</ul></li>
<li><p>隐藏（overwrite）</p>
<p>屏蔽 基类的函数定义</p>
<p>① 派生类的函数 与 基类的函数 同名，但是参数列表有所差异。</p>
<p>② 派生类的函数 与 基类的函数 同名，参数列表也相同，但是基类函数没有
virtual 关键字。</p></li>
<li><p>继承</p>
<p>没有被覆盖或隐藏的基类函数，包括基类中重载的函数</p></li>
</ul>
<p><strong>重载和隐藏的区别</strong></p>
<p>例如：<code>Time::Set(int, int, int)</code> 和
<code>ExtTime::Set(int, int, int, ZoneType)</code></p>
<ul>
<li>如果 <code>Set</code> 在一个类中定义，则是
<strong>重载</strong>（Set 的 函数标签不一样）</li>
<li>如果同名函数出现在 Base 和 Derived 中，且满足特征①或②，则属于
<strong>隐藏</strong>
<ul>
<li>ExtTime 案例 Set 满足特征 ①</li>
<li>ExtTime 案例 Write 满足特征 ②</li>
</ul></li>
</ul>
<p>在派生类中隐藏与显式调用基类中的成员函数</p>
<ul>
<li>在派生类中调用被隐藏的函数成员
<ul>
<li>方法：<code>Base::HidenFun(...)</code> 或
<code>this-&gt;Base::HidenFun(...)</code></li>
</ul></li>
</ul>
<p><strong>隐藏的应用</strong></p>
<ul>
<li>利用隐藏，在派生函数中修改成员函数的功能</li>
<li>利用隐藏，赋予派生类成员函数新的功能</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//time.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::Set</span><span class="params">( <span class="type">int</span> hours, <span class="type">int</span> minutes, <span class="type">int</span> seconds )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    hrs = hours;</span><br><span class="line">    mins = minutes;</span><br><span class="line">    secs = seconds;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Exttime.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtTime::Set</span><span class="params">( <span class="type">int</span> hours, <span class="type">int</span> minutes, <span class="type">int</span> seconds,ZoneType timeZone )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Time::<span class="built_in">Set</span>(hours, minutes, seconds);</span><br><span class="line">    zone = timeZone;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h2 id="改变继承访问控制方式">改变继承访问控制方式</h2>
<h3 id="恢复访问控制方式">恢复访问控制方式</h3>
<ul>
<li><p>基类中的 public 或 protected 成员，因使用 protected 或 private
继承访问控制而导致在派生类中的访问方式发生改变，可以使用 “访问声明”
恢复为原来的访问控制方式</p></li>
<li><p>访问声明的形式</p>
<p><code>using 基类名:: 成员名</code>
（放在适当的成员访问控制后）</p></li>
<li><p>使用情景</p>
<p>在派生类中希望大多数继承成员为 protected 或
private，只有少数希望保持为基类原来的访问控制方式。</p></li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BASE</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_i</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        i = x;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_i</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DERIVED</span> : <span class="keyword">private</span> BASE {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> BASE::set_i;   <span class="comment">// 访问声明</span></span><br><span class="line">    <span class="keyword">using</span> BASE::i;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_j</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        j = x;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_ij</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> i + j;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    DERIVED obj;    <span class="comment">// 声明一个派生类的对象</span></span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">set_i</span>(<span class="number">5</span>);    <span class="comment">// set_i()已从私有的转为public</span></span><br><span class="line">    obj.<span class="built_in">set_j</span>(<span class="number">7</span>);    <span class="comment">// set_j()本来就是公有的</span></span><br><span class="line">    cout &lt;&lt; obj.<span class="built_in">get_ij</span>() &lt;&lt; <span class="string">"\n"</span>;    <span class="comment">// get_ij()本来就是公有的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h3 id="屏蔽基类成员">屏蔽基类成员</h3>
<p>目的：使得客户代码通过派生类对象不能访问继承成员。</p>
<p>方法：</p>
<ul>
<li>使用继承访问控制 protected 和 private（真正屏蔽）</li>
<li>在派生类中成员访问控制 protected 或 private 之后，使用 “using
基类名::成员名”（非真正屏蔽，仍可通过使用“基类名::成员名” 访问）</li>
</ul>
<p><strong>用于继承对象的重命名</strong></p>
<p>目的：解决名字冲突，在派生类中选择更合适的术语命名继承成员</p>
<p>方法：①在派生类中定义新的函数，该函数调用旧函数；屏蔽旧函数。</p>
<p>②在派生类中定义新的函数，该函数的函数体与旧函数相同</p>
<p><strong>使用基类构造函数</strong></p>
<p>目的：使得派生类对象直接使用基类的构造函数</p>
<p>方法：在派生类中使用 "using 基类名::基类名"</p>
<h2 id="类型兼容性">类型兼容性</h2>
<ul>
<li><p>赋值运算的类型兼容性</p>
<ul>
<li>可以将后代类的对象赋值给祖先类对象，反之不可以。</li>
</ul>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BASE obj1;</span><br><span class="line">Y1 obj2;</span><br><span class="line">obj1 = obj2; <span class="comment">//可以把obj2中基类的部分内容赋给obj1</span></span><br><span class="line"><span class="comment">//obj2 = obj1; //错误</span></span><br></pre></td></tr></table></figure></div>
<p>原因：每个派生类对象包含一个基类部分，这意味着可以将派生类对象当作基类对象使用。</p></li>
<li><p>指向基类对象的指针 也可指向 公有派生类对象</p></li>
<li><p>只有公有派生类才能兼容基类类型（上述规则只适用于公有派生）</p></li>
</ul>
<p>类型兼容性例子</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">}</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span>: <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span>: <span class="keyword">public</span> D1{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//B.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"B.h"</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Base::display</span><span class="params">()</span></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Base::display"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">D1::display</span><span class="params">()</span></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"D1::display"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> D2:: <span class="built_in">display</span>(){</span><br><span class="line">    cout&lt;&lt;<span class="string">"D2::display()"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Base &amp;ptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ptr-&gt;<span class="built_in">display</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Base b; <span class="comment">//声明Base类对象</span></span><br><span class="line">    D1 d1;  <span class="comment">//声明D1类对象</span></span><br><span class="line">    D2 d2;  <span class="comment">//声明D2类对象</span></span><br><span class="line">    Base *p;<span class="comment">//声明Base类指针</span></span><br><span class="line">    p=&amp;b;   <span class="comment">//Base类指针指向Base类对象</span></span><br><span class="line">    <span class="built_in">fun</span>(p);</span><br><span class="line">    <span class="built_in">fun</span>(b);</span><br><span class="line">    p=&amp;d1;  <span class="comment">//Base类指针指向D1类对象</span></span><br><span class="line">    <span class="built_in">fun</span>(p);</span><br><span class="line">    <span class="built_in">fun</span>(d1);</span><br><span class="line">    p=&amp;d2;  <span class="comment">//Base类指针指向D2类对象(间接派生类对象)</span></span><br><span class="line">    <span class="built_in">fun</span>(p);</span><br><span class="line">    <span class="built_in">fun</span>(d2);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>运行结果</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base::display()</span><br><span class="line">Base::display()</span><br><span class="line">Base::display()</span><br></pre></td></tr></table></figure></div>
<h2 id="对象的类型转换">对象的类型转换</h2>
<p>C++向上转型和向下转型</p>
<ol type="1">
<li><p>隐式转型（向上转型，即将派生类对象赋值给基类）</p>
<p>C++允许向上转型，即将 <strong>派生类对象赋值给基类的对象</strong>
是可以的。其只不过是将派生类中基类的部分直接赋值给基类的对象，这称为向上转型（这里的“上”是指基类），例如：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>{};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base{};</span><br><span class="line"></span><br><span class="line">Base* Bptr;</span><br><span class="line">Derived* Dptr;</span><br><span class="line"></span><br><span class="line">Bptr = Dptr; <span class="comment">//编译正确，允许向上类型转型</span></span><br><span class="line">Dptr = Bptr; <span class="comment">//编译错误，C++不允许隐式的向下转型</span></span><br></pre></td></tr></table></figure></div></li>
<li><p>向下转型</p>
<p>正如上面所述，类层次间的向下转型是不能通过隐式转换完成的。此时要想达到这种转换，可以借助
<code>static_cast</code> 或者 <code>dynamic_cast</code> 。</p>
<ul>
<li><p><code>static_cast</code></p>
<p>例如：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>{};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span>{};</span><br><span class="line"></span><br><span class="line">Base* B;</span><br><span class="line">Derived* D;</span><br><span class="line">D = <span class="built_in">static_cast</span>&lt;Drived*&gt;(B); <span class="comment">//正确，可以使用static_cast向下转型</span></span><br></pre></td></tr></table></figure></div>
<p>注意：<code>static_cast</code>
的使用，仅当类型之间可隐式转化时才是合法的。<code>static_cast</code>
可以完成类层次之间的向下转型。</p></li>
<li><p><code>dynamic_cast</code> （更安全）</p>
<p>dynamic_cast
涉及运行时的类型检查。如果向下转型是安全的（也就是说，如果基类指针或者引用确实指向一个派生类的对象），这个运算符会传回转型过的指针。如果
downcast
不安全（即基类指针或者引用没有指向一个派生类的对象），这个运算符会传回空指针。</p>
<p>注意：要使用 <code>dynamic_cast</code> 类中必须定义虚函数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>{</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>{} </span><br><span class="line"> };</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drived</span> : <span class="keyword">public</span> Base{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"> };</span><br><span class="line">Base *Bptr = <span class="keyword">new</span> <span class="built_in">Drived</span>()；<span class="comment">//语句0</span></span><br><span class="line">Derived *Dptr1 = <span class="built_in">static_cast</span>&lt;Derived *&gt;(Bptr); <span class="comment">//语句1；</span></span><br><span class="line">Derived *Dptr2 = <span class="built_in">dynamic_cast</span>&lt;Derived *&gt;(Bptr); <span class="comment">//语句2；</span></span><br></pre></td></tr></table></figure></div>
<p>此时语句1和语句2都是安全的，因为此时Bptr确实是指向的派生类，虽然其类型被声明为Base*，但是其实际指向的内容确确实实是Drived对象，所以语句1和2都是安全的，Dptr1和Dptr2可以尽情访问Drived类中的成员，绝对不会出问题。</p>
<p><strong>但是此时如果将语句0改为这样：</strong></p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base *Bptr = new Base()；</span><br></pre></td></tr></table></figure></div>
<p>那语句1就不安全了，例如访问Drived类的成员变量i的值时，将得到一个垃圾值。（延后了错误的发现）
语句2使得Dptr2得到的是一个空指针，对空指针进行操作，将发生异常，从而能够尽早的发现错误，这也是为什么说dynamic_cast更安全的原因。</p></li>
</ul></li>
<li><p>多继承时的向下转型</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>{</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>{}</span><br><span class="line">}；</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>{</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>{}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>{}</span><br><span class="line">};</span><br><span class="line">Base1 *pD = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived *pD1  = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(pD);  <span class="comment">//正确，原因和前面类似</span></span><br><span class="line">Derived *pD2  = <span class="built_in">static_cast</span>&lt;Derived*&gt;(pD);  <span class="comment">//正确，原因和前面类似</span></span><br><span class="line">Base2 *pB1  = <span class="built_in">dynamic_cast</span>&lt;Base2*&gt;(pD);    <span class="comment">//语句1</span></span><br><span class="line">Base2 *pB2  = <span class="built_in">static_cast</span>&lt;Base2*&gt;(pD);    <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure></div>
<p>此时的语句1,将pD的类型转化为Base2*，即：使得pB1指向Drived对象的Base2子对象，为什么能达到这种转化？因为dynamic_cast是运行时才决定真正的类型，在运行时发现虽然此时pD的类型是Base1*，但是实际指向的是Derived类型的对象，那么就可以通过调整指针，来达到pB1指向Derived
对象的Base2子对象的目的；</p>
<p>但是语句2就不行了，其使用的是static_cast，它不涉及运行时的类型检查，对于它来讲，pD的类型是Base1*，Base1和Base2没有任何关系，那就会出现编译错误了。error:
invalid static_cast from type ‘Base1*’ to type ‘Base2*’</p>
<p>总结：对于多种继承，如果pD真的是指向Derived，使用static_cast和dynamic_cast都可以转化为Derived，但是如果要转化为Base1的兄弟类Base2，必须使用dynamic_cast，使用static_cast不能通过编译。</p>
<p>ps：因为Derived和Base1和Base2*之间存在隐式转化，可以将语句2修改为：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pB2 = static_cast&lt;Base2*&gt;(static_cast&lt;Derived*&gt;(pD));</span><br></pre></td></tr></table></figure></div>
<p>这样就可以完成转换。</p></li>
<li><p><code>const_cast</code></p>
<p>语法：<code>const_cast&lt;type_id&gt; (expression)</code></p>
<p>该运算符用来修改类型的const或volatile属性。除了const
或volatile修饰之外， type_id和expression的类型是一样的。</p>
<p>一、常量指针被转化成<strong>非常量</strong>的指针，并且仍然指向原来的对象；</p>
<pre><code>（去除指向常变量指针的常变量性）</code></pre>
<p>二、常量引用被转换成<strong>非常量</strong>的引用，并且仍然指向原来的对象；</p>
<p>三、const_cast一般用于修改底指针。如const char *p形式。</p></li>
</ol>
<h2 id="多继承">多继承</h2>
<p>派生类都只有一个基类，称为单继承（Single
Inheritance）。除此之外，C++也支持多继承（Multiple
Inheritance），即一个派生类可以有两个或多个基类。</p>
<p>例如已声明了类A、类B和类C，那么可以这样来声明派生类D：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> A, <span class="keyword">private</span> B, <span class="keyword">protected</span> C{</span><br><span class="line">    <span class="comment">//类D新增加的成员</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p><strong>多继承下的构造函数</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">D</span>(形参列表): <span class="built_in">A</span>(实参列表), <span class="built_in">B</span>(实参列表), <span class="built_in">C</span>(实参列表){</span><br><span class="line">    <span class="comment">//其他操作</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>先调用 A 类的构造函数，再调用 B 类构造函数，最后调用 C
类构造函数。</p>
<p>多继承的实例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseA</span>(<span class="type">int</span> a, <span class="type">int</span> b);</span><br><span class="line">    ~<span class="built_in">BaseA</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">};</span><br><span class="line">BaseA::<span class="built_in">BaseA</span>(<span class="type">int</span> a, <span class="type">int</span> b): <span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b){</span><br><span class="line">    cout&lt;&lt;<span class="string">"BaseA constructor"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">BaseA::~<span class="built_in">BaseA</span>(){</span><br><span class="line">    cout&lt;&lt;<span class="string">"BaseA destructor"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseB</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseB</span>(<span class="type">int</span> c, <span class="type">int</span> d);</span><br><span class="line">    ~<span class="built_in">BaseB</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_c;</span><br><span class="line">    <span class="type">int</span> m_d;</span><br><span class="line">};</span><br><span class="line">BaseB::<span class="built_in">BaseB</span>(<span class="type">int</span> c, <span class="type">int</span> d): <span class="built_in">m_c</span>(c), <span class="built_in">m_d</span>(d){</span><br><span class="line">    cout&lt;&lt;<span class="string">"BaseB constructor"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">BaseB::~<span class="built_in">BaseB</span>(){</span><br><span class="line">    cout&lt;&lt;<span class="string">"BaseB destructor"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> BaseA, <span class="keyword">public</span> BaseB{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e);</span><br><span class="line">    ~<span class="built_in">Derived</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_e;</span><br><span class="line">};</span><br><span class="line">Derived::<span class="built_in">Derived</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e): <span class="built_in">BaseA</span>(a, b), <span class="built_in">BaseB</span>(c, d), <span class="built_in">m_e</span>(e){</span><br><span class="line">    cout&lt;&lt;<span class="string">"Derived constructor"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">Derived::~<span class="built_in">Derived</span>(){</span><br><span class="line">    cout&lt;&lt;<span class="string">"Derived destructor"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derived::show</span><span class="params">()</span></span>{</span><br><span class="line">    cout&lt;&lt;m_a&lt;&lt;<span class="string">", "</span>&lt;&lt;m_b&lt;&lt;<span class="string">", "</span>&lt;&lt;m_c&lt;&lt;<span class="string">", "</span>&lt;&lt;m_d&lt;&lt;<span class="string">", "</span>&lt;&lt;m_e&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="function">Derived <span class="title">obj</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h3 id="虚基类">虚基类</h3>
<ul>
<li>继承基类时，在继承访问控制前添加保留字“virtual”。
那么这个基类就是一个虚拟基类。
<ul>
<li>虚拟基类用于共享继承。</li>
<li>普通基类与虚基类之间的区别只有在派生类重复继承了某一基类时才表现出来。</li>
</ul></li>
<li>创建后代类对象时，<code>virtual</code>
关键字保证了<strong>虚基类的唯一副本只被初始化一次</strong>。
<ul>
<li>若派生类有一个虚基类作为祖先类，则在派生类构造函数中需要列出对虚基类构造函数的调用（否则，调用虚基类的默认构造函数），且对<u>虚基类构造函数的调用总是先于普通基类的构造函数</u>。</li>
<li>创建派生类对象时构造函数的调用次序： ① 最先调用虚基类的构造函数； ②
其次调用普通基类的构造函数，多个基类则按<strong>派生类声明时列出的次序</strong>、从左到右调用，而不是初始化列表中的次序；
③
再调用对象成员的构造函数，按类声明中对象成员出现的次序调用，而不是初始化列表中的次序
④ 最后执行派生类的构造函数。</li>
</ul></li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {<span class="keyword">public</span>: <span class="type">int</span> i;};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Derived obj; <span class="comment">// 声明一个派生类对象</span></span><br><span class="line">    obj.i = <span class="number">3</span>;   <span class="comment">// 正确：从Base继承的i在Derived中只有一份</span></span><br><span class="line">    obj.j = <span class="number">5</span>;   <span class="comment">// 正确：使用从Base1继承的j</span></span><br><span class="line">    obj.k = <span class="number">7</span>;   <span class="comment">// 正确：使用从Base2继承的k</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derivedA</span> : <span class="keyword">public</span> baseB, <span class="keyword">virtual</span> <span class="keyword">public</span> baseA</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">derivedA</span>()</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; endl &lt;&lt; <span class="string">"This is derivedA class."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derivedB</span> : <span class="keyword">public</span> baseB, <span class="keyword">virtual</span> <span class="keyword">public</span> baseA</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">derivedB</span>()</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; endl &lt;&lt; <span class="string">"This is derivedB class."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> derivedA, <span class="keyword">virtual</span> <span class="keyword">public</span> derivedB</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()</span><br><span class="line">    {</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">"This is Derived class."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Derived obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>运行结果</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">This is baseA class.</span><br><span class="line">This is baseB class.</span><br><span class="line">This is derivedB class.</span><br><span class="line">This is baseB class.</span><br><span class="line">This is derivedA class.</span><br><span class="line">This is Derived class.</span><br></pre></td></tr></table></figure></div>
<p>构造顺序： 1.先基类后成员 2.先虚后实 3.先左后右 析构顺序：
与构造顺序相反</p>
<h2 id="多态">多态</h2>
<h3 id="虚函数">虚函数</h3>
<p>虚函数是一个类的成员函数，前面有关键字 <code>virtual</code></p>
<p>作用：</p>
<ol type="1">
<li>提醒在 公有继承层次中的一个或多个派生类中要对虚函数进行重定义。</li>
<li>并且当使用基类指针（或引用）调用派生类的对象的虚函数时，将调用该对象的虚函数的重定义版本。</li>
</ol>
<h3 id="覆盖override-与-隐藏overwrite">覆盖(override) 与
隐藏(overwrite)</h3>
<ul>
<li><p>覆盖（override）</p>
<ul>
<li>形式：派生类定义的函数与从（基类或非直接基类中）继承的虚函数有同样的签名，即函数名，参数类型，顺序和数量都必须相同。</li>
<li>效果：与同名的继承虚函数是语义相关的，将修改（即重新定义）继承虚函数的实现语义</li>
</ul></li>
<li><p>隐藏（overwrite）</p>
<ul>
<li>形式
1：派生类定义的函数与继承成员函数同名，但是参数列表有所差异。</li>
<li>形式
2：派生类定义的函数与继承成员函数同名，参数列表也相同，但是基类函数没有
<code>virtual</code> 关键字。</li>
<li>效果：与同名的继承成员是语义无关的，
将屏蔽继承成员（即重新声明这个函数名）</li>
</ul></li>
<li><p>使用效果的场景：</p>
<ul>
<li>对象指针（引用）被向上转型到基类指针（引用）。即通过指向派生类对象的基类指针（引用）调用同名函数。
<ul>
<li>覆盖：调用派生类对象的虚函数版本。</li>
<li>隐藏：调用基类的函数。</li>
</ul></li>
<li>派生类对象赋值到基类对象，即通过基类对象调用同名函数
<ul>
<li>按基类行为调用该函数</li>
</ul></li>
</ul></li>
</ul>
<img lazyload src="/images/loading.svg" data-src="/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230518155822471.png" class title="image-20230518155822471">
<h3 id="多态的概念">多态的概念</h3>
<p>程序语言中，哪些标识符有哪些会满足多态定义？</p>
<ul>
<li><p>函数重载（Function Overload）</p></li>
<li><p>方法覆盖（Method Override）</p>
<p>有虚函数基类的 指针或引用，它可指代派生类的对象</p></li>
<li><p>泛型（Generics）/模板（Template），即“参数化类型”</p>
<p>模板名，例如 vector 可泛化指代各种类型数据的数组</p></li>
</ul>
<p>多态标识符必须指派具体的函数或方法以实现规定的语义。</p>
<p><strong>静态绑定</strong>：如果在运行前由编译完成这个指派，称为静态绑定</p>
<p><strong>动态绑定</strong>：如果在运行期间完成这个指派，称为动态绑定</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230518160058527.png" class title="image-20230518160058527">
<p><strong>静态类型</strong>：对程序进行编译时分析所得到的表达式的类型被称为表达式的静态类型。程序执行时静态类型不会更改。</p>
<p><strong>动态类型</strong>：若某个泛左值表达式（如指针、引用）指代某个多态对象，则其最终派生对象的类型被称为其动态类型。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> { <span class="keyword">virtual</span> ~<span class="built_in">B</span>() {} }; <span class="comment">// 多态类型：至少包含一个虚函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span>: B {}; <span class="comment">// 多态类型</span></span><br><span class="line">D d; <span class="comment">// 最终派生对象</span></span><br><span class="line">B* ptr = &amp;d;</span><br><span class="line"><span class="comment">// (*ptr) 的静态类型为 B 。什么条件下 *Ptr 是静态类型？final 类</span></span><br><span class="line"><span class="comment">// (*ptr) 的动态类型为 D</span></span><br></pre></td></tr></table></figure></div>
<h3 id="静态绑定">静态绑定</h3>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm a fruit!\n"</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> : <span class="keyword">public</span> Fruit{</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span> : <span class="keyword">public</span> Fruit{</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cherry</span> : <span class="keyword">public</span> Fruit{</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Apple a;</span><br><span class="line">    Banana b;</span><br><span class="line">    Cherry c;</span><br><span class="line">    a.<span class="built_in">say</span>();</span><br><span class="line">    b.<span class="built_in">say</span>();</span><br><span class="line">    c.<span class="built_in">say</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>从继承的特性可知， Apple、Banana、Cherry
这3个类中即使没有实现“say”函数，会自动继承Fruit类的函数。</p>
<p>在 main 函数中， 对<code>a.say()</code>
编译会延Apple继承树向上，找到最近的say成员函数定义，并翻译为<code>call Fruit::say(a)</code>，即
<strong>静态联编</strong>。</p>
<p>所以main函数中三次调用都会输出“I‘m a
fruit!”。显然，我们想要它们输出自己的水果种类，那就期望重写（Override or
Overwrite）“say”函数。</p>
<p>重写一个相同函数名、相同参数的函数，会覆盖或隐藏之前继承而来的函数。那么再次调用Apple对象的“say”函数时，就不会输出“I‘m
a fruit!”。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I'm a fruit!\n"</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> : <span class="keyword">public</span> Fruit{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I'm an apple!\n"</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span> : <span class="keyword">public</span> Fruit{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I'm a banana!\n"</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<p>这里 say 不是虚函数。所以编译器翻译<code>a.say()</code>时
延Apple继承树向上，找到最近的say成员函数定义，并翻译为<code>call Apple::say(a)</code>，得到期望输出
“I‘m an apple!”</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Apple a;</span><br><span class="line">    Fruit *fPtr = &amp;a;</span><br><span class="line">    fPtr-&gt;<span class="built_in">say</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p><strong>基类指针指向派生类对象</strong>，这对于实现多态性的行为是至关重要的。</p>
<p>派生类可以重写从基类继承过来的函数,上述 <code>main</code>
函数的输出为：<code>I’m a fruit!</code></p>
<p>C++默认这样的成员函数“重写”为隐藏。 由于 Fruit
不是多态类型，因此编译器使用<code>*fPtr</code> 的静态类型解释
<code>fPtr-&gt;say()</code>，即解释为<code>Fruit::Say(fptr)</code></p>
<h3 id="动态绑定">动态绑定</h3>
<p>仅需要在基类的成员函数前面加上<code>virtual</code>关键字，就能把一个函数声明为虚函数。该类及其子类都是多态类型。（注意：apple也是多态类型）</p>
<p>当
多态类型指针（或引用）调用虚函数时，则产生多态现象，即调用指针所指向的对象的成员函数，上述代码输出“I’m
an apple!”</p>
<h3 id="纯虚函数与抽象类">纯虚函数与抽象类</h3>
<p>纯虚函数：用<code>=0</code>
作为虚函数声明的后缀，表明该函数是纯虚函数</p>
<ul>
<li>纯虚函数可以（不建议）给定义。（若纯虚函数是析构函数则必须提供）</li>
</ul>
<p>抽象类（Abstract Class）：定义或继承了至少一个纯虚函数的类。</p>
<ul>
<li>抽象类不能被实例化</li>
<li>抽象函数的子类是抽象类，除非所有的纯虚函数都被覆写（override）为非纯虚函数</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<p>示例：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Abstract</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚</span></span><br><span class="line">}; <span class="comment">// "Abstract" 是抽象的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Concrete</span> : Abstract</span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span>{}   <span class="comment">// 非纯虚</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;      <span class="comment">// 非纯虚</span></span><br><span class="line">}; <span class="comment">// "Concrete" 不是抽象的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Abstract2</span> : Concrete</span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> <span class="keyword">override</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚覆盖函数</span></span><br><span class="line">}; <span class="comment">// "Abstract2" 是抽象的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Abstract a;   // 错误：不能创建抽象类的对象</span></span><br><span class="line">    Concrete b;      <span class="comment">// OK</span></span><br><span class="line">    Abstract&amp; a = b; <span class="comment">// OK：到抽象基类的引用</span></span><br><span class="line">    a.<span class="built_in">f</span>();           <span class="comment">// 虚派发到 Concrete::f()</span></span><br><span class="line">    <span class="comment">// Abstract2 a2; // 错误：不能创建抽象类的对象（g() 的最终覆盖函数是纯虚的）</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>抽象类语法与语义：</p>
<ul>
<li>仅能作为基类指针或引用，因为不可能存在抽象对象
<ul>
<li>能声明为指针或引用，指代自己派生类对象</li>
<li>不能定义抽象类的对象</li>
<li>不能显示转为抽象类对象</li>
<li>不能作为函数参数类型或者返回的值</li>
</ul></li>
</ul>
<h3 id="虚析构函数">虚析构函数</h3>
<p>程序回避了 new 包含虚析构函数的类 这样的语句，因为</p>
<ul>
<li>在抽象与接口案例中，多态类型指针必须动态转换为对象实际类型指针才能正确执行对象析构过程。</li>
<li>若基类声明其析构函数为
virtual，则派生的析构函数始终覆盖它。这使得可以通过指向基类的指针 delete
动态分配的多态类型对象。</li>
<li>任何包含虚函数的基类的析构函数必须为公开且虚，或受保护且非虚。否则很容易导致内存泄漏</li>
</ul>
<h3 id="rtti概念">RTTI概念</h3>
<p>RTTI (Run Time Type Identification)
即通过运行时类型识别，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。</p>
<ul>
<li>C
是一种静态类型语言。其数据类型是在编译期就确定的，不能在运行时更改。</li>
<li>面向对象程序设计中多态性要求，C++中的指针或引用本身的类型，可能与它实际指代(指向或引用)的类型并不一致，需要在运行时将一个多态指针转换为其实际指向对象的类型。</li>
<li>RTTI 提供了两个非常有用的操作符：<code>typeid</code> 和
<code>dynamic_cast</code>。
<ul>
<li><code>typeid</code>
操作符，返回指针和引用所指的<u>实际类型</u>（type_info 对象）</li>
<li><code>dynamic_cast</code>
操作符，将基类类型的指针或引用安全地转换为其派生类类型的指针或引用</li>
</ul></li>
</ul>
<h4 id="typeid-运算符">typeid 运算符</h4>
<p>查询类型的信息。用于必须知晓多态对象的动态类型的场合以及静态类型鉴别</p>
<ul>
<li>在使用 <code>typeid</code> 前，必须包含头文件
<code>&lt;typeinfo&gt;</code></li>
<li><code>typeid</code> 返回 <code>std::type_info</code>
对象，它常用的有 ==、!= 运算符 和 <code>name()</code> 成员</li>
</ul>
<p>语法1：<code>typeid ( 类型 )</code></p>
<ul>
<li>指代一个表示 类型 类型的 std::type_info 对象。若 类型
为引用类型，则结果所指代的<code>std::type_info</code>
对象表示被引用的类型。</li>
</ul>
<p>语法2：<code>typeid ( 表达式 )</code></p>
<ul>
<li>若 表达式
为标识某个多态类型（即声明或继承至少一个虚函数的类）对象的泛左值表达式，则
<code>typeid</code> 表达式对该表达式求值，然后指代表示该表达式动态类型的
<code>std::type_info</code> 对象。</li>
<li>若 表达式 不是多态类型的泛左值表达式，则 typeid
不对该表达式求值，而是由编译静态推导表达式静态类型的
<code>std::type_info</code> 对象</li>
</ul>
<h4 id="dynamic_cast-类型转换运算符">dynamic_cast 类型转换运算符</h4>
<p>沿继承层级向上、向下及侧向，安全地转换到其他类的指针和引用。</p>
<p>语法：<code>dynamic_cast &lt;新类型&gt; ( 表达式 )</code></p>
<p>若转型成功，则 dynamic_cast 返回 新类型 类型的值。</p>
<p>若转型失败，</p>
<ul>
<li>且 新类型 是指针类型，则它返回该类型的空指针。</li>
<li>且 新类型 是引用类型，则它抛出与类型 <code>std::bad_cast</code>
的处理块匹配的异常。</li>
</ul>
<p>指定某个虚函数不能在子类中被覆盖，或者某个类不能被子类继承。</p>
<p>示例</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> : Base</span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// Base::foo 被覆盖而 A::foo 是最终覆盖函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// 错误：bar 非虚，因此它不能是 final 的</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> <span class="keyword">final</span> : A <span class="comment">// struct B 为 final</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// 错误：foo 不能被覆盖，因为它在 A 中是 final 的</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> : B{}; <span class="comment">// 错误：B 是 final 的</span></span><br></pre></td></tr></table></figure></div>
<h2 id="泛型编程">泛型编程</h2>
<p>独立于任何特定数据类型的编程，这使得不同类型的数据（对象）可以被相同的代码操作。</p>
<p>C++中，使用模板(template)来泛型编程，包括</p>
<ul>
<li><p>函数模板</p></li>
<li><p>类模板</p></li>
</ul>
<p>实例化（Instantiation）：由编译器将通用模板代码转换为处理特定类型数据的实例代码的过程称为实例化</p>
<ul>
<li>当从通用代码创建实例代码时，具体数据类型才被确定</li>
<li>泛型编程是一种编译时多态性（静态多态）。其中，数据类型本身是参数化的，因而程序具有多态性特征</li>
</ul>
<h3 id="函数模板">函数模板</h3>
<p>作用：使用相同的处理过程，处理不同类型的数据。能够减少代码，
甚至能处理编程时未知的数据类型。</p>
<p>函数模板的一般形式</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;模板形参表&gt;</span><br><span class="line">返回值类型 函数名（形式参数列表）</span><br><span class="line">{</span><br><span class="line">    函数体语句</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>注：形式参数列表中必须包含模板形参表中出现的所有模板形参</p>
<p>交换函数的含模板的代码</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; v1, T&amp; v2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    T temp;</span><br><span class="line">    temp = v1;</span><br><span class="line">    v1 = v2;</span><br><span class="line">    v2 = temp;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>对上述函数模板进行实例化</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::string <span class="title">s1</span><span class="params">(<span class="string">"rabbit"</span>)</span>, <span class="title">s2</span><span class="params">(<span class="string">"bear"</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> iv1 = <span class="number">3</span>, iv2 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> dv1 = <span class="number">2.8</span>, dv2 = <span class="number">8.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数模板的实例Swap(string&amp;, string&amp;)</span></span><br><span class="line">    <span class="built_in">Swap</span>(s1, s2);</span><br><span class="line">    <span class="comment">// 调用函数模板的实例Swap(int&amp;, int&amp;)</span></span><br><span class="line">    <span class="built_in">Swap</span>(iv1, iv2);</span><br><span class="line">    <span class="comment">// 调用Swap的实例Swap(double&amp;, double&amp;)</span></span><br><span class="line">    <span class="built_in">Swap</span>(dv1, dv2);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>函数模板实例化</p>
<p>调用函数模板的过程：</p>
<ol type="1">
<li><p>模板实参推断（template argument deduction）：</p>
<p>编译器根据函数调用中所给出的实参的类型，确定相应的模板实参。</p>
<p>显式实例化，显式指定模板形参的类型</p></li>
<li><p>函数模板的实例化（instantiation）：</p>
<p>模板实参确定之后，编译器就使用模板实参代替相应的模板形参，产生并编译函数模板的一个特定版本（称为函数模板的一个实例（instance））</p>
<p>注意：此过程中不进行常规隐式类型转换</p></li>
</ol>
<p>函数模板特化</p>
<ul>
<li><p>情形：在函数模板当中有些特殊的类型，当想要针对特殊的类型进行一些特殊的处理，这时候就可以用函数模板的特化</p></li>
<li><p>特化方法：在正常的函数模板下面接着编写代码，写一个空的template&lt;&gt;然后写个具体的函数代码来补充。如左图所示。</p></li>
<li><p>效果：如实例所示，当传入的实参类型是int类型，就执行函数模板的特化部分，而非int类型执行正常的模板推断</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">( T&amp; v1, T&amp; v2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    T temp;</span><br><span class="line">    temp = v1;</span><br><span class="line">    v1 = v2;</span><br><span class="line">    v2 = temp;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">( <span class="type">int</span> &amp; v1, <span class="type">int</span> &amp; v2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = v1;</span><br><span class="line">    v1 = v2;</span><br><span class="line">    v2 = temp;</span><br><span class="line">    v1 += <span class="number">10</span>;</span><br><span class="line">    v2 += <span class="number">10</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>函数模板重载</p>
<ul>
<li>定义名字相同而函数形参表不同的函数模板</li>
<li>或者定义与函数模板同名的非模板函数(正常函数)，在其函数体中完成不同的行为</li>
</ul>
<p>函数调用的静态绑定规则（重载协议）：</p>
<ol type="1">
<li>如果某一同名非模板函数(指正常的函数)的形参类型正好与函数调用的实参类型匹配(完全一致)，则调用该函数。否则，进入第2步</li>
<li>如果能从同名的函数模板实例化一个函数实例，而该函数实例的形参类型正好与函数调用的实参类型匹配(完全一致)，则调用该函数模板的实例函数。否则，进入第3步在步骤2中：首先匹配函数模板的特化，再匹配非指定特殊的函数模板</li>
<li>对函数调用的实参进行隐式类型转换后与非模板函数再次进行匹配，若能找到匹
配的函数则调用该函数。否则，进入第4步</li>
<li>提示编译错误</li>
</ol>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数模板demoPrint</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demoPrint</span><span class="params">(<span class="type">const</span> T v1, <span class="type">const</span> T v2)</span></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"the first version of demoPrint()"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"the arguments: "</span> &lt;&lt; v1 &lt;&lt; <span class="string">" "</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 函数模板demoPrint的特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demoPrint</span><span class="params">(<span class="type">const</span> <span class="type">char</span> v1, <span class="type">const</span> <span class="type">char</span> v2)</span></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"the specify special of demoPrint()"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"the arguments: "</span> &lt;&lt; v1 &lt;&lt; <span class="string">" "</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 函数模板demoPrint重载的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demoPrint</span><span class="params">(<span class="type">const</span> T v)</span></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"the second version of demoPrint()"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"the argument: "</span> &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 非函数模板demoPrint</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demoPrint</span><span class="params">(<span class="type">const</span> <span class="type">double</span> v1, <span class="type">const</span> <span class="type">double</span> v2)</span></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"the nonfunctional template version of demoPrint()"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"the arguments: "</span> &lt;&lt; v1 &lt;&lt; <span class="string">" "</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* 函数调用 */</span></span><br><span class="line">    <span class="function">string <span class="title">s1</span><span class="params">(<span class="string">"rabbit"</span>)</span>, <span class="title">s2</span><span class="params">(<span class="string">"bear"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">c1</span><span class="params">(<span class="string">'k'</span>)</span>, <span class="title">c2</span><span class="params">(<span class="string">'b'</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> iv1 = <span class="number">3</span>, iv2 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> dv1 = <span class="number">2.8</span>, dv2 = <span class="number">8.5</span>;</span><br><span class="line">    <span class="comment">// 调用第一个函数模板</span></span><br><span class="line">    <span class="built_in">demoPrint</span>(iv1, iv2);</span><br><span class="line">    <span class="comment">// 调用第一个函数模板的特化</span></span><br><span class="line">    <span class="built_in">demoPrint</span>(c1, c2);</span><br><span class="line">    <span class="comment">// 调用第二个函数模板</span></span><br><span class="line">    <span class="built_in">demoPrint</span>(iv1);</span><br><span class="line">    <span class="comment">// 调用非函数模板</span></span><br><span class="line">    <span class="built_in">demoPrint</span>(dv1, dv2);</span><br><span class="line">    <span class="comment">// 隐式转换后调用非函数模板</span></span><br><span class="line">    <span class="built_in">demoPrint</span>(iv1, dv2);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h3 id="类模板">类模板</h3>
<p>使用情景：定义可以存放任意类型对象的通用容器类 •
定义一个栈（stack）类，即可用于存放int型对象，又可用于存放float、double、string…甚至任意未知类型的元素
•
定义一个队列（queue）类，即可用于存放int型对象，又可用于存放float、double、string…甚至任意未知类型的元素</p>
<p>实现方式：为类声明一种模板，使得类中的某些数据成员、某些成员函数的参数、某些成员函数的返回值，能取任意类型（包括基本类型和用户自定义类型）</p>
<p>类模板的一般形式：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 类模板一般形式 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;模板形参表&gt;</span><br><span class="line"><span class="keyword">class</span> 类模板名</span><br><span class="line">{</span><br><span class="line">    类成员声明</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>在类模板外定义成员函数的一般形式：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在类模板外定义成员函数的一般形式 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;模板形参表&gt;</span><br><span class="line">返回值类型 类模板名&lt;模板形参名列表&gt;::函数名(函数形参表)</span><br><span class="line">{</span><br><span class="line">    函数实现</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>其中模板形参表的形式为：template &lt;typename 类型参数1, typename
类型参数2, ...&gt;
（注：模板形参每项是非类型形参、类型形参、模板形参之一。)</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 类模板：使用链表实现的栈*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElementType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line">    ~<span class="built_in">Stack</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(ElementType obj)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> <span class="title">throw</span><span class="params">(std::logic_error)</span></span>;</span><br><span class="line">    <span class="function">ElementType <span class="title">getTop</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">(std::logic_error)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 栈节点类型 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">    {</span><br><span class="line">    ElementType element; <span class="comment">// 结点中存放的元素</span></span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="comment">// 指向下一结点的指针</span></span><br><span class="line">    };</span><br><span class="line">    Node* top;</span><br><span class="line">    <span class="comment">// 栈顶节点</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">/* 向栈内压入元素 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElementType&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;ElementType&gt;::<span class="built_in">push</span>( ElementType obj ) <span class="keyword">throw</span>(std::bad_alloc)</span><br><span class="line">{</span><br><span class="line">    Node* temp;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        temp = <span class="keyword">new</span> Node;</span><br><span class="line">        temp -&gt; element = obj;</span><br><span class="line">        temp -&gt; next = top;</span><br><span class="line">        top = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">catch</span> (std::bad_alloc e) { <span class="comment">// 内存分配失败时进行异常处理</span></span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">        <span class="comment">// 重新抛出异常</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 从栈顶弹出元素 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElementType&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;ElementType&gt;::<span class="built_in">pop</span>() <span class="keyword">throw</span>(std::logic_error)</span><br><span class="line">{</span><br><span class="line">    Node* temp;</span><br><span class="line">    <span class="keyword">if</span> (top != <span class="literal">NULL</span>) {</span><br><span class="line">        temp = top;</span><br><span class="line">        top = top -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> { <span class="comment">// 栈为空时抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">"pop from empty Stack"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈顶元素 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElementType&gt;</span><br><span class="line">ElementType Stack&lt;ElementType&gt;::<span class="built_in">getTop</span>() <span class="function"><span class="type">const</span> <span class="title">throw</span><span class="params">(std::logic_error)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (top != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> top-&gt;element;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> { <span class="comment">//栈为空时抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">"getTop from empty Stack"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 判断栈是否为空 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElementType&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;ElementType&gt;::<span class="built_in">isEmpty</span>() <span class="type">const</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> top == <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 主函数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Stack&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line">    <span class="comment">// 实例化一个保存int型元素的栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">9</span>; i++) <span class="comment">// 向栈中压入8个元素</span></span><br><span class="line">    stack.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">isEmpty</span>()) {</span><br><span class="line">        <span class="comment">// 栈不为空时循环</span></span><br><span class="line">        cout &lt;&lt; stack.<span class="built_in">getTop</span>() &lt;&lt; <span class="string">" "</span>; <span class="comment">// 显示栈顶元素</span></span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h3 id="非函数模板形参">非函数模板形参</h3>
<ul>
<li><p>两类模板形参：类型模板形参和非类型模板形参</p></li>
<li><p>非类型模板形参：</p>
<ul>
<li><p>相当于模板内部的常量</p></li>
<li><p>形式上类似于普通的函数形参</p></li>
<li><p>对模板进行实例化时，非类型形参由相应模板实参的值代替</p></li>
<li><p>对应的模板实参必须是 <strong>编译时常量表达式</strong></p></li>
</ul></li>
</ul>
<p>示例1：以数组实现的栈类模板</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 类模板：使用数组实现的栈*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElementType, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line">    ~<span class="built_in">Stack</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(ElementType obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ElementType <span class="title">getTop</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 栈节点类型 */</span></span><br><span class="line">    ElementType elements[N];</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">};</span><br><span class="line"><span class="comment">/* 主函数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Stack&lt;<span class="type">int</span>, <span class="number">10</span>&gt; stack;</span><br><span class="line">    <span class="comment">// 实例化一个保存int型元素的栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">9</span>; i++) <span class="comment">// 向栈中压入8个元素</span></span><br><span class="line">    stack.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">isEmpty</span>()) {</span><br><span class="line">        <span class="comment">// 栈不为空时循环</span></span><br><span class="line">        cout &lt;&lt; stack.<span class="built_in">getTop</span>() &lt;&lt; <span class="string">" "</span>; <span class="comment">// 显示栈顶元素</span></span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h3 id="函数模板的非类型模板形参">函数模板的非类型模板形参</h3>
<p>打印函数</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 非类型模板形参实例2 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValues</span><span class="params">(T (&amp;arr)[N])</span> </span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != N; ++i)</span><br><span class="line">    cout&lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> intArr[<span class="number">6</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>};</span><br><span class="line">    <span class="type">double</span> dblArr[<span class="number">4</span>] = {<span class="number">1.2</span>, <span class="number">2.3</span>, <span class="number">3.4</span>, <span class="number">4.5</span>};</span><br><span class="line">    <span class="comment">// 生成函数实例printValues(int (&amp;) [6])</span></span><br><span class="line">    <span class="built_in">printValues</span>(intArr);</span><br><span class="line">    <span class="comment">// 生成函数实例printValues(double (&amp;) [4])</span></span><br><span class="line">    <span class="built_in">printValues</span>(dblArr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 非类型模板形参实例2 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValues</span><span class="params">(T (*arr)[N])</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != N; ++i)</span><br><span class="line">    cout&lt;&lt; (*arr)[i] &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> intArr[<span class="number">6</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>};</span><br><span class="line">    <span class="type">double</span> dblArr[<span class="number">4</span>] = {<span class="number">1.2</span>, <span class="number">2.3</span>, <span class="number">3.4</span>, <span class="number">4.5</span>};</span><br><span class="line">    <span class="comment">// 生成函数实例printValues(int (&amp;) [6])</span></span><br><span class="line">    <span class="built_in">printValues</span>(&amp;intArr);</span><br><span class="line">    <span class="comment">// 生成函数实例printValues(double (&amp;) [4])</span></span><br><span class="line">    <span class="built_in">printValues</span>(&amp;dblArr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h2 id="stl">STL</h2>
<p>C++标准库的一部分</p>
<h3 id="容器">容器</h3>
<p>容器是储存其他对象的对象</p>
<p>容器分为四种： • 序列式容器 • 关联式容器 • 无序关联式容器 •
容器适配器 简单来说，每个容器提供了一种适配大部分类型的数据结构</p>
<p>迭代器：迭代器是每种容器各自定义的一个或多个不同于容器的类，比如
<code>vector&lt;T&gt;::iterator</code>，它主要用于访问、修改、增加、删除容器中的元素。</p>
<p>按照功能的不同，C++17之前的迭代器分为:
LegacyInputIterator（输入迭代器）, LegacyOutputIterator（输出迭代器）,
LegacyForwardIterator（单向迭代器）,
LegacyBidirectionalIterator（双向迭代器）,
LegacyRandomAccessIterator（随机迭代器） 五种，C++17加入了
LegacyContiguousIterator （连续迭代器）</p>
<h4 id="序列式容器类型">序列式容器类型</h4>
<img lazyload src="/images/loading.svg" data-src="/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615150811607.png" class title="image-20230615150811607">
<p><strong>构造函数</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615151036096.png" class title="image-20230615151036096">
<p><strong>访问元素</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="./C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615151216828.png" alt="image-20230615151216828" style="zoom:50%;"></p>
<p>注：对于list容器不支持随机访问。</p>
<p><strong>使用迭代器访问</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="./C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615151337749.png" alt="image-20230615151337749" style="zoom:50%;"></p>
<p><strong>插入元素</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615151449580.png" class title="image-20230615151449580">
<p>还有：<code>c.emplace_back(t)</code></p>
<p><strong>删除元素</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615152153340.png" class title="image-20230615152153340">
<p><strong>容器比较</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="./C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615152240917.png" alt="image-20230615152240917" style="zoom: 50%;"></p>
<p><strong>容量操作</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615152339676.png" class title="image-20230615152339676">
<p><strong>容器的赋值和交换</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="./C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615152414454.png" alt="image-20230615152414454" style="zoom:50%;"></p>
<h4 id="关联容器">关联容器</h4>
<img lazyload src="/images/loading.svg" data-src="/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615152546198.png" class title="image-20230615152546198">
<p><strong>std::pair</strong></p>
<p><code>std::map</code>的某些函数使用了<code>&lt;utility&gt;</code>中的类<code>std::pair，pair&lt;T1, T2&gt;</code>代表一个由类型T1和类型T2组成的有序对。
可以直接用构造函数 <code>std::pair&lt;T1, T2&gt; (v1, v2)</code>
进行构造，也可以用make_pair进行构造：
<code>auto p = make_pair(v1, v2);</code>
通过p.first访问第一个元素，通过p.second访问第二个元素</p>
<h5 id="map">map</h5>
<p><strong>map的构造函数</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="./C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615152726812.png" alt="image-20230615152726812" style="zoom: 50%;"></p>
<p><strong>向map中插入元素</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;string, <span class="type">int</span>&gt; m = { { “hello”, <span class="number">1</span> } };</span><br><span class="line">m.<span class="built_in">insert</span>({ “h”, <span class="number">10</span> });</span><br><span class="line">m.<span class="built_in">insert</span>(std::pair{<span class="string">"Kageyama"</span>, <span class="number">180.6</span>});</span><br><span class="line">m.<span class="built_in">emplace</span>(<span class="string">"hh"</span>, <span class="number">233</span>);</span><br></pre></td></tr></table></figure></div>
<p>最简便的方法是直接用operator[]来插入元素：<code>m["me"] = 10</code></p>
<p><strong>在 map 中查找元素</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="./C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615152959585.png" alt="image-20230615152959585" style="zoom: 40%;"></p>
<p><strong>在map中删除元素</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="./C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615153058006.png" alt="image-20230615153058006" style="zoom:50%;"></p>
<h5 id="multimap">multimap</h5>
<ul>
<li>不支持下标操作</li>
<li><code>insert</code>
操作每调用一次都会增加新的元素（multimap容器中，键相同的元素相邻存放）。</li>
<li>以键值为参数的erase操作删除该键所关联的所有元素，并返回被删除元素的数目。</li>
<li>count 操作返回指定键的出现次数。</li>
<li>find 操作返回的迭代器指向与被查找键相关联的第一个元素。</li>
<li>结合使用count和find操作依次访问，multimap容器中与特定键关联的所有元素。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="./C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615153510895.png" alt="image-20230615153510895" style="zoom:40%;"></p>
<h5 id="set">set</h5>
<p>map支持的操作set基本上都支持，但有区别。如下： 1）不支持下标操作。
2）没有定义mapped_type类型
3）set容器定义的value_type类型不是pair类型，而是与key_type相同，指的都set中元素的类型。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; s = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> };</span><br><span class="line"><span class="keyword">auto</span> iter1 = s.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">auto</span> iter2 = s.<span class="built_in">insert</span>(<span class="number">3</span>); <span class="comment">// 返回值为指向之前的3的迭代器，没有实际插入发生</span></span><br><span class="line"><span class="keyword">auto</span> b = iter1 == iter2; <span class="comment">// b 为 true</span></span><br></pre></td></tr></table></figure></div>
<h4 id="适配器">适配器</h4>
<p>容器适配器提供顺序容器之上的不同功能接口（界面）。</p>
<p><img lazyload src="/images/loading.svg" data-src="./C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615153803274.png" alt="image-20230615153803274" style="zoom:50%;"></p>
<p><strong>队列 (queue) 功能接口（操作）</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615153832106.png" class title="image-20230615153832106">
<p>还有<code>emplace()</code></p>
<p><strong>优先队列（priority_queue）的功能接口（操作）</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615154012292.png" class title="image-20230615154012292">
<p><strong>适配器与容器</strong></p>
<ul>
<li><p>标准库中定义的容器适配器都是基于顺序容器建立的</p></li>
<li><p>程序员在创建适配器对象时可以选择相应的基础容器类</p>
<ul>
<li><p><code>stack</code> 适配器可以建立在 <code>vector</code>
、<code>list</code> 或 <code>deque</code> 容器</p>
<p>原因：高效支持尾部 <code>push(item)</code>,
<code>pop()</code></p></li>
<li><p><code>queue</code> 适配器只能建立在 <code>list</code> 或
<code>deque</code> 容器上。</p>
<p>原因：高效支持尾部 <code>push(item)</code>,
首部<code>pop()</code></p></li>
<li><p><code>priority_queue</code> 适配器只能建立在 <code>vector</code>
或 <code>deque</code> 容器上。</p>
<p>原因：高效支持堆排序</p></li>
</ul></li>
<li><p>如果创建适配器对象时不指定基础容器，则</p>
<ul>
<li><code>stack</code> 和 <code>queue</code>
默认采用<code>deque</code>实现</li>
<li>而 <code>priority_queue</code> 则默认采用 <code>vector</code>
实现。</li>
</ul></li>
</ul>
<h3 id="迭代器">迭代器</h3>
<p><strong>类别</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615154900417.png" class title="image-20230615154900417">
<img lazyload src="/images/loading.svg" data-src="/2023/03/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615154828914.png" class title="image-20230615154828914">
<p><img lazyload src="/images/loading.svg" data-src="./C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230615155036568.png" alt="image-20230615155036568" style="zoom:50%;"></p>
<h2 id="异常处理">异常处理</h2>
<h3 id="异常处理概述">异常处理概述</h3>
<p><strong>程序终止</strong></p>
<ul>
<li>正常终止：执行正常结束而终止</li>
<li>异常终止：程序执行中发生错误或特殊事件而终止
<ul>
<li>可预测的错误</li>
<li>用户自己定义的错误</li>
<li>难以预测的错误</li>
</ul></li>
</ul>
<p><strong>异常处理（exception handling）机制的基本思想</strong></p>
<ul>
<li>采用结构化方法对程序的运行时错误进行显示管理：
<ul>
<li>目标1：处理的是可预料的错误或特殊事件</li>
<li>目标2：将程序中的正常处理代码与异常处理代码显示区分开来，提高程序的可读性</li>
</ul></li>
</ul>
<p><strong>结构化方法的两种含义</strong></p>
<ul>
<li>结构化定义异常
<ul>
<li>将异常种类定义为树状结构</li>
</ul></li>
<li>结构化处理异常（异常检测 与 异常处理 分离）
<ul>
<li>异常检测：
<ul>
<li>异常检测部分检测到异常的存在时，抛出一个异常对象给异常处理代码。</li>
</ul></li>
<li>异常处理：
<ul>
<li>在程序或函数特定位置，集中捕获异常对象，再处理异常。</li>
</ul></li>
<li>通过该异常对象，独立开发的异常检测部分和异常处理部分就能够就程序执行期间出现的异常情况进行通信。</li>
</ul></li>
</ul>

        </div>

        
            <div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> C++ 基础知识学习</li>
        <li><strong>Author:</strong> 卡布叻_米菲</li>
        <li><strong>Created at
                :</strong> 2023-03-01 17:30:39</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-02-08 13:09:05
            </li>
        
        <li>
            <strong>Link:</strong> https://carolinebaby.github.io/2023/03/01/C++基础知识/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/C/">#C++</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                    <div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="prev"
                        rel="prev"
                        href="/2023/03/29/%E6%A0%91/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">树</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="next"
                        rel="next"
                        href="/2023/02/21/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">C++提高编程</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
            <div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
                <div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://caroline-world-42jy0ja18-carolinebaby.vercel.app',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          requiredMeta: ['nick', 'mail'],
          emoji: [],
          recaptchaV3Key: "wasd",
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

            </div>
        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">C++ 基础知识学习</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#c"><span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-text">类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="nav-text">主函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#io%E6%B5%81"><span class="nav-text">IO流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">命名空间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-text">引用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91%E5%BC%95%E7%94%A8"><span class="nav-text">转发引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8"><span class="nav-text">悬垂引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E5%80%BC%E4%B8%8E%E4%BC%A0%E5%BC%95%E7%94%A8"><span class="nav-text">传值与传引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E5%8F%98%E9%87%8F%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text">常变量、右值引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="nav-text">数据存储</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#c%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F%E7%AE%A1%E7%90%86"><span class="nav-text">C动态对象(变量)管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F%E7%AE%A1%E7%90%86-1"><span class="nav-text">C++动态对象(变量)管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88"><span class="nav-text">动态对象(变量)与对象指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">new 运算符的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#delete-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">delete 操作符的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-text">内存泄露</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#string-%E7%B1%BB"><span class="nav-text">string 类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-string-%E5%AF%B9%E8%B1%A1"><span class="nav-text">创建 string 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%90%E7%AE%97"><span class="nav-text">string 对象的运算</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="nav-text">数据抽象和类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">抽象数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E9%BB%98%E8%AE%A4%E7%9A%84%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89-default"><span class="nav-text">显示默认的函数定义：
&#x3D;default</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%83%E7%BD%AE%E5%87%BD%E6%95%B0delete"><span class="nav-text">弃置函数：&#x3D;delete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB"><span class="nav-text">结构体与类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">静态成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="nav-text">基本知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E6%96%B0%E7%B1%BB%E5%9E%8B-bool"><span class="nav-text">C++新类型 bool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#void-%E5%BD%A2%E5%8F%82"><span class="nav-text">void 形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-text">函数重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E6%96%B0%E7%89%B9%E6%80%A7-%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="nav-text">C++新特性-默认实参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B-string"><span class="nav-text">字符串类型-string</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E6%9C%89public%E6%88%90%E5%91%98"><span class="nav-text">公有(public)成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%81%E6%9C%89private%E6%88%90%E5%91%98"><span class="nav-text">私有(private)成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">无参构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">有参构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">拷贝构造函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this-%E6%8C%87%E9%92%88"><span class="nav-text">this 指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">对象成员初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8c11"><span class="nav-text">成员初始化器(C++11)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E9%87%8D%E8%BD%BD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">可以重载的运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E4%BB%A5%E9%87%8D%E8%BD%BD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">不可以重载的运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">移位运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-text">函数对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-text">友元函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#explicit-%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="nav-text">explicit 说明符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F"><span class="nav-text">继承和派生</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AF%E8%AF%AD"><span class="nav-text">术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-text">语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0"><span class="nav-text">构造</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E4%B8%AD%E4%B8%8D%E5%8F%AF%E7%BB%A7%E6%89%BF%E7%9A%84%E6%88%90%E5%91%98"><span class="nav-text">类中不可继承的成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91%E5%9F%BA%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%AE%9E%E5%8F%82"><span class="nav-text">向基类构造函数传递实参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E4%B8%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">派生与成员函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E7%BB%A7%E6%89%BF%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-text">改变继承访问控制方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-text">恢复访问控制方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%8F%E8%94%BD%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-text">屏蔽基类成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="nav-text">类型兼容性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">对象的类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="nav-text">多继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="nav-text">虚基类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96override-%E4%B8%8E-%E9%9A%90%E8%97%8Foverwrite"><span class="nav-text">覆盖(override) 与
隐藏(overwrite)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">多态的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A"><span class="nav-text">静态绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="nav-text">动态绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">纯虚函数与抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">虚析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rtti%E6%A6%82%E5%BF%B5"><span class="nav-text">RTTI概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="nav-text">泛型编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-text">函数模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-text">类模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%BD%A2%E5%8F%82"><span class="nav-text">非函数模板形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%BD%A2%E5%8F%82"><span class="nav-text">函数模板的非类型模板形参</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stl"><span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8"><span class="nav-text">容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">迭代器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%A6%82%E8%BF%B0"><span class="nav-text">异常处理概述</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">卡布叻_米菲</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        16 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.1</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>





    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>









<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>
